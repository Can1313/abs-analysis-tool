'stress' ANAHTAR KELİMESİ İÇİN ARAMA SONUÇLARI
======================================================================

FRONTEND SONUÇLARI:
==================

DOSYA: src\App.js
==================================================
// src/App.js
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";

import TopBar from "./components/TopBar";
import Footer from "./components/Footer";
import HomePage from "./pages/HomePage";
import CalculationPage from "./pages/CalculationPage";
import OptimizationPage from "./pages/OptimizationPage";
import StressTestingPage from "./pages/StressTestingPage";
import { DataProvider } from "./contexts/DataContext";
import ComparisonPage from "./pages/ComparisonPage";

// Create a dark navy theme
const theme = createTheme({
  palette: {
    mode: 'dark',
    primary: {
      main: '#4e7bea', // Modern blue
      light: '#6d92fd',
      dark: '#3461c7',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#9c27b0', // Purple
      light: '#bb4fd3',
      dark: '#7b1fa2',
      contrastText: '#ffffff',
    },
    error: {
      main: '#f44336',
      light: '#ff7961',
      dark: '#d32f2f',
    },
    warning: {
      main: '#ff9800',
      light: '#ffb74d',
      dark: '#f57c00',
    },
    info: {
      main: '#29b6f6',
      light: '#4fc3f7',
      dark: '#0288d1',
    },
    success: {
      main: '#4caf50',
      light: '#80e27e',
      dark: '#087f23',
    },
    background: {
      default: '#0f172a', // Dark navy
      paper: '#1e293b', // Lighter navy
    },
    text: {
      primary: '#e2e8f0',
      secondary: '#94a3b8',
    },
    divider: 'rgba(148, 163, 184, 0.12)',
  },
  typography: {
    fontFamily: '"Roboto", "Segoe UI", "Helvetica Neue", sans-serif',
    h4: {
      fontWeight: 500,
    },
    h5: {
      fontWeight: 500,
    },
    h6: {
      fontWeight: 500,
    },
    subtitle1: {
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none',
          boxShadow: '0 1px 3px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.7)',
          borderRadius: 8,
        },
        elevation1: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.7)',
        },
        elevation2: {
          boxShadow: '0 3px 6px rgba(0,0,0,0.7), 0 2px 4px rgba(0,0,0,0.8)',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          fontWeight: 500,
          borderRadius: 6,
        },
        contained: {
          boxShadow: '0 1px 2px rgba(0,0,0,0.3)',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        head: {
          fontWeight: 600,
          backgroundColor: 'rgba(78, 123, 234, 0.15)',
        },
      },
    },
    MuiTableRow: {
      styleOverrides: {
        root: {
          '&:last-child td': {
            borderBottom: 0,
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.7)',
          backgroundColor: '#0f172a', // Match background.default
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 6,
        },
      },
    },
    MuiSlider: {
      styleOverrides: {
        thumb: {
          height: 20,
          width: 20,
          backgroundColor: '#fff',
          border: '2px solid currentColor',
          '&:focus, &:hover, &.Mui-active, &.Mui-focusVisible': {
            boxShadow: 'inherit',
          },
        },
        valueLabel: {
          fontSize: 12,
          fontWeight: 'normal',
          top: -6,
          backgroundColor: 'unset',
          '&:before': {
            display: 'none',
          },
        },
      },
    },
    MuiCssBaseline: {
      styleOverrides: {
        body: {
          scrollbarColor: "#6b6b6b #2b2b2b",
          "&::-webkit-scrollbar, & *::-webkit-scrollbar": {
            backgroundColor: "#2b2b2b",
            width: 8,
          },
          "&::-webkit-scrollbar-thumb, & *::-webkit-scrollbar-thumb": {
            borderRadius: 8,
            backgroundColor: "#6b6b6b",
            minHeight: 24,
          },
          "&::-webkit-scrollbar-thumb:focus, & *::-webkit-scrollbar-thumb:focus": {
            backgroundColor: "#959595",
          },
          "&::-webkit-scrollbar-thumb:active, & *::-webkit-scrollbar-thumb:active": {
            backgroundColor: "#959595",
          },
          "&::-webkit-scrollbar-thumb:hover, & *::-webkit-scrollbar-thumb:hover": {
            backgroundColor: "#959595",
          },
        },
      },
    },
  },
});

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <DataProvider>
        <Router>
          <TopBar />
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/calculation" element={<CalculationPage />} />
            <Route path="/optimization" element={<OptimizationPage />} />
            <Route path="/comparison" element={<ComparisonPage />} />
            <Route path="/stress-testing" element={<StressTestingPage />} />
          </Routes>
          <Footer />
        </Router>
      </DataProvider>
    </ThemeProvider>
  );
}

export default App;

======================================================================

DOSYA: src\components\TopBar.js
==================================================
// frontend/src/components/TopBar.js
import React from 'react';
import { Link as RouterLink, useLocation } from 'react-router-dom';
import { 
  AppBar, 
  Toolbar, 
  Typography, 
  Button, 
  Box, 
  Container, 
  useTheme 
} from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import OptimizeIcon from '@mui/icons-material/Speed';
import HomeIcon from '@mui/icons-material/Home';
import CompareIcon from '@mui/icons-material/Compare';
import BusinessIcon from '@mui/icons-material/Business';
import AssessmentIcon from '@mui/icons-material/Assessment';
import { alpha } from '@mui/material/styles';

const TopBar = () => {
  const location = useLocation();
  const theme = useTheme();
  
  // Menu items with updated professional names
  const menuItems = [
    {
      path: '/',
      label: 'Dashboard',
      icon: <HomeIcon />
    },
    {
      path: '/calculation',
      label: 'Structure Analysis',
      icon: <CalculateIcon />
    },
    {
      path: '/optimization',
      label: 'Portfolio Optimizer',
      icon: <OptimizeIcon />
    },
    {
      path: '/comparison',
      label: 'Performance Metrics',
      icon: <CompareIcon />
    },
    {
      path: '/stress-testing',
      label: 'Stress Testing',
      icon: <AssessmentIcon />
    }
  ];
  
  return (
    <AppBar 
      position="static" 
      elevation={0}
      sx={{
        background: 'linear-gradient(90deg, #0f172a 0%, #1e293b 100%)',
        borderBottom: '1px solid rgba(78, 123, 234, 0.15)'
      }}
    >
      <Container maxWidth="lg">
        <Toolbar disableGutters>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              flexGrow: 1,
            }}
          >
            <BusinessIcon 
              sx={{ 
                fontSize: 28, 
                color: theme.palette.primary.main,
                mr: 1.5 
              }} 
            />
            <Typography
              variant="h6"
              component={RouterLink}
              to="/"
              sx={{
                textDecoration: 'none',
                color: 'inherit',
                fontWeight: 600,
                letterSpacing: 0.5,
              }}
            >
              Advanced ABS Design
            </Typography>
          </Box>
          
          <Box sx={{ display: 'flex', gap: 1 }}>
            {menuItems.map((item) => (
              <Button 
                key={item.path}
                color="inherit" 
                component={RouterLink} 
                to={item.path}
                startIcon={item.icon}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 1,
                  backgroundColor: location.pathname === item.path 
                    ? alpha(theme.palette.primary.main, 0.15) 
                    : 'transparent',
                  '&:hover': {
                    backgroundColor: location.pathname === item.path 
                      ? alpha(theme.palette.primary.main, 0.25) 
                      : alpha(theme.palette.primary.main, 0.1),
                  }
                }}
              >
                {item.label}
              </Button>
            ))}
          </Box>
        </Toolbar>
      </Container>
    </AppBar>
  );
};

export default TopBar;

======================================================================

DOSYA: src\contexts\DataContext.js
==================================================
/* -----------------------------------------------------------
 *  Global state & helpers (React Context)
 * --------------------------------------------------------- */

import React, {
  createContext,
  useContext,
  useEffect,
  useState,
} from 'react';

const DataContext = createContext();
export const useData = () => useContext(DataContext);

/* localStorage parse – prevents "undefined" errors */
const safeParse = (key, fallback) => {
  try {
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : fallback;
  } catch {
    localStorage.removeItem(key);
    return fallback;
  }
};

/* -----------------------------------------------------------
 *              DEFAULT SETTINGS
 * --------------------------------------------------------- */
const DEFAULT_SETTINGS = {
  previous: {
    generalSettings: {
      start_date: new Date(2025, 1, 13),
      operational_expenses: 7_928_640,
      min_buffer: 5,
    },
    tranchesA: [
      { maturity_days: 61, base_rate: 45.6, spread: 0, reinvest_rate: 40, nominal: 480_000_000 },
      { maturity_days: 120, base_rate: 44.5, spread: 0, reinvest_rate: 37.25, nominal: 460_000_000 },
      { maturity_days: 182, base_rate: 43.3, spread: 0, reinvest_rate: 32.5, nominal: 425_000_000 },
      { maturity_days: 274, base_rate: 42.5, spread: 0, reinvest_rate: 30, nominal: 400_000_000 },
    ],
    trancheB: {
      maturity_days: 300,
      base_rate: 0,
      spread: 0,
      reinvest_rate: 25.5,
      /* nominal empty – will be filled when optimization comes */
    }
  },
  new: {
    generalSettings: {
      start_date: new Date(2025, 3, 16), // April 16, 2025
      operational_expenses: 10_000_000,
      min_buffer: 5,
    },
    tranchesA: [
      { maturity_days: 59, base_rate: 45.5, spread: 0, reinvest_rate: 41.0, nominal: 980_000_000 },
      { maturity_days: 94, base_rate: 45.5, spread: 0, reinvest_rate: 38.5, nominal: 600_000_000 },
      { maturity_days: 150, base_rate: 45.5, spread: 0, reinvest_rate: 35.0, nominal: 590_000_000 },
      { maturity_days: 189, base_rate: 45.5, spread: 0, reinvest_rate: 33.5, nominal: 420_000_000 },
      { maturity_days: 275, base_rate: 45.5, spread: 0, reinvest_rate: 31.5, nominal: 579_600_000 },
    ],
    trancheB: {
      maturity_days: 346,
      base_rate: 0,
      spread: 0,
      reinvest_rate: 30.0,
      // For new default settings, Class B percentage should be 10%
      class_b_percent: 10 // Will be used to calculate nominal dynamically
    }
  }
};

/* Default stress test scenarios */
const DEFAULT_STRESS_SCENARIOS = {
  base: {
    name: "Base",
    npl_rate: 1.5,
    prepayment_rate: 30,
    reinvestment_shift: 0
  },
  moderate: {
    name: "Moderate",
    npl_rate: 3,
    prepayment_rate: 15,
    reinvestment_shift: -3
  },
  severe: {
    name: "Severe",
    npl_rate: 5,
    prepayment_rate: 10,
    reinvestment_shift: -5
  },
  extreme: {
    name: "Extreme",
    npl_rate: 7,
    prepayment_rate: 5,
    reinvestment_shift: -10
  }
};

/* -----------------------------------------------------------
 *              <DataProvider>
 * --------------------------------------------------------- */
export const DataProvider = ({ children }) => {
  /* ------------------- Core flags ------------------ */
  const [cashFlowData, setCashFlowData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [selectedDefaults, setSelectedDefaults] = useState(() => 
    localStorage.getItem('selectedDefaults') || 'previous'
  );

  /* ---------------- Form defaults ------------------ */
  const [generalSettings, setGeneralSettings] = useState(() => 
    safeParse('generalSettings', DEFAULT_SETTINGS[selectedDefaults].generalSettings)
  );
  
  const [tranchesA, setTranchesA] = useState(() => 
    safeParse('tranchesA', DEFAULT_SETTINGS[selectedDefaults].tranchesA)
  );
  
  const [trancheB, setTrancheB] = useState(() => 
    safeParse('trancheB', DEFAULT_SETTINGS[selectedDefaults].trancheB)
  );

  const [npvSettings, setNpvSettings] = useState({
    method: 'weighted_avg_rate',
    custom_rate: 40,
  });

  /* ---------------- Optimization defaults ------------------ */
  const [optimizationSettings, setOptimizationSettings] = useState({
    optimization_method: 'classic',
    a_tranches_range: [2, 6],
    maturity_range: [32, 365],
    maturity_step: 10,
    min_class_b_percent: 10,
    target_class_b_coupon_rate: 30,
    additional_days_for_class_b: 10,
    population_size: 50,
    num_generations: 40,
  });

  /* ---------------- Stress Test state ------------------ */
  const [stressTestResults, setStressTestResults] = useState(() =>
    safeParse('stressTestResults', null)
  );
  
  const [stressScenarios, setStressScenarios] = useState(() =>
    safeParse('stressScenarios', DEFAULT_STRESS_SCENARIOS)
  );
  
  const [stressTestHistory, setStressTestHistory] = useState(() =>
    safeParse('stressTestHistory', [])
  );

  /* -------------- originals for <Reset> -------------- */
  const [origA, setOrigA] = useState(null);
  const [origB, setOrigB] = useState(null);
  useEffect(() => {
    if (!origA) setOrigA(JSON.parse(JSON.stringify(tranchesA)));
    if (!origB) setOrigB(JSON.parse(JSON.stringify(trancheB)));
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  /* ------------------ Stored results ---------------- */
  const [calculationResults, setCalculationResults] = useState(() =>
    safeParse('calculationResults', null),
  );
  const [optimizationResults, setOptimizationResults] = useState(() =>
    safeParse('optimizationResults', null),
  );
  const [previousCalculationResults, setPreviousCalc] = useState(() =>
    safeParse('previousCalculationResults', null),
  );
  const [savedResults, setSavedResults] = useState(() =>
    safeParse('savedResults', []),
  );
  const [multipleComparisonResults, setMultiResults] = useState(() =>
    safeParse('multipleComparisonResults', []),
  );

  /* -------------- Default settings selection -------------- */
  // Update everything when default settings change
  useEffect(() => {
    localStorage.setItem('selectedDefaults', selectedDefaults);
    setGeneralSettings(DEFAULT_SETTINGS[selectedDefaults].generalSettings);
    setTranchesA(DEFAULT_SETTINGS[selectedDefaults].tranchesA);
    
    // Make a deep copy of the tranche B
    const newTrancheB = JSON.parse(JSON.stringify(DEFAULT_SETTINGS[selectedDefaults].trancheB));
    
    // If it's the new model, calculate and set Class B nominal based on percentage
    if (selectedDefaults === 'new' && newTrancheB.class_b_percent) {
      // Calculate total Class A nominal
      const totalClassANominal = DEFAULT_SETTINGS[selectedDefaults].tranchesA.reduce(
        (sum, tranche) => sum + tranche.nominal, 0
      );
      
      // Calculate Class B nominal using the formula:
      // class_b_nominal = totalClassANominal * (classBPercent / (100 - classBPercent))
      const classBPercent = newTrancheB.class_b_percent;
      const b_percent = classBPercent / 100;
      let b_nominal = (totalClassANominal * b_percent) / (1 - b_percent);
      
      // Round to nearest 1000
      b_nominal = Math.round(b_nominal / 1000) * 1000;
      
      // Set the calculated nominal
      newTrancheB.nominal = b_nominal;
      
      console.log(`Using new model with 10% Class B. Total Class A: ${totalClassANominal}, Class B nominal: ${b_nominal}`);
    }
    
    setTrancheB(newTrancheB);
    
    // Update originals for reset functionality
    setOrigA(JSON.parse(JSON.stringify(DEFAULT_SETTINGS[selectedDefaults].tranchesA)));
    setOrigB(JSON.parse(JSON.stringify(newTrancheB)));
  }, [selectedDefaults]);

  /* -------------- localStorage wrappers -------------- */
  const wrapLocal = (setter, key) => (val) => {
    setter(val);
    if (val && (Array.isArray(val) ? val.length : true))
      localStorage.setItem(key, JSON.stringify(val));
    else localStorage.removeItem(key);
  };

  const setCalcResLS   = wrapLocal(setCalculationResults, 'calculationResults');
  const setOptResLS    = wrapLocal(setOptimizationResults, 'optimizationResults');
  const setPrevCalcLS  = wrapLocal(setPreviousCalc, 'previousCalculationResults');
  const setSavedResLS  = wrapLocal(setSavedResults, 'savedResults');
  const setMultiResLS  = wrapLocal(setMultiResults, 'multipleComparisonResults');
  const setStressResLS = wrapLocal(setStressTestResults, 'stressTestResults');
  const setStressScenLS = wrapLocal(setStressScenarios, 'stressScenarios');
  const setStressHistLS = wrapLocal(setStressTestHistory, 'stressTestHistory');

  /* ---------------------- helpers -------------------- */
  const saveResult = (result, name, methodType) => {
    if (!result) return false;
    const stamped = {
      ...result,
      id: Date.now().toString(),
      savedName: name,
      timestamp: new Date().toISOString(),
      methodType: methodType || result.method_type || 'manual',
    };
    setSavedResLS([...savedResults, stamped]);
    return true;
  };
  
  const saveStressTestResult = (result, scenarioName, structureId) => {
    if (!result) return false;
    const stamped = {
      ...result,
      id: Date.now().toString(),
      scenarioName: scenarioName,
      structureId: structureId,
      timestamp: new Date().toISOString(),
    };
    setStressHistLS([...stressTestHistory, stamped]);
    return true;
  };
  
  const deleteStressTestResult = (id) => 
    setStressHistLS(stressTestHistory.filter(r => r.id !== id));
  
  const clearStressTestHistory = () => 
    setStressHistLS([]);
    
  const deleteSavedResult  = (id) => setSavedResLS(savedResults.filter(r => r.id !== id));
  const clearSavedResults  = () => setSavedResLS([]);
  const clearComparisonData = () => setMultiResLS([]);

  const resetToDefaults = () => {
    if (origA && origB) {
      setTranchesA(JSON.parse(JSON.stringify(origA)));
      setTrancheB(JSON.parse(JSON.stringify(origB)));
      return true;
    }
    return false;
  };

  const clearData = () => {
    setCashFlowData(null);
    setCalcResLS(null);
    setOptResLS(null);
    setError(null);
  };

  /* ---------- request constructors ---------- */
  const createCalculationRequest = () => {
    // Check if we're using the new default settings with Class B percentage
    const isNewDefault = selectedDefaults === 'new';
    const classBPercent = isNewDefault && trancheB.class_b_percent ? trancheB.class_b_percent : null;
    
    // Calculate Class B nominal if percentage is provided
    let modifiedTrancheB = { ...trancheB };
    
    if (classBPercent) {
      // Calculate total Class A nominal
      const totalClassANominal = tranchesA.reduce((sum, tranche) => sum + tranche.nominal, 0);
      
      // Calculate Class B nominal using the formula:
      // class_b_nominal = totalClassANominal * (classBPercent / (100 - classBPercent))
      const b_percent = classBPercent / 100;
      let b_nominal = (totalClassANominal * b_percent) / (1 - b_percent);
      
      // Round to nearest 1000
      b_nominal = Math.round(b_nominal / 1000) * 1000;
      
      // Set the calculated nominal
      modifiedTrancheB.nominal = b_nominal;
    }
    
    return {
      general_settings: {
        start_date: generalSettings.start_date.toISOString().split('T')[0],
        operational_expenses: generalSettings.operational_expenses,
        min_buffer: generalSettings.min_buffer,
      },
      tranches_a: tranchesA,
      tranche_b: modifiedTrancheB,
      npv_settings: npvSettings,
    };
  };

  const createOptimizationRequest = () => ({
    optimization_settings: optimizationSettings,
    general_settings: {
      start_date: generalSettings.start_date.toISOString().split('T')[0],
      operational_expenses: generalSettings.operational_expenses,
      min_buffer: generalSettings.min_buffer,
    },
    selected_default_model: selectedDefaults
  });

  const createStressTestRequest = (structure, scenario) => {
    // Get structure details
    const structureDetails = typeof structure === 'string' ? 
      savedResults.find(r => r.id === structure) : structure;
      
    if (!structureDetails) {
      throw new Error("Structure not found");
    }
    
    // Format structure for API
    const formattedStructure = {
      start_date: structureDetails.start_date ||
                 (structureDetails.general_settings?.start_date instanceof Date ? 
                  structureDetails.general_settings.start_date.toISOString().split('T')[0] :
                  structureDetails.general_settings?.start_date),
      a_maturities: [],
      a_base_rates: [],
      a_spreads: [],
      a_reinvest_rates: [],
      a_nominals: [],
      b_maturity: structureDetails.tranche_b?.maturity_days || 180,
      b_base_rate: structureDetails.tranche_b?.base_rate || 0,
      b_spread: structureDetails.tranche_b?.spread || 0,
      b_reinvest_rate: structureDetails.tranche_b?.reinvest_rate || 0,
      b_nominal: structureDetails.tranche_b?.nominal || 0,
      ops_expenses: Number(structureDetails.general_settings?.operational_expenses || 0)
    };
    
    // Properly extract Class A tranches data
    if (Array.isArray(structureDetails.tranches_a)) {
      structureDetails.tranches_a.forEach(tranche => {
        formattedStructure.a_maturities.push(Number(tranche.maturity_days));
        formattedStructure.a_base_rates.push(Number(tranche.base_rate));
        formattedStructure.a_spreads.push(Number(tranche.spread));
        formattedStructure.a_reinvest_rates.push(Number(tranche.reinvest_rate));
        formattedStructure.a_nominals.push(Number(tranche.nominal));
      });
    }
    
    // Return complete request
    return {
      structure: formattedStructure,
      scenario: scenario
    };
  };

  /* ---------------- context value ------------------- */
  const value = {
    /* raw data */
    cashFlowData,
    setCashFlowData,
    isLoading,
    setIsLoading,
    error,
    setError,

    /* form state */
    generalSettings,
    setGeneralSettings,
    tranchesA,
    setTranchesA,
    trancheB,
    setTrancheB,
    npvSettings,
    setNpvSettings,

    /* default settings selection */
    selectedDefaults,
    setSelectedDefaults,
    defaultOptions: Object.keys(DEFAULT_SETTINGS),

    /* optimization settings */
    optimizationSettings,
    setOptimizationSettings,
    
    /* stress test settings */
    stressTestResults,
    setStressTestResults: setStressResLS,
    stressScenarios,
    setStressScenarios: setStressScenLS,
    stressTestHistory,
    setStressTestHistory: setStressHistLS,
    saveStressTestResult,
    deleteStressTestResult,
    clearStressTestHistory,

    /* results */
    calculationResults,
    setCalculationResults: setCalcResLS,
    optimizationResults,
    setOptimizationResults: setOptResLS,
    previousCalculationResults,
    setPreviousCalculationResults: setPrevCalcLS,

    /* saved / comparison */
    savedResults,
    setSavedResults: setSavedResLS,
    saveResult,
    deleteSavedResult,
    clearSavedResults,
    multipleComparisonResults,
    setMultipleComparisonResults: setMultiResLS,
    clearComparisonData,

    /* misc helpers */
    resetToDefaults,
    clearData,
    createCalculationRequest,
    createOptimizationRequest,
    createStressTestRequest,
  };

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
};

======================================================================

DOSYA: src\pages\StressTestingPage.js
==================================================
import React, { useState, useEffect } from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper, 
  Grid, 
  Slider, 
  TextField, 
  Button, 
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Divider,
  alpha,
  IconButton,
  Tooltip,
  CircularProgress,
  Snackbar,
  Alert,
  Tab,
  Tabs,
  LinearProgress
} from '@mui/material';

import AssessmentIcon from '@mui/icons-material/Assessment';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import TrendingUpIcon from '@mui/icons-material/TrendingUp';
import TrendingDownIcon from '@mui/icons-material/TrendingDown';
import AttachMoneyIcon from '@mui/icons-material/AttachMoney';
import ShowChartIcon from '@mui/icons-material/ShowChart';
import SaveAltIcon from '@mui/icons-material/SaveAlt';
import PieChartIcon from '@mui/icons-material/PieChart';
import TableChartIcon from '@mui/icons-material/TableChart';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';

import { useData } from '../contexts/DataContext';
import { useNavigate } from 'react-router-dom';
import { useTheme } from '@mui/material';
import { runEnhancedStressTest, formatStructureForStressTest } from '../services/apiService';

// Recharts components
import {
  LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip as RechartsTooltip, 
  Legend, ResponsiveContainer, AreaChart, Area, BarChart, Bar, ScatterChart, 
  Scatter, ZAxis, ReferenceLine, PieChart, Pie, Cell
} from 'recharts';

// Custom tooltip for charts
const CustomTooltip = ({ active, payload, label }) => {
  const theme = useTheme();
  if (active && payload && payload.length) {
    return (
      <Paper sx={{ p: 2, boxShadow: 3 }}>
        <Typography variant="subtitle2" gutterBottom>
          {label}
        </Typography>
        
        {payload.map((entry, index) => (
          <Box key={`tooltip-item-${index}`} sx={{ display: 'flex', justifyContent: 'space-between', my: 0.5 }}>
            <Typography variant="body2" color="text.secondary" sx={{ mr: 2 }}>
              {entry.name}:
            </Typography>
            <Typography variant="body2" fontWeight="medium" sx={{ color: entry.color }}>
              {typeof entry.value === 'number' 
                ? entry.value.toFixed(2) + (entry.unit || '%')
                : entry.value}
            </Typography>
          </Box>
        ))}
      </Paper>
    );
  }
  return null;
};

// Main StressTestingPage component
const StressTestingPage = () => {
  const theme = useTheme();
  const { 
    savedResults, 
    stressScenarios,
    setStressScenarios,
    stressTestResults,
    setStressTestResults,
    saveStressTestResult,
    createStressTestRequest
  } = useData();
  const navigate = useNavigate();
  
  // State variables
  const [isLoading, setIsLoading] = useState(false);
  const [tabValue, setTabValue] = useState(0);
  
  // Scenario parameters
  const [nplRate, setNplRate] = useState(1.5);
  const [prepaymentRate, setPrepaymentRate] = useState(30);
  const [reinvestmentShift, setReinvestmentShift] = useState(0);
  const [recoveryRate, setRecoveryRate] = useState(0.5);
  const [recoveryLag, setRecoveryLag] = useState(90);
  const [delinquencyRate, setDelinquencyRate] = useState(null);
  
  // Scenario type
  const [scenarioType, setScenarioType] = useState('base');
  
  // Structure selection
  const [selectedStructureId, setSelectedStructureId] = useState('');
  const [availableStructures, setAvailableStructures] = useState([]);
  
  // Notifications
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [snackbarSeverity, setSnackbarSeverity] = useState('success');
  
  // Results display
  const [showResults, setShowResults] = useState(false);
  const [testResults, setTestResults] = useState({
    classBRate: {
      original: null,
      stressed: null,
      difference: null
    },
    cashFlowMetrics: {
      reductionPct: null,
      nplImpact: null,
      prepaymentTotal: null,
      reinvestmentTotal: null
    },
    modeledCashflows: []
  });
  
  // Get available structures on component mount
  useEffect(() => {
    if (savedResults && savedResults.length > 0) {
      const structures = savedResults.map(result => ({
        id: result.id,
        name: result.savedName || `${result.methodType || 'Default'} Structure`,
        type: result.methodType || 'default',
        classBCouponRate: result.class_b_coupon_rate || result.stressed_class_b_rate || 0,
        originalData: result // Store the entire result for later use
      }));
      
      setAvailableStructures(structures);
      
      if (structures.length > 0 && !selectedStructureId) {
        setSelectedStructureId(structures[0].id);
      }
    }
  }, [savedResults, selectedStructureId]);
  
  // Check if we have stored stress test results
  useEffect(() => {
    if (stressTestResults && 
        stressTestResults.structureId === selectedStructureId && 
        stressTestResults.scenarioType === scenarioType) {
      setTestResults(stressTestResults);
      setShowResults(true);
    }
  }, [stressTestResults, selectedStructureId, scenarioType]);
  
  // Tab change handler
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  // Structure selection handler
  const handleStructureChange = (event) => {
    setSelectedStructureId(event.target.value);
  };
  
  // Get the selected structure
  const getSelectedStructure = () => {
    return availableStructures.find(structure => structure.id === selectedStructureId) || null;
  };
  
  // Scenario selection handler
  const handleScenarioChange = (type) => {
    setScenarioType(type);
    
    // Update parameters based on scenario type
    if (stressScenarios && stressScenarios[type]) {
      const scenario = stressScenarios[type];
      setNplRate(scenario.npl_rate);
      setPrepaymentRate(scenario.prepayment_rate);
      setReinvestmentShift(scenario.reinvestment_shift);
    } else {
      // Default values if scenario not found
      switch (type) {
        case 'base':
          setNplRate(1.5);
          setPrepaymentRate(30);
          setReinvestmentShift(0);
          break;
        case 'moderate':
          setNplRate(3);
          setPrepaymentRate(15);
          setReinvestmentShift(-3);
          break;
        case 'severe':
          setNplRate(5);
          setPrepaymentRate(10);
          setReinvestmentShift(-5);
          break;
        default:
          // Keep current values for custom scenario
          break;
      }
    }
  };
  
  // Navigate back to calculation
  const handleNavigateToCalculation = () => {
    navigate('/calculation');
  };
  
  // Run stress test
  const handleRunStressTest = async () => {
    const selectedStructure = getSelectedStructure();
    
    if (!selectedStructure) {
      setSnackbarMessage("Please select a structure to test");
      setSnackbarSeverity("error");
      setSnackbarOpen(true);
      return;
    }
    
    setIsLoading(true);
    setShowResults(false);
    
    try {
      // Get structure details from savedResults
      const structureDetails = savedResults.find(r => r.id === selectedStructureId);
      
      if (!structureDetails) {
        throw new Error("Structure details not found");
      }
      
      // Structure'ı manuel olarak formatlayalım
      const manuallyFormattedStructure = {
        start_date: structureDetails.start_date || "2025-02-12",
        a_maturities: [],
        a_base_rates: [],
        a_spreads: [],
        a_reinvest_rates: [],
        a_nominals: [],
        b_maturity: 300,
        b_base_rate: 0,
        b_spread: 0,
        b_reinvest_rate: 25.5,
        b_nominal: 200000000,
        ops_expenses: structureDetails.general_settings?.operational_expenses || 0
      };
      
      // Eğer tranche_results varsa ondan değerleri al
      if (structureDetails.tranche_results && Array.isArray(structureDetails.tranche_results)) {
        for (const tranche of structureDetails.tranche_results) {
          if (tranche["Is Class A"]) {
            manuallyFormattedStructure.a_maturities.push(tranche["Maturity Days"]);
            manuallyFormattedStructure.a_base_rates.push(parseFloat(tranche["Base Rate (%)"] || 0));
            manuallyFormattedStructure.a_spreads.push(parseFloat(tranche["Spread (bps)"] || 0));
            manuallyFormattedStructure.a_reinvest_rates.push(40); // Varsayılan değer
            manuallyFormattedStructure.a_nominals.push(tranche["Principal"] || 0);
          } else {
            manuallyFormattedStructure.b_maturity = tranche["Maturity Days"];
            manuallyFormattedStructure.b_base_rate = parseFloat(tranche["Base Rate (%)"] || 0);
            manuallyFormattedStructure.b_spread = parseFloat(tranche["Spread (bps)"] || 0);
            manuallyFormattedStructure.b_reinvest_rate = 25.5; // Varsayılan değer
            manuallyFormattedStructure.b_nominal = tranche["Principal"] || 0;
          }
        }
      }
      
      // Eğer Class A tranches bulunamadıysa, varsayılan değerler kullan
      if (manuallyFormattedStructure.a_maturities.length === 0) {
        manuallyFormattedStructure.a_maturities = [61, 120, 182, 274];
        manuallyFormattedStructure.a_base_rates = [45.6, 44.5, 43.3, 42.5];
        manuallyFormattedStructure.a_spreads = [0, 0, 0, 0];
        manuallyFormattedStructure.a_reinvest_rates = [40, 37.25, 32.5, 30];
        manuallyFormattedStructure.a_nominals = [480000000, 460000000, 425000000, 400000000];
      }
      
      // Create scenario parameters
      const scenarioParams = {
        name: scenarioType,
        npl_rate: nplRate,
        prepayment_rate: prepaymentRate,
        reinvestment_shift: reinvestmentShift,
        recovery_rate: recoveryRate,
        recovery_lag: recoveryLag,
        delinquency_rate: delinquencyRate
      };
      
      // Update scenario in state for future use
      const updatedScenarios = {
        ...stressScenarios,
        [scenarioType]: {
          ...scenarioParams
        }
      };
      setStressScenarios(updatedScenarios);
      
      // Create request parameters
      const requestParams = {
        structure: manuallyFormattedStructure,
        scenario: scenarioParams
      };
      
      // Call API
      const response = await runEnhancedStressTest(requestParams);
      
      // Process results with correct property names from API response
      const resultsData = {
        structureId: selectedStructureId,
        scenarioType: scenarioType,
        classBRate: {
          original: response.baseline?.class_b_coupon_rate || 0,
          stressed: response.stress_test?.class_b_coupon_rate || 0,
          difference: response.difference?.class_b_coupon_rate || 0
        },
        cashFlowMetrics: {
          reductionPct: response.difference?.cashflow_reduction_pct || 0,
          nplImpact: response.stress_test?.total_npl_impact || 0,
          prepaymentTotal: response.stress_test?.total_prepayment || 0,
          reinvestmentTotal: response.stress_test?.total_reinvestment || 0
        },
        modeledCashflows: response.cashflows?.stress || []
      };
      
      // Update state
      setTestResults(resultsData);
      setStressTestResults(resultsData);
      
      // Save test result to history
      saveStressTestResult(
        resultsData, 
        `${scenarioType.charAt(0).toUpperCase() + scenarioType.slice(1)} Scenario`, 
        selectedStructureId
      );
      
      setIsLoading(false);
      setShowResults(true);
      
      // Show success message
      setSnackbarMessage("Stress test completed successfully");
      setSnackbarSeverity("success");
      setSnackbarOpen(true);
      
    } catch (error) {
      console.error("Error running stress test:", error);
      setIsLoading(false);
      
      let errorMessage = "Error running stress test";
      if (error.response && error.response.data) {
        errorMessage += ": " + (error.response.data.detail || error.response.data);
      } else if (error.message) {
        errorMessage += ": " + error.message;
      }
      
      setSnackbarMessage(errorMessage);
      setSnackbarSeverity("error");
      setSnackbarOpen(true);
    }
  };
  
  // Close snackbar
  const handleCloseSnackbar = () => {
    setSnackbarOpen(false);
  };
  
  // Export results
  const handleExportResults = () => {
    if (!showResults) return;
    
    try {
      const selectedStructure = getSelectedStructure();
      const scenarioName = scenarioType.charAt(0).toUpperCase() + scenarioType.slice(1);
      
      // Create export data
      const exportData = {
        testDate: new Date().toISOString(),
        structure: {
          id: selectedStructureId,
          name: selectedStructure?.name || 'Unknown Structure'
        },
        scenario: {
          name: scenarioName,
          npl_rate: nplRate,
          prepayment_rate: prepaymentRate,
          reinvestment_shift: reinvestmentShift,
          recovery_rate: recoveryRate
        },
        results: testResults
      };
      
      // Convert to JSON
      const jsonStr = JSON.stringify(exportData, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      
      // Create download link
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `stress-test-${selectedStructureId}-${scenarioType}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      setSnackbarMessage("Results exported successfully");
      setSnackbarSeverity("success");
      setSnackbarOpen(true);
      
    } catch (error) {
      console.error("Export error:", error);
      setSnackbarMessage("Error exporting results");
      setSnackbarSeverity("error");
      setSnackbarOpen(true);
    }
  };
  
  // Get color based on difference value
  const getDifferenceColor = (diff) => {
    if (diff >= 0) return theme.palette.success.main;
    if (diff >= -3) return theme.palette.warning.main;
    return theme.palette.error.main;
  };
  
  // Format pie chart data
  const formatPieData = () => {
    const { classBRate } = testResults;
    
    if (!classBRate.original) {
      return [];
    }
    
    return [
      { 
        name: "Class B Rate", 
        value: Math.max(0, classBRate.stressed), 
        color: theme.palette.primary.main 
      },
      { 
        name: "Stress Loss", 
        value: Math.max(0, classBRate.original - classBRate.stressed), 
        color: theme.palette.error.main 
      }
    ];
  };
  
  // Format cashflow comparison data
  const formatCashflowComparisonData = () => {
    if (!testResults.modeledCashflows || testResults.modeledCashflows.length === 0) {
      return [];
    }
    
    // Use first 10 cashflows for comparison
    return testResults.modeledCashflows.slice(0, 10).map(cf => ({
      date: new Date(cf.installment_date).toLocaleDateString(),
      original: cf.original_cashflow,
      actual: cf.total_actual_cashflow,
      difference: cf.total_actual_cashflow - cf.original_cashflow,
      percentDiff: ((cf.total_actual_cashflow / cf.original_cashflow) - 1) * 100
    }));
  };
  
  // Scenario comparison data
  const scenarioComparisonData = [
    {
      name: "Base Case",
      npl: 0,
      prepayment: 30,
      reinvestment: 0,
      rate: testResults.classBRate.original || 0
    },
    {
      name: scenarioType.charAt(0).toUpperCase() + scenarioType.slice(1),
      npl: nplRate,
      prepayment: prepaymentRate,
      reinvestment: reinvestmentShift,
      rate: testResults.classBRate.stressed || 0
    }
  ];
  
  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      {/* Page Header */}
      <Box
        sx={{
          mb: 4,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between'
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <AssessmentIcon 
            sx={{ 
              fontSize: 36, 
              color: theme.palette.primary.main,
              mr: 2,
            }} 
          />
          <Box>
            <Typography variant="h4" fontWeight="500">
              Stress Testing
            </Typography>
            <Typography variant="subtitle1" color="text.secondary">
              Analyze Class B coupon performance under various market conditions
            </Typography>
          </Box>
        </Box>
        
        <Box sx={{ display: 'flex', gap: 2 }}>
          <Button
            variant="outlined"
            color="primary"
            startIcon={<ArrowBackIcon />}
            onClick={handleNavigateToCalculation}
          >
            Back to Structure Analysis
          </Button>
          
          <Button
            variant="contained"
            color="primary"
            startIcon={<SaveAltIcon />}
            disabled={!showResults}
            onClick={handleExportResults}
          >
            Export Results
          </Button>
        </Box>
      </Box>
      
      <Grid container spacing={4}>
        {/* Left Panel: Structure Selection and Parameters */}
        <Grid item xs={12} md={4}>
          <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
            {/* Structure Selection */}
            <Paper
              elevation={3}
              sx={{
                p: 3,
                borderRadius: 2,
                backgroundColor: alpha(theme.palette.background.paper, 0.8),
              }}
            >
              <Typography variant="h6" gutterBottom>
                Stress Test Structure
              </Typography>
              
              {availableStructures.length > 0 ? (
                <FormControl fullWidth variant="outlined">
                  <InputLabel id="structure-select-label">Select Structure</InputLabel>
                  <Select
                    labelId="structure-select-label"
                    value={selectedStructureId}
                    onChange={handleStructureChange}
                    label="Select Structure"
                  >
                    {availableStructures.map((structure) => (
                      <MenuItem key={structure.id} value={structure.id}>
                        {structure.name}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>
              ) : (
                <Alert 
                  severity="info"
                  action={
                    <Button color="inherit" size="small" onClick={handleNavigateToCalculation}>
                      Go to Analysis
                    </Button>
                  }
                >
                  No saved structures found. Please calculate and save at least one structure before running stress tests.
                </Alert>
              )}
              
              {getSelectedStructure() && (
                <Box sx={{ mt: 2, p: 2, borderRadius: 1, bgcolor: alpha(theme.palette.info.main, 0.05) }}>
                  <Typography variant="subtitle2" gutterBottom>Selected Structure Details:</Typography>
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}>
                      <Typography variant="body2" color="text.secondary">Type:</Typography>
                      <Typography variant="body1">
                        {getSelectedStructure().type === 'manual' ? 'Manual Calculation' : 
                         getSelectedStructure().type === 'genetic' ? 'Genetic Algorithm' : 
                         'Standard Algorithm'}
                      </Typography>
                    </Grid>
                    <Grid item xs={12} sm={6}>
                      <Typography variant="body2" color="text.secondary">Class B Coupon Rate:</Typography>
                      <Typography variant="body1" fontWeight="medium" color="primary">
                        {getSelectedStructure().classBCouponRate.toFixed(2)}%
                      </Typography>
                    </Grid>
                  </Grid>
                </Box>
              )}
            </Paper>
            
            {/* Scenario Selection */}
            <Paper
              elevation={3}
              sx={{
                p: 3,
                borderRadius: 2,
                backgroundColor: alpha(theme.palette.background.paper, 0.8),
              }}
            >
              <Typography variant="h6" gutterBottom>
                Stress Scenario
              </Typography>
              
              <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2, mt: 2, mb: 3 }}>
                <Button
                  variant={scenarioType === 'base' ? 'contained' : 'outlined'}
                  color="primary"
                  onClick={() => handleScenarioChange('base')}
                  size="medium"
                >
                  Base
                </Button>
                
                <Button
                  variant={scenarioType === 'moderate' ? 'contained' : 'outlined'}
                  color="secondary"
                  onClick={() => handleScenarioChange('moderate')}
                  size="medium"
                >
                  Moderate
                </Button>
                
                <Button
                  variant={scenarioType === 'severe' ? 'contained' : 'outlined'}
                  color="error"
                  onClick={() => handleScenarioChange('severe')}
                  size="medium"
                >
                  Severe
                </Button>
                
                <Button
                  variant={scenarioType === 'custom' ? 'contained' : 'outlined'}
                  onClick={() => handleScenarioChange('custom')}
                  size="medium"
                >
                  Custom
                </Button>
              </Box>
              
              <Divider sx={{ my: 2 }} />
              
              {/* Parameter Settings */}
              <Box sx={{ mt: 3 }}>
                <Typography variant="subtitle2" display="flex" alignItems="center">
                  <WarningAmberIcon sx={{ fontSize: 20, mr: 1, color: theme.palette.warning.main }} />
                  NPL Rate (%)
                  <Tooltip title="Non-Performing Loan rate affects the cash flow available for Class B payment" sx={{ ml: 1 }}>
                    <IconButton size="small">
                      <InfoOutlinedIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Typography>
                <Slider
                  value={nplRate}
                  onChange={(e, value) => setNplRate(value)}
                  valueLabelDisplay="auto"
                  min={0}
                  max={15}
                  step={0.5}
                  marks={[
                    { value: 0, label: '0%' },
                    { value: 5, label: '5%' },
                    { value: 15, label: '15%' }
                  ]}
                  sx={{ mt: 2, mb: 4 }}
                />
              </Box>
              
              <Box sx={{ mt: 2 }}>
                <Typography variant="subtitle2" display="flex" alignItems="center">
                  <TrendingDownIcon sx={{ fontSize: 20, mr: 1, color: theme.palette.primary.light }} />
                  Prepayment Rate (%)
                  <Tooltip title="Early prepayment rates affect the expected cash flow timing" sx={{ ml: 1 }}>
                    <IconButton size="small">
                      <InfoOutlinedIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Typography>
                <Slider
                  value={prepaymentRate}
                  onChange={(e, value) => setPrepaymentRate(value)}
                  valueLabelDisplay="auto"
                  min={0}
                  max={50}
                  step={1}
                  marks={[
                    { value: 0, label: '0%' },
                    { value: 30, label: '30%' },
                    { value: 50, label: '50%' }
                  ]}
                  sx={{ mt: 2, mb: 4 }}
                />
              </Box>
              
              <Box sx={{ mt: 2 }}>
                <Typography variant="subtitle2" display="flex" alignItems="center">
                  <AttachMoneyIcon sx={{ fontSize: 20, mr: 1, color: theme.palette.secondary.light }} />
                  Reinvestment Rate Shift (±%)
                  <Tooltip title="All reinvestment rates will shift by this amount" sx={{ ml: 1 }}>
                    <IconButton size="small">
                      <InfoOutlinedIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Typography>
                <Slider
                  value={reinvestmentShift}
                  onChange={(e, value) => setReinvestmentShift(value)}
                  valueLabelDisplay="auto"
                  min={-10}
                  max={10}
                  step={1}
                  marks={[
                    { value: -10, label: '-10%' },
                    { value: 0, label: '0%' },
                    { value: 10, label: '+10%' }
                  ]}
                  sx={{ mt: 2, mb: 3 }}
                />
              </Box>
              
              <Divider sx={{ my: 2 }} />
              
              <Box sx={{ mt: 3 }}>
                <Typography variant="subtitle2" gutterBottom>
                  Advanced Parameters
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={12} sm={6}>
                    <TextField
                      fullWidth
                      label="Recovery Rate (0-1)"
                      value={recoveryRate}
                      onChange={(e) => setRecoveryRate(Number(e.target.value))}
                      type="number"
                      inputProps={{ min: 0, max: 1, step: 0.05 }}
                      size="small"
                    />
                  </Grid>
                  <Grid item xs={12} sm={6}>
                    <TextField
                      fullWidth
                      label="Delinquency Rate (%)"
                      value={delinquencyRate === null ? '' : delinquencyRate}
                      onChange={(e) => {
                        const value = e.target.value === '' ? null : Number(e.target.value);
                        setDelinquencyRate(value);
                      }}
                      type="number"
                      inputProps={{ min: 0, max: 100, step: 0.1 }}
                      size="small"
                      helperText="Leave blank to use half of NPL rate"
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      label="Recovery Lag (days)"
                      value={recoveryLag}
                      onChange={(e) => setRecoveryLag(Number(e.target.value))}
                      type="number"
                      inputProps={{ min: 0, step: 1 }}
                      size="small"
                    />
                  </Grid>
                </Grid>
              </Box>
            </Paper>
            
            {/* Run Button */}
            <Button
              variant="contained"
              color="primary"
              fullWidth
              size="large"
              startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : <AssessmentIcon />}
              onClick={handleRunStressTest}
              disabled={isLoading || !selectedStructureId}
              sx={{ py: 1.5, boxShadow: '0 4px 10px rgba(0,0,0,0.3)' }}
            >
              {isLoading ? 'Running Tests...' : 'Run Stress Test'}
            </Button>
          </Box>
        </Grid>
        
        {/* Right Panel: Results */}
        <Grid item xs={12} md={8}>
          {isLoading && (
            <Box sx={{ mt: 2, mb: 4 }}>
              <Typography variant="subtitle1" gutterBottom>
                Running stress test...
              </Typography>
              <LinearProgress />
            </Box>
          )}
          
          {!showResults && !isLoading && (
            <Paper
              elevation={3}
              sx={{
                p: 4,
                borderRadius: 2,
                backgroundColor: alpha(theme.palette.background.paper, 0.8),
                textAlign: 'center',
                height: '300px',
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                alignItems: 'center'
              }}
            >
              <AssessmentIcon sx={{ fontSize: 60, color: alpha(theme.palette.primary.main, 0.3), mb: 2 }} />
              <Typography variant="h6" gutterBottom>
                Stress Test Results Will Appear Here
              </Typography>
              <Typography variant="body1" color="text.secondary">
                Select a structure and run the stress test
              </Typography>
            </Paper>
          )}
          
          {showResults && testResults.classBRate.original !== null && (
            <>
              {/* Tab Navigation */}
              <Box sx={{ borderBottom: 1, borderColor: 'divider', mb: 2 }}>
                <Tabs 
                  value={tabValue} 
                  onChange={handleTabChange}
                  variant="scrollable"
                  scrollButtons="auto"
                >
                  <Tab icon={<ShowChartIcon />} label="Summary" iconPosition="start" />
                  <Tab icon={<PieChartIcon />} label="Coupon Analysis" iconPosition="start" />
                  <Tab icon={<TableChartIcon />} label="Cash Flow" iconPosition="start" />
                </Tabs>
              </Box>
              
              {/* Tab Content */}
              {tabValue === 0 && (
                <>
                  {/* Summary Results */}
                  <Paper
                    elevation={3}
                    sx={{
                      p: 3,
                      mb: 3,
                      borderRadius: 2,
                      backgroundColor: alpha(theme.palette.background.paper, 0.8),
                    }}
                  >
                    <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                      <ShowChartIcon sx={{ mr: 1, color: theme.palette.primary.main }} />
                      Class B Coupon Rate Results
                    </Typography>
                    
                    <Grid container spacing={3}>
                      <Grid item xs={12} sm={4}>
                        <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.primary.main, 0.1) }}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Original Coupon Rate
                          </Typography>
                          <Typography variant="h4" color="primary" fontWeight="bold">
                            {testResults.classBRate.original.toFixed(2)}%
                          </Typography>
                        </Paper>
                      </Grid>
                      
                      <Grid item xs={12} sm={4}>
                        <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.secondary.main, 0.1) }}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Stressed Coupon Rate
                          </Typography>
                          <Typography variant="h4" color="secondary" fontWeight="bold">
                            {testResults.classBRate.stressed.toFixed(2)}%
                          </Typography>
                        </Paper>
                      </Grid>
                      
                      <Grid item xs={12} sm={4}>
                        <Paper sx={{ 
                          p: 2, 
                          textAlign: 'center', 
                          bgcolor: alpha(getDifferenceColor(testResults.classBRate.difference), 0.1)
                        }}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Impact
                          </Typography>
                          <Typography 
                            variant="h4" 
                            fontWeight="bold"
                            color={getDifferenceColor(testResults.classBRate.difference)}
                          >
                            {testResults.classBRate.difference > 0 ? '+' : ''}
                            {testResults.classBRate.difference.toFixed(2)}%
                          </Typography>
                        </Paper>
                      </Grid>
                    </Grid>
                    
                    <Box sx={{ mt: 3, p: 2, borderRadius: 2, bgcolor: alpha(theme.palette.info.main, 0.05) }}>
                      <Grid container spacing={2}>
                        <Grid item xs={12} sm={6}>
                          <Typography variant="body2" color="text.secondary">Cash Flow Reduction:</Typography>
                          <Typography variant="h6" fontWeight="medium" color="error">
                            {testResults.cashFlowMetrics.reductionPct.toFixed(2)}%
                          </Typography>
                        </Grid>
                        <Grid item xs={12} sm={6}>
                          <Typography variant="body2" color="text.secondary">Total NPL Impact:</Typography>
                          <Typography variant="h6" fontWeight="medium">
                            {new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(testResults.cashFlowMetrics.nplImpact)}
                          </Typography>
                        </Grid>
                      </Grid>
                    </Box>
                  </Paper>
                  
                  {/* Comparison Chart */}
                  <Paper
                    elevation={3}
                    sx={{
                      p: 3,
                      mb: 3,
                      borderRadius: 2,
                      backgroundColor: alpha(theme.palette.background.paper, 0.8),
                    }}
                  >
                    <Typography variant="h6" gutterBottom>
                      Scenario Comparison
                    </Typography>
                    
                    <Box sx={{ height: 350, mt: 2 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <BarChart
                          data={scenarioComparisonData}
                          margin={{ top: 20, right: 30, left: 20, bottom: 10 }}
                        >
                          <CartesianGrid strokeDasharray="3 3" />
                          <XAxis dataKey="name" />
                          <YAxis 
                            tickFormatter={(value) => `${value}%`}
                            domain={[0, 'dataMax + 5']}
                          />
                          <RechartsTooltip content={<CustomTooltip />} />
                          <Legend />
                          <Bar 
                            dataKey="rate" 
                            name="Class B Coupon Rate" 
                            fill={theme.palette.primary.main}
                            maxBarSize={80}
                          />
                        </BarChart>
                      </ResponsiveContainer>
                    </Box>
                    
                    <Divider sx={{ my: 3 }} />
                    
                    <Typography variant="subtitle1" gutterBottom>
                      Scenario Parameters
                    </Typography>
                    
                    <Grid container spacing={2} sx={{ mt: 1 }}>
                      <Grid item xs={12} sm={4}>
                        <Paper sx={{ p: 2, textAlign: 'center' }}>
                          <Typography variant="body2" color="text.secondary">NPL Rate</Typography>
                          <Typography variant="h6" fontWeight="medium">
                            {nplRate}%
                          </Typography>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} sm={4}>
                        <Paper sx={{ p: 2, textAlign: 'center' }}>
                          <Typography variant="body2" color="text.secondary">Prepayment</Typography>
                          <Typography variant="h6" fontWeight="medium">
                            {prepaymentRate}%
                          </Typography>
                        </Paper>
                      </Grid>
                      <Grid item xs={12} sm={4}>
                        <Paper sx={{ p: 2, textAlign: 'center' }}>
                          <Typography variant="body2" color="text.secondary">Reinvestment Shift</Typography>
                          <Typography variant="h6" fontWeight="medium">
                            {reinvestmentShift > 0 ? '+' : ''}{reinvestmentShift}%
                          </Typography>
                        </Paper>
                      </Grid>
                    </Grid>
                  </Paper>
                </>
              )}
              
              {/* Other tabs content would go here */}
              
              {/* Coupon Analysis Tab */}
              {tabValue === 1 && (
                <>
                  <Paper
                    elevation={3}
                    sx={{
                      p: 3,
                      mb: 3,
                      borderRadius: 2,
                      backgroundColor: alpha(theme.palette.background.paper, 0.8),
                    }}
                  >
                    <Typography variant="h6" gutterBottom>
                      Class B Coupon Analysis
                    </Typography>
                    
                    <Grid container spacing={3}>
                      <Grid item xs={12} md={6}>
                        <Box sx={{ height: 350 }}>
                          <ResponsiveContainer width="100%" height="100%">
                            <PieChart>
                              <Pie
                                data={formatPieData()}
                                dataKey="value"
                                nameKey="name"
                                cx="50%"
                                cy="50%"
                                outerRadius={120}
                                innerRadius={60}
                                labelLine={false}
                                label={({ percent }) => `${(percent * 100).toFixed(1)}%`}
                              >
                                {formatPieData().map((entry, index) => (
                                  <Cell key={`cell-${index}`} fill={entry.color} />
                                ))}
                              </Pie>
                              <RechartsTooltip content={<CustomTooltip />} />
                              <Legend />
                            </PieChart>
                          </ResponsiveContainer>
                        </Box>
                      </Grid>
                      
                      <Grid item xs={12} md={6}>
                        <Box sx={{ p: 2, height: '100%', display: 'flex', flexDirection: 'column', justifyContent: 'center' }}>
                          <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                            Coupon Rate Details
                          </Typography>
                          
                          <Box sx={{ mt: 2 }}>
                            <Typography variant="body2" color="text.secondary">Original Coupon Rate:</Typography>
                            <Typography variant="h5" color="primary" fontWeight="medium">
                              {testResults.classBRate.original.toFixed(2)}%
                            </Typography>
                            
                            <Divider sx={{ my: 2 }} />
                            
                            <Typography variant="body2" color="text.secondary">Stressed Coupon Rate:</Typography>
                            <Typography variant="h5" color="secondary" fontWeight="medium">
                              {testResults.classBRate.stressed.toFixed(2)}%
                            </Typography>
                            
                            <Divider sx={{ my: 2 }} />
                            
                            <Typography variant="body2" color="text.secondary">Coupon Rate Difference:</Typography>
                            <Typography 
                              variant="h5" 
                              fontWeight="medium"
                              color={getDifferenceColor(testResults.classBRate.difference)}
                            >
                              {testResults.classBRate.difference > 0 ? '+' : ''}
                              {testResults.classBRate.difference.toFixed(2)}%
                            </Typography>
                            
                            <Divider sx={{ my: 2 }} />
                            
                            <Typography variant="body2" color="text.secondary">Percentage Change:</Typography>
                            <Typography 
                              variant="h5" 
                              fontWeight="medium"
                              color={getDifferenceColor(testResults.classBRate.difference)}
                            >
                              {(testResults.classBRate.stressed / testResults.classBRate.original * 100 - 100).toFixed(2)}%
                            </Typography>
                          </Box>
                        </Box>
                      </Grid>
                    </Grid>
                  </Paper>
                </>
              )}
              
              {/* Cash Flow Tab */}
              {tabValue === 2 && (
                <>
                  <Paper
                    elevation={3}
                    sx={{
                      p: 3,
                      mb: 3,
                      borderRadius: 2,
                      backgroundColor: alpha(theme.palette.background.paper, 0.8),
                    }}
                  >
                    <Typography variant="h6" gutterBottom>
                      Cash Flow Comparison
                    </Typography>
                    
                    <Box sx={{ height: 350, mt: 2 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <BarChart
                          data={formatCashflowComparisonData()}
                          margin={{ top: 20, right: 30, left: 20, bottom: 30 }}
                        >
                          <CartesianGrid strokeDasharray="3 3" />
                          <XAxis 
                            dataKey="date" 
                            label={{ value: 'Payment Date', position: 'insideBottom', offset: -15 }}
                            angle={-45}
                            textAnchor="end"
                            height={60}
                          />
                          <YAxis 
                            tickFormatter={(value) => `$${(value/1000).toFixed(0)}k`}
                          />
                          <RechartsTooltip content={<CustomTooltip />} />
                          <Legend />
                          <Bar 
                            dataKey="original" 
                            name="Original Cash Flow" 
                            fill={theme.palette.primary.main}
                            maxBarSize={20}
                          />
                          <Bar 
                            dataKey="actual" 
                            name="Stressed Cash Flow" 
                            fill={theme.palette.secondary.main}
                            maxBarSize={20}
                          />
                        </BarChart>
                      </ResponsiveContainer>
                    </Box>
                  </Paper>
                  
                  <Paper
                    elevation={3}
                    sx={{
                      p: 3,
                      mb: 3,
                      borderRadius: 2,
                      backgroundColor: alpha(theme.palette.background.paper, 0.8),
                    }}
                  >
                    <Typography variant="h6" gutterBottom>
                      Cash Flow Impact Analysis
                    </Typography>
                    
                    <Grid container spacing={3}>
                      <Grid item xs={12} sm={6} md={3}>
                        <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.error.main, 0.1) }}>
                          <Typography variant="subtitle2" color="text.secondary">
                            NPL Impact
                          </Typography>
                          <Typography variant="h6" color="error" fontWeight="medium">
                            {testResults.cashFlowMetrics.nplImpact.toLocaleString('en-US', { maximumFractionDigits: 0 })} $
                          </Typography>
                        </Paper>
                      </Grid>
                      
                      <Grid item xs={12} sm={6} md={3}>
                        <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.warning.main, 0.1) }}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Cash Flow Loss
                          </Typography>
                          <Typography variant="h6" color="warning.dark" fontWeight="medium">
                            {testResults.cashFlowMetrics.reductionPct.toFixed(2)}%
                          </Typography>
                        </Paper>
                      </Grid>
                      
                      <Grid item xs={12} sm={6} md={3}>
                        <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.info.main, 0.1) }}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Prepayment
                          </Typography>
                          <Typography variant="h6" color="info.dark" fontWeight="medium">
                            {testResults.cashFlowMetrics.prepaymentTotal.toLocaleString('en-US', { maximumFractionDigits: 0 })} $
                          </Typography>
                        </Paper>
                      </Grid>
                      
                      <Grid item xs={12} sm={6} md={3}>
                        <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.success.main, 0.1) }}>
                          <Typography variant="subtitle2" color="text.secondary">
                            Reinvestment
                          </Typography>
                          <Typography variant="h6" color="success.dark" fontWeight="medium">
                            {testResults.cashFlowMetrics.reinvestmentTotal.toLocaleString('en-US', { maximumFractionDigits: 0 })} $
                          </Typography>
                        </Paper>
                      </Grid>
                    </Grid>
                    
                    <Box sx={{ mt: 3, p: 2, borderRadius: 2, bgcolor: alpha(theme.palette.info.main, 0.05) }}>
                      <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                        Stress Scenario Summary
                      </Typography>
                      
                      <Typography variant="body1" paragraph>
                        This stress test modeled cash flows under a {scenarioType === 'base' ? 'base' : scenarioType === 'moderate' ? 'moderate' : scenarioType === 'severe' ? 'severe' : 'custom'} scenario with {nplRate}% NPL rate and {prepaymentRate}% prepayment rate assumptions.
                      </Typography>
                      
                      <Typography variant="body1" paragraph>
                        The test shows that compared to the original Class B coupon rate of {testResults.classBRate.original.toFixed(2)}%, under stress conditions this rate becomes {testResults.classBRate.stressed.toFixed(2)}%. This represents a {Math.abs(testResults.classBRate.difference).toFixed(2)}% ({(testResults.classBRate.stressed / testResults.classBRate.original * 100 - 100).toFixed(2)}%) change in the rate.
                      </Typography>
                      
                      <Typography variant="body1">
                        The total cash flow reduction is {testResults.cashFlowMetrics.reductionPct.toFixed(2)}%, with the majority coming from NPL impact (${testResults.cashFlowMetrics.nplImpact.toLocaleString('en-US', { maximumFractionDigits: 0 })}), while prepayments also affect the cash flow dynamics.
                      </Typography>
                    </Box>
                  </Paper>
                </>
              )}
            </>
          )}
        </Grid>
      </Grid>
      
      {/* Snackbar */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleCloseSnackbar}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert 
          onClose={handleCloseSnackbar} 
          severity={snackbarSeverity}
          sx={{ width: '100%' }}
        >
          {snackbarMessage}
        </Alert>
      </Snackbar>
    </Container>
  );
};

export default StressTestingPage;

======================================================================

DOSYA: src\services\apiService.js
==================================================
// src/services/apiService.js
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

/**
 * Shared axios client
 */
const apiClient = axios.create({
  baseURL: API_URL,
  headers: { 'Content-Type': 'application/json' },
  // 5 minutes (300,000 ms) - optimization processes can take long
  timeout: 300_000,
});

/* --------------------------------------------------------------------- */
/*                               UPLOAD                                  */
/* --------------------------------------------------------------------- */

/**
 * Upload Excel file
 * @param {File} file
 * @returns {Promise<Object>}
 */
const uploadFile = async (file) => {
  const formData = new FormData();
  formData.append('file', file);

  try {
    console.log('Uploading file:', file.name);

    const response = await axios.post(
      `${API_URL}/upload-excel/`,
      formData,
      {
        headers: { 'Content-Type': 'multipart/form-data' },
      }
    );

    console.log('File upload successful');
    return response.data;
  } catch (error) {
    console.error('Error uploading file:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

/* --------------------------------------------------------------------- */
/*                             CALCULATION                               */
/* --------------------------------------------------------------------- */

/**
 * Calculation service.
 * If optimization output is sent as 2nd parameter,
 * Class B nominal is automatically added.
 *
 * @param {Object} params - CalculationRequest body
 * @param {Object|null} optResult - OptimizationResult (optional)
 * @returns {Promise<Object>}
 */
const calculateResults = async (params, optResult = null) => {
  try {
    // Optional Class B nominal integration
    const finalParams = { ...params };

    if (
      optResult &&
      optResult.class_b_nominal &&
      Number(optResult.class_b_nominal) > 0
    ) {
      finalParams.tranche_b = {
        ...(finalParams.tranche_b || {}),
        nominal: optResult.class_b_nominal,
      };
    }

    console.log('Calculating results with params:', finalParams);

    const response = await apiClient.post('/calculate/', finalParams);

    console.log('Calculation successful');
    return response.data;
  } catch (error) {
    console.error('Error calculating results:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

/* --------------------------------------------------------------------- */
/*                             OPTIMIZATION                              */
/* --------------------------------------------------------------------- */

/**
 * Structure optimization (classic | genetic)
 *
 * @param {Object} params - OptimizationRequest body
 * @param {'classic'|'genetic'} [method='classic']
 * @returns {Promise<Object>}
 */
const optimizeStructure = async (params, method = 'classic') => {
  try {
    console.log(`Starting optimization with method: ${method}`);
    console.log(
      'Optimization params:',
      JSON.stringify(params, null, 2)
    );

    // Create cancellable request
    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();

    // 5 minute timeout
    const timeout = setTimeout(() => {
      source.cancel(
        'Operation timeout: The optimization process took too long'
      );
    }, 300_000);

    const response = await apiClient.post(
      `/optimize/${method}/`,
      params,
      { cancelToken: source.token }
    );

    clearTimeout(timeout);

    console.log(`${method} optimization completed successfully`);
    return response.data;
  } catch (error) {
    console.error(`Error in ${method} optimization:`, error);

    if (axios.isCancel(error)) {
      console.log('Request canceled:', error.message);
      throw new Error(
        'Optimization process was canceled: ' + error.message
      );
    }

    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);

      const status = error.response.status;
      let message = 'Optimization failed';

      switch (status) {
        case 400:
          message =
            'Invalid optimization parameters: ' +
            (error.response.data.detail ||
              'Please check your parameters');
          break;
        case 500:
          message =
            'Server error during optimization. The calculation may be too complex.';
          break;
        case 504:
          message =
            'Optimization timed out. Try again with simpler parameters.';
          break;
        default:
          message =
            `Optimization error (${status}): ` +
            (error.response.data.detail || error.message);
      }

      throw new Error(message);
    }

    throw error;
  }
};

/* --------------------------------------------------------------------- */
/*                           PROGRESS POLLING                            */
/* --------------------------------------------------------------------- */

/**
 * Poll optimization progress from server
 * @returns {Promise<Object>}
 */
const pollOptimizationProgress = async () => {
  try {
    const response = await apiClient.get('/optimize/progress/');
    return response.data;
  } catch (error) {
    console.error('Error polling optimization progress:', error);
    return {
      progress: 0,
      phase: 'Error',
      message: 'Failed to get progress information',
      error: true,
    };
  }
};

/* --------------------------------------------------------------------- */
/*                            STRESS TESTING                             */
/* --------------------------------------------------------------------- */

/**
 * Format structure for stress test API
 * @param {Object} savedStructure - Saved structure from context
 * @returns {Object} - Formatted structure for API
 */
const formatStructureForStressTest = (savedStructure) => {
  console.log('Formatting structure for stress test:', savedStructure);
  
  // Create a_tranches array from tranchesA
  const a_tranches = [];
  
  // Check if tranches_a exists in the saved structure
  const tranchesArray = savedStructure.tranches_a || savedStructure.tranchesA || [];
  console.log('Found tranches array:', tranchesArray);
  
  if (Array.isArray(tranchesArray) && tranchesArray.length > 0) {
    for (const tranche of tranchesArray) {
      console.log('Processing tranche:', tranche);
      a_tranches.push({
        maturity_days: Number(tranche.maturity_days),
        base_rate: Number(tranche.base_rate),
        spread: Number(tranche.spread),
        reinvest_rate: Number(tranche.reinvest_rate),
        nominal: Number(tranche.nominal)
      });
    }
  } else {
    console.warn('No tranches_a found in the structure');
  }
  
  // Format tranche_b
  const trancheB = savedStructure.tranche_b || savedStructure.trancheB || {};
  console.log('Found tranche B:', trancheB);
  
  const b_tranche = {
    maturity_days: Number(trancheB.maturity_days || 180),
    base_rate: Number(trancheB.base_rate || 0),
    spread: Number(trancheB.spread || 0),
    reinvest_rate: Number(trancheB.reinvest_rate || 0),
    nominal: Number(trancheB.nominal || 0)
  };
  
  // If no nominal is provided, calculate it as 10% of total structure
  if (!b_tranche.nominal || b_tranche.nominal <= 0) {
    const total_a_nominal = a_tranches.reduce((sum, t) => sum + t.nominal, 0);
    // Calculate using the percentage formula (10% / 90%)
    const percent_b = 10;
    b_tranche.nominal = (total_a_nominal * percent_b) / (100 - percent_b);
    b_tranche.nominal = Math.round(b_tranche.nominal / 1000) * 1000;
    console.log('Calculated B nominal:', b_tranche.nominal);
  }
  
  // Format date
  let start_date = savedStructure.start_date || 
                   savedStructure.general_settings?.start_date || 
                   new Date().toISOString().split('T')[0];
  
  console.log('Start date before formatting:', start_date);
  
  // If it's a Date object, convert to ISO format
  if (start_date instanceof Date) {
    start_date = start_date.toISOString().split('T')[0];
  }
  
  console.log('Start date after formatting:', start_date);
  
  // Return formatted structure for API
  const formattedStructure = {
    start_date: start_date,
    a_maturities: a_tranches.map(t => t.maturity_days),
    a_base_rates: a_tranches.map(t => t.base_rate),
    a_spreads: a_tranches.map(t => t.spread),
    a_reinvest_rates: a_tranches.map(t => t.reinvest_rate),
    a_nominals: a_tranches.map(t => t.nominal),
    b_maturity: b_tranche.maturity_days,
    b_base_rate: b_tranche.base_rate,
    b_spread: b_tranche.spread,
    b_reinvest_rate: b_tranche.reinvest_rate,
    b_nominal: b_tranche.nominal,
    ops_expenses: Number(savedStructure.general_settings?.operational_expenses || 0)
  };
  
  console.log('Final formatted structure:', formattedStructure);
  return formattedStructure;
};

/**
 * Run a basic stress test on a structure
 * @param {Object} params - StressTestRequest body
 * @returns {Promise<Object>}
 */
const runStressTest = async (params) => {
  try {
    console.log('Running stress test with params:', params);
    
    const response = await apiClient.post('/stress-test/', params);
    
    console.log('Stress test successful');
    return response.data;
  } catch (error) {
    console.error('Error running stress test:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

/**
 * Run enhanced stress test with detailed cash flow modeling
 * @param {Object} params - EnhancedStressTestRequest body
 * @returns {Promise<Object>}
 */
const runEnhancedStressTest = async (params) => {
  try {
    console.log('Running enhanced stress test with params:', params);
    
    // Log structure details
    console.log('Structure details:', JSON.stringify(params.structure, null, 2));
    console.log('Scenario details:', JSON.stringify(params.scenario, null, 2));
    
    // Log specific fields to debug date issues
    console.log('Start date:', params.structure.start_date);
    console.log('Start date type:', typeof params.structure.start_date);
    
    const response = await apiClient.post('/enhanced-stress-test/', params);
    
    console.log('Enhanced stress test successful');
    return response.data;
  } catch (error) {
    console.error('Error running enhanced stress test:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
      console.error('Full error response:', JSON.stringify(error.response.data, null, 2));
      
      // Extract specific validation errors
      if (error.response.data && error.response.data.detail) {
        console.error('Validation errors:', error.response.data.detail);
      }
    }
    throw error;
  }
};

/* --------------------------------------------------------------------- */
/*                                EXPORT                                 */
/* --------------------------------------------------------------------- */

export {
  uploadFile,
  calculateResults,
  optimizeStructure,
  pollOptimizationProgress,
  formatStructureForStressTest,
  runStressTest,
  runEnhancedStressTest
};

======================================================================



BACKEND SONUÇLARI:
================

DOSYA: backend\app\main.py
==================================================
# app/main.py
import time
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from app.routers import calculation, optimization, stress_testing
import uvicorn

app = FastAPI(
    title="ABS Analysis Tool",
    description="Cash flow analysis for securitization",
    version="1.2.0"  # Updated version number to reflect changes
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify the actual frontend domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add GZip compression for faster responses
app.add_middleware(GZipMiddleware, minimum_size=1000)

# Add custom middleware for timeout and performance tracking
@app.middleware("http")
async def add_process_time_header(request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

# Include routers
app.include_router(calculation.router, prefix="/api", tags=["Calculation"])
app.include_router(optimization.router, prefix="/api", tags=["Optimization"])
app.include_router(stress_testing.router, prefix="/api", tags=["Stress Testing"])

@app.get("/")
async def root():
    return {
        "message": "ABS Analysis Tool API is running",
        "version": "1.2.0",
        "features": [
            "Calculation", 
            "Optimization", 
            "Unified Stress Testing with Advanced Cash Flow Modeling"
        ]
    }

# Configure server settings if run directly
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        timeout_keep_alive=600,  # 10 minute keep-alive timeout
        workers=1,  # Single worker is better for optimization process
    )

======================================================================

DOSYA: backend\app\models\input_models.py
==================================================
# app/models/input_models.py

from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import date


class GeneralSettings(BaseModel):
    start_date: date
    operational_expenses: float
    min_buffer: float


class TrancheA(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: float


class TrancheB(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: Optional[float] = None


class NPVSettings(BaseModel):
    method: str
    custom_rate: Optional[float] = None


class OptimizationSettings(BaseModel):
    optimization_method: str = Field(default="classic")
    selected_strategies: List[str] = Field(default=["equal", "increasing", "decreasing", "middle_weighted"])
    a_tranches_range: List[int] = Field(default=[2, 6])
    maturity_range: List[int] = Field(default=[32, 365])
    maturity_step: int = Field(default=10)
    min_class_b_percent: float = Field(default=10.0)
    target_class_b_coupon_rate: float = Field(default=30.0)
    additional_days_for_class_b: int = Field(default=10)
    class_b_percent_deviation: float = Field(default=1.0)
    selected_default_model: str = Field(default="previous")
    
    # Evolutionary algorithm parameters
    population_size: Optional[int] = Field(default=50)
    num_generations: Optional[int] = Field(default=40)


class CalculationRequest(BaseModel):
    general_settings: GeneralSettings
    tranches_a: List[TrancheA]
    tranche_b: TrancheB
    npv_settings: NPVSettings
    is_optimized: Optional[bool] = False
    optimization_method: Optional[str] = None


# Stress Testing Models
class StructureParameters(BaseModel):
    start_date: date
    a_maturities: List[int]
    a_base_rates: List[float]
    a_spreads: List[float]
    a_reinvest_rates: List[float]
    a_nominals: List[float]
    b_maturity: int
    b_base_rate: float
    b_spread: float
    b_reinvest_rate: float
    b_nominal: float
    ops_expenses: float = 0.0


class EnhancedScenarioParameters(BaseModel):
    name: str
    npl_rate: float
    prepayment_rate: float
    reinvestment_shift: float
    # Additional parameters for cash flow modeling
    recovery_rate: float = 0.50
    recovery_lag: int = 6
    delinquency_rate: Optional[float] = None  # If None, will be derived from npl_rate
    delinquency_recovery_rate: float = 0.85
    delinquency_to_default_rate: float = 0.20
    repeat_delinquency_factor: float = 1.5


class ScenarioParameters(BaseModel):
    name: str
    npl_rate: float
    prepayment_rate: float
    reinvestment_shift: float


class StressTestRequest(BaseModel):
    structure: StructureParameters
    scenario: ScenarioParameters


class EnhancedStressTestRequest(BaseModel):
    structure: StructureParameters
    scenario: EnhancedScenarioParameters

======================================================================

DOSYA: backend\app\routers\stress_testing.py
==================================================
# app/routers/stress_testing.py

from fastapi import APIRouter, HTTPException, Body
from app.models.input_models import StressTestRequest, EnhancedStressTestRequest, StructureParameters, EnhancedScenarioParameters
from app.services.enhanced_stress_testing_service import perform_enhanced_stress_test
from app.routers.calculation import df_store
import logging
import traceback
from datetime import date
from typing import Dict, Any, List
from pydantic import ValidationError

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/stress-test/", response_model=Dict[str, Any])
async def stress_test(request: StressTestRequest):
    """
    Run a basic stress test with NPL, prepayment and reinvestment shift
    """
    try:
        # Get the stored dataframe
        df = df_store.get("df")
        if df is None:
            raise HTTPException(
                status_code=400, 
                detail="No loan data found. Please upload an Excel file on the Structure Analysis page first."
            )
        
        # Validate dataframe has required columns
        required_columns = ['principal_amount', 'interest_amount', 'cash_flow', 'installment_date']
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            raise HTTPException(
                status_code=400,
                detail=f"Missing required columns in uploaded data: {', '.join(missing_columns)}"
            )
        
        # Validate input data
        if not request.structure:
            raise HTTPException(status_code=400, detail="Structure details are missing")
            
        # Validate structure parameters
        if not request.structure.a_maturities:
            raise HTTPException(status_code=400, detail="No Class A maturities provided")
        
        # Ensure lists are of equal length
        list_lengths = [
            len(request.structure.a_maturities),
            len(request.structure.a_base_rates),
            len(request.structure.a_spreads),
            len(request.structure.a_reinvest_rates),
            len(request.structure.a_nominals)
        ]
        if len(set(list_lengths)) > 1:
            raise HTTPException(
                status_code=400, 
                detail=f"Inconsistent lengths in Class A parameters: {list_lengths}"
            )
        
        # Validate scenario parameters
        if request.scenario.npl_rate < 0 or request.scenario.npl_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"NPL rate must be between 0 and 100, got {request.scenario.npl_rate}"
            )
            
        if request.scenario.prepayment_rate < 0 or request.scenario.prepayment_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"Prepayment rate must be between 0 and 100, got {request.scenario.prepayment_rate}"
            )
        
        # Log inputs for debugging
        logger.info(f"Running stress test with scenario: {request.scenario.name}")
        logger.info(f"NPL rate: {request.scenario.npl_rate}%, Prepayment: {request.scenario.prepayment_rate}%, Reinvestment shift: {request.scenario.reinvestment_shift}%")
        
        # Convert standard request to enhanced request with default values for enhanced parameters
        enhanced_request = EnhancedStressTestRequest(
            structure=request.structure,
            scenario=EnhancedScenarioParameters(
                name=request.scenario.name,
                npl_rate=request.scenario.npl_rate,
                prepayment_rate=request.scenario.prepayment_rate,
                reinvestment_shift=request.scenario.reinvestment_shift,
                recovery_rate=0.50,
                recovery_lag=6,
                delinquency_rate=None,  # Will be derived from npl_rate
                delinquency_recovery_rate=0.85,
                delinquency_to_default_rate=0.20,
                repeat_delinquency_factor=1.5
            )
        )
        
        # Use enhanced stress test
        result = perform_enhanced_stress_test(df, enhanced_request)
        
        # Return result directly - it's already in the correct format
        return result
        
    except HTTPException:
        # Re-raise HTTP exceptions directly
        raise
    except Exception as e:
        # Capture and log the full exception details
        stack_trace = traceback.format_exc()
        error_message = str(e)
        logger.error(f"Stress testing error: {error_message}\n{stack_trace}")
        
        # Provide a meaningful error message
        if not error_message:
            error_message = "Unknown error occurred during stress testing. Check server logs for details."
            
        raise HTTPException(
            status_code=400, 
            detail=f"Stress testing error: {error_message}"
        )

@router.post("/enhanced-stress-test/")
async def enhanced_stress_test(request_data: Dict[str, Any] = Body(...)):
    """
    Run enhanced stress test with additional parameters
    """
    try:
        # Log raw request data for debugging
        logger.info(f"Enhanced stress test raw request: {request_data}")
        
        # Try to parse and validate request data manually
        try:
            # Extract structure and scenario data
            structure_data = request_data.get("structure", {})
            scenario_data = request_data.get("scenario", {})
            
            # Format date string from frontend to date object
            start_date_str = structure_data.get("start_date")
            start_date = None
            
            if isinstance(start_date_str, str):
                try:
                    start_date = date.fromisoformat(start_date_str)
                except ValueError:
                    # Try different formats
                    try:
                        from datetime import datetime
                        start_date = datetime.strptime(start_date_str, "%Y-%m-%d").date()
                    except ValueError:
                        raise ValueError(f"Invalid date format: {start_date_str}. Expected YYYY-MM-DD")
            
            # Validate structure
            structure = StructureParameters(
                start_date=start_date,
                a_maturities=structure_data.get("a_maturities", []),
                a_base_rates=structure_data.get("a_base_rates", []),
                a_spreads=structure_data.get("a_spreads", []),
                a_reinvest_rates=structure_data.get("a_reinvest_rates", []),
                a_nominals=structure_data.get("a_nominals", []),
                b_maturity=structure_data.get("b_maturity"),
                b_base_rate=structure_data.get("b_base_rate"),
                b_spread=structure_data.get("b_spread"),
                b_reinvest_rate=structure_data.get("b_reinvest_rate"),
                b_nominal=structure_data.get("b_nominal"),
                ops_expenses=structure_data.get("ops_expenses", 0.0)
            )
            
            # Validate scenario
            scenario = EnhancedScenarioParameters(
                name=scenario_data.get("name", "Scenario"),
                npl_rate=scenario_data.get("npl_rate"),
                prepayment_rate=scenario_data.get("prepayment_rate"),
                reinvestment_shift=scenario_data.get("reinvestment_shift"),
                recovery_rate=scenario_data.get("recovery_rate", 0.5),
                recovery_lag=scenario_data.get("recovery_lag", 6),
                delinquency_rate=scenario_data.get("delinquency_rate"),
                delinquency_recovery_rate=scenario_data.get("delinquency_recovery_rate", 0.85),
                delinquency_to_default_rate=scenario_data.get("delinquency_to_default_rate", 0.2),
                repeat_delinquency_factor=scenario_data.get("repeat_delinquency_factor", 1.5)
            )
            
            # Create validated request
            request = EnhancedStressTestRequest(structure=structure, scenario=scenario)
            
        except ValidationError as ve:
            # Return detailed validation errors
            error_messages = str(ve).split("\n")
            logger.error(f"Validation error: {error_messages}")
            raise HTTPException(
                status_code=422,
                detail={"message": "Validation error", "errors": error_messages}
            )
        
        # Get the stored dataframe
        df = df_store.get("df")
        if df is None:
            raise HTTPException(
                status_code=400, 
                detail="No loan data found. Please upload an Excel file on the Structure Analysis page first."
            )
        
        # Perform additional validation on the structure
        # Ensure lists are of equal length
        list_lengths = [
            len(request.structure.a_maturities),
            len(request.structure.a_base_rates),
            len(request.structure.a_spreads),
            len(request.structure.a_reinvest_rates),
            len(request.structure.a_nominals)
        ]
        if len(set(list_lengths)) > 1:
            raise HTTPException(
                status_code=400, 
                detail=f"Inconsistent lengths in Class A parameters: {list_lengths}"
            )
        
        # Validate scenario parameters
        if request.scenario.npl_rate < 0 or request.scenario.npl_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"NPL rate must be between 0 and 100, got {request.scenario.npl_rate}"
            )
            
        if request.scenario.prepayment_rate < 0 or request.scenario.prepayment_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"Prepayment rate must be between 0 and 100, got {request.scenario.prepayment_rate}"
            )
        
        if request.scenario.recovery_rate < 0 or request.scenario.recovery_rate > 1:
            raise HTTPException(
                status_code=400,
                detail=f"Recovery rate must be between 0 and 1, got {request.scenario.recovery_rate}"
            )
        
        if request.scenario.recovery_lag <= 0:
            raise HTTPException(
                status_code=400,
                detail=f"Recovery lag must be positive, got {request.scenario.recovery_lag}"
            )
            
        if request.scenario.delinquency_recovery_rate < 0 or request.scenario.delinquency_recovery_rate > 1:
            raise HTTPException(
                status_code=400,
                detail=f"Delinquency recovery rate must be between 0 and 1, got {request.scenario.delinquency_recovery_rate}"
            )
            
        if request.scenario.delinquency_to_default_rate < 0 or request.scenario.delinquency_to_default_rate > 1:
            raise HTTPException(
                status_code=400,
                detail=f"Delinquency to default rate must be between 0 and 1, got {request.scenario.delinquency_to_default_rate}"
            )
        
        # Log inputs for debugging
        logger.info(f"Running enhanced stress test with scenario: {request.scenario.name}")
        logger.info(f"NPL rate: {request.scenario.npl_rate}%, Prepayment: {request.scenario.prepayment_rate}%, " + 
                    f"Recovery: {request.scenario.recovery_rate * 100}%")
        
        # Perform the enhanced stress test
        result = perform_enhanced_stress_test(df, request)
        
        # Return result directly - it's already in the correct format
        return result
        
    except HTTPException:
        # Re-raise HTTP exceptions directly
        raise
    except Exception as e:
        # Capture and log the full exception details
        stack_trace = traceback.format_exc()
        error_message = str(e)
        logger.error(f"Enhanced stress testing error: {error_message}\n{stack_trace}")
        
        # Provide a meaningful error message
        if not error_message:
            error_message = "Unknown error occurred during enhanced stress testing. Check server logs for details."
            
        raise HTTPException(
            status_code=400, 
            detail=f"Enhanced stress testing error: {error_message}"
        )

======================================================================

DOSYA: backend\app\services\enhanced_stress_testing_service.py
==================================================
# app/services/enhanced_stress_testing_service.py
"""
Enhanced Stress Testing Service for Asset-Backed Securities (ABS)
This module implements advanced stress testing with detailed cash flow modeling
"""

import pandas as pd
import numpy as np
from datetime import date, datetime, timedelta
import logging
from typing import Dict, Any, List, Optional, Union, Tuple
from pydantic import BaseModel

# Configure logger
logger = logging.getLogger(__name__)

# =========================================================================
# Data Models
# =========================================================================

class ClassATranche(BaseModel):
    """Class A tranche parameters"""
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: float

class ClassBTranche(BaseModel):
    """Class B tranche parameters"""
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: float

class ABSStructure(BaseModel):
    """ABS structure parameters"""
    start_date: str
    a_tranches: List[ClassATranche]
    b_tranche: ClassBTranche
    ops_expenses: float = 0

class StressScenario(BaseModel):
    """Stress test scenario parameters"""
    name: str
    npl_rate: float  # %
    prepayment_rate: float  # %
    reinvestment_shift: float  # %
    recovery_rate: float = 0.5  # Ratio (0-1)
    recovery_lag: int = 90  # Days
    delinquency_rate: Optional[float] = None  # %, If None, half of NPL is used
    delinquency_recovery_rate: float = 0.85  # Ratio (0-1)
    delinquency_to_default_rate: float = 0.2  # Ratio (0-1)
    repeat_delinquency_factor: float = 1.5  # Multiplier

class StressTestRequest(BaseModel):
    """Stress test request parameters"""
    structure: ABSStructure
    scenario: StressScenario

class StressTestResponse(BaseModel):
    """Stress test response parameters"""
    original_class_b_rate: float
    stressed_class_b_rate: float
    difference: float
    cashflow_reduction_pct: float
    total_npl_impact: float
    total_prepayment: float
    total_reinvestment: float
    modeled_cashflows: List[Dict[str, Any]]

# =========================================================================
# Cash Flow Modeling
# =========================================================================

class CashFlowModeler:
    """
    Cash flow modeling class. Calculates modeled cash flows
    applying various stress factors.
    """
    
    @staticmethod
    def prepare_cashflow_df(cash_flows: pd.DataFrame) -> pd.DataFrame:
        """
        Prepares the original cash flow DataFrame for modeling
        """
        df = cash_flows.copy()
        
        # Check and fix date column
        if 'installment_date' not in df.columns:
            raise ValueError("Cash flow table must contain 'installment_date' column")
        
        # Fix date format
        df['installment_date'] = pd.to_datetime(df['installment_date'])
        
        # Check required columns
        required_columns = ['principal_amount', 'interest_amount']
        for col in required_columns:
            if col not in df.columns:
                raise ValueError(f"Cash flow table must contain '{col}' column")
        
        # Calculate cash flow total
        if 'cash_flow' not in df.columns:
            df['cash_flow'] = df['principal_amount'] + df['interest_amount']
        
        # Convert data types
        df['principal_amount'] = pd.to_numeric(df['principal_amount'])
        df['interest_amount'] = pd.to_numeric(df['interest_amount'])
        df['cash_flow'] = pd.to_numeric(df['cash_flow'])
        
        return df
    
    @staticmethod
    def calculate_daily_rates(annual_rate: float) -> float:
        """
        Converts an annual rate to a daily rate
        """
        return 1 - (1 - annual_rate/100) ** (1/365)
    
    @staticmethod
    def model_cashflows(
        original_cashflows: pd.DataFrame,
        structure: ABSStructure,
        scenario: StressScenario
    ) -> pd.DataFrame:
        """
        Models cash flows according to stress parameters
        """
        # Create copy of DataFrame
        df = original_cashflows.copy()
        result_df = pd.DataFrame()
        
        # Prepare scenario parameters
        npl_rate = scenario.npl_rate / 100
        prepayment_rate = scenario.prepayment_rate / 100  
        reinvest_shift = scenario.reinvestment_shift / 100
        recovery_rate = scenario.recovery_rate
        recovery_lag_days = scenario.recovery_lag
        
        # Set delinquency rate, if not specified use half of NPL
        delinquency_rate = (scenario.delinquency_rate / 100) if scenario.delinquency_rate is not None else (npl_rate / 2)
        delinquency_recovery_rate = scenario.delinquency_recovery_rate
        delinquency_to_default_rate = scenario.delinquency_to_default_rate
        
        # Calculate daily rates
        daily_npl_rate = CashFlowModeler.calculate_daily_rates(scenario.npl_rate)
        daily_prepayment_rate = CashFlowModeler.calculate_daily_rates(scenario.prepayment_rate)
        daily_delinquency_rate = CashFlowModeler.calculate_daily_rates(
            scenario.delinquency_rate if scenario.delinquency_rate is not None else (scenario.npl_rate / 2)
        )
        
        # Initial values
        remaining_principal = df["principal_amount"].sum()
        current_date = pd.Timestamp(structure.start_date)
        remaining_cashflows = []
        defaulted_amounts = []  # List of defaulted amounts
        delinquent_amounts = []  # List of delinquent amounts

        # Process cash flows in date order
        for _, row in df.sort_values("installment_date").iterrows():
            installment_date = pd.Timestamp(row["installment_date"])
            days_diff = (installment_date - current_date).days
            
            # 1. Calculate NPL impact - loss of principal and interest
            # Instead of direct calculation, we calculate a cumulative probability
            cumulative_npl_prob = 1 - (1 - daily_npl_rate) ** days_diff
            npl_impact = remaining_principal * cumulative_npl_prob
            
            # NPL effect on principal and interest (proportional by default)
            remaining_after_npl = remaining_principal - npl_impact
            
            # Ratio of remaining to what should be
            scaling_factor = remaining_after_npl / remaining_principal if remaining_principal > 0 else 0
            principal_after_npl = row["principal_amount"] * scaling_factor
            interest_after_npl = row["interest_amount"] * scaling_factor
            
            # 2. Calculate delinquency effect
            # Based on principal after NPL
            cumulative_delinq_prob = 1 - (1 - daily_delinquency_rate) ** days_diff
            delinquency_amount = remaining_after_npl * cumulative_delinq_prob
            
            # Principal remaining after NPL and delinquency
            remaining_after_delinq = remaining_after_npl - delinquency_amount
            
            # 3. Calculate prepayment effect
            # Based on principal after NPL and delinquency
            cumulative_prepay_prob = 1 - (1 - daily_prepayment_rate) ** days_diff
            prepayment_amount = remaining_after_delinq * cumulative_prepay_prob
            
            # Normal principal payment + prepayment
            scheduled_principal = principal_after_npl * (1 - cumulative_delinq_prob)
            actual_principal = scheduled_principal + prepayment_amount
            
            # 4. Calculate interest effects
            # a. Delinquency interest effect (typically with penalty interest)
            delinquency_ratio = delinquency_amount / remaining_after_npl if remaining_after_npl > 0 else 0
            delinquency_interest = interest_after_npl * delinquency_ratio * 1.5  # 1.5x penalty interest
            
            # b. Prepayment interest loss
            prepayment_interest_loss = 0
            if row["principal_amount"] > 0:
                interest_rate = row["interest_amount"] / row["principal_amount"]
                # Lost interest on prepaid amount (assume average half period)
                prepayment_interest_loss = prepayment_amount * interest_rate * 0.5  
            
            # Net interest
            actual_interest = (interest_after_npl * (1 - delinquency_ratio)) - prepayment_interest_loss + delinquency_interest
            
            # 5. Recovery calculations
            # Recovery for defaults and delinquencies after specific lag
            default_recovery = 0
            delinquency_recovery = 0
            
            # Calculate recovery from previous defaults based on recovery lag
            recovery_date = installment_date - timedelta(days=recovery_lag_days)
            for def_amount in defaulted_amounts:
                if def_amount["date"] <= recovery_date:
                    default_recovery += def_amount["amount"] * recovery_rate
                    def_amount["processed"] = True
            
            # Calculate recovery from previous delinquencies 
            for del_amount in delinquent_amounts:
                if del_amount["date"] <= recovery_date:
                    # Part of delinquency becomes default
                    default_portion = del_amount["amount"] * delinquency_to_default_rate
                    # Remaining part is either recovered or continues delinquent
                    recovery_portion = (del_amount["amount"] - default_portion) * delinquency_recovery_rate
                    
                    # Add recovery amount
                    delinquency_recovery += recovery_portion
                    
                    # Add default portion to defaults list
                    defaulted_amounts.append({
                        "date": del_amount["date"] + timedelta(days=30),  # Default after 30 days
                        "amount": default_portion,
                        "processed": False
                    })
                    
                    del_amount["processed"] = True
            
            # Remove processed amounts from lists
            defaulted_amounts = [d for d in defaulted_amounts if not d.get("processed", False)]
            delinquent_amounts = [d for d in delinquent_amounts if not d.get("processed", False)]
            
            # Add new default amount to list
            defaulted_amounts.append({
                "date": installment_date,
                "amount": npl_impact,
                "processed": False
            })
            
            # Add new delinquency amount to list
            delinquent_amounts.append({
                "date": installment_date,
                "amount": delinquency_amount,
                "processed": False
            })
            
            # 6. Calculate total actual cash flow
            actual_cashflow = actual_principal + actual_interest + default_recovery + delinquency_recovery
            
            # 7. Calculate reinvestment
            reinvest_amount = 0
            
            # Calculate reinvestment for all tranches (base + shift)
            for i, cf in enumerate(remaining_cashflows):
                cf_date = cf["date"]
                days_between = (installment_date - cf_date).days
                if days_between > 0:
                    # Tranche specific reinvest rate
                    base_reinvest_rate = 0
                    
                    # Find appropriate tranche
                    if i < len(structure.a_tranches):
                        # Class A tranche-specific rate
                        base_reinvest_rate = structure.a_tranches[i].reinvest_rate / 100
                    else:
                        # Class B rate
                        base_reinvest_rate = structure.b_tranche.reinvest_rate / 100
                    
                    # Apply shift
                    actual_reinvest_rate = max(0, base_reinvest_rate + reinvest_shift)
                    
                    # Calculate reinvestment return (simple interest)
                    reinvest_return = cf["amount"] * actual_reinvest_rate * days_between / 365
                    reinvest_amount += reinvest_return
            
            # 8. Update remaining principal
            remaining_principal -= actual_principal
            
            # 9. Add results
            result_df = pd.concat([result_df, pd.DataFrame({
                "installment_date": [installment_date],
                "original_principal": [row["principal_amount"]],
                "original_interest": [row["interest_amount"]],
                "original_cashflow": [row["cash_flow"]],
                "npl_impact": [npl_impact],
                "delinquency_amount": [delinquency_amount],
                "actual_principal": [actual_principal],
                "actual_interest": [actual_interest],
                "prepayment": [prepayment_amount],
                "default_recovery": [default_recovery],
                "delinquency_recovery": [delinquency_recovery],
                "actual_cashflow": [actual_cashflow],
                "reinvest_amount": [reinvest_amount],
                "total_actual_cashflow": [actual_cashflow + reinvest_amount],
                "remaining_principal": [remaining_principal]
            })], ignore_index=True)
            
            # 10. Remember cash flow for next period reinvestment
            remaining_cashflows.append({
                "date": installment_date,
                "amount": actual_cashflow
            })
            
            current_date = installment_date
        
        return result_df

# =========================================================================
# Class A Calculator
# =========================================================================

class ClassACalculator:
    """
    Class for calculating Class A payments
    """
    
    @staticmethod
    def calculate_interest_rate(base_rate: float, spread: float, days: int) -> float:
        """
        Calculates annual interest yield using simple interest formula
        """
        annual_rate = base_rate + spread  # %
        return annual_rate * (days / 365) / 100
    
    @staticmethod
    def calculate_class_a_payments(structure: ABSStructure) -> pd.DataFrame:
        """
        Calculates payments for all Class A tranches
        """
        start_date = pd.Timestamp(structure.start_date)
        results = []
        
        for i, tranche in enumerate(structure.a_tranches):
            maturity_date = start_date + pd.Timedelta(days=tranche.maturity_days)
            
            # Calculate interest rate
            interest_rate = ClassACalculator.calculate_interest_rate(
                tranche.base_rate, tranche.spread, tranche.maturity_days
            )
            
            # Calculate interest amount
            interest_amount = tranche.nominal * interest_rate
            
            # Add results
            results.append({
                "tranche_index": i,
                "tranche_name": f"Class A-{i+1}",
                "maturity_days": tranche.maturity_days,
                "maturity_date": maturity_date,
                "nominal": tranche.nominal,
                "interest_rate": interest_rate * 100,  # As %
                "interest_amount": interest_amount,
                "total_payment": tranche.nominal + interest_amount
            })
        
        return pd.DataFrame(results)

# =========================================================================
# Main Stress Testing Functions
# =========================================================================

def perform_stress_test(original_cashflows: pd.DataFrame, request: StressTestRequest) -> StressTestResponse:
    """
    Performs stress test and returns results
    """
    try:
        logger.info(f"Starting stress test: {request.scenario.name}")
        
        # 1. Prepare cash flow DataFrame
        df = CashFlowModeler.prepare_cashflow_df(original_cashflows)
        
        # 2. Calculate Class A payments
        class_a_payments = ClassACalculator.calculate_class_a_payments(request.structure)
        total_class_a_payments = class_a_payments["total_payment"].sum()
        
        # 3. Calculate original Class B coupon rate
        original_total_cashflow = df["cash_flow"].sum()
        original_class_b_available = original_total_cashflow - total_class_a_payments
        
        # Subtract operational expenses if any
        if request.structure.ops_expenses > 0:
            original_class_b_available -= request.structure.ops_expenses
        
        # Calculate coupon rate (annualized)
        b_tranche = request.structure.b_tranche
        b_maturity_years = b_tranche.maturity_days / 365
        original_class_b_rate = (original_class_b_available / b_tranche.nominal) / b_maturity_years * 100
        
        # 4. Model stressed cash flows
        modeled_cashflows = CashFlowModeler.model_cashflows(df, request.structure, request.scenario)
        
        # 5. Calculate stressed Class B coupon rate
        modeled_total_cashflow = modeled_cashflows["total_actual_cashflow"].sum()
        stressed_class_b_available = modeled_total_cashflow - total_class_a_payments
        
        # Subtract operational expenses if any
        if request.structure.ops_expenses > 0:
            stressed_class_b_available -= request.structure.ops_expenses
        
        # Must be at least 0 (no negative payment)
        stressed_class_b_available = max(0, stressed_class_b_available)
        
        # Calculate coupon rate (annualized)
        stressed_class_b_rate = (stressed_class_b_available / b_tranche.nominal) / b_maturity_years * 100
        
        # 6. Prepare results
        cashflow_reduction_pct = ((original_total_cashflow - modeled_total_cashflow) / original_total_cashflow) * 100 if original_total_cashflow > 0 else 0
        
        # Metrics
        total_npl_impact = modeled_cashflows["npl_impact"].sum()
        total_prepayment = modeled_cashflows["prepayment"].sum()
        total_reinvestment = modeled_cashflows["reinvest_amount"].sum()
        
        logger.info(f"Stress test completed: {request.scenario.name}")
        logger.info(f"Original Class B rate: {original_class_b_rate:.2f}%, Stressed: {stressed_class_b_rate:.2f}%")
        logger.info(f"Cash flow reduction: {cashflow_reduction_pct:.2f}%")
        
        # Create response
        response = StressTestResponse(
            original_class_b_rate=original_class_b_rate,
            stressed_class_b_rate=stressed_class_b_rate,
            difference=stressed_class_b_rate - original_class_b_rate,
            cashflow_reduction_pct=cashflow_reduction_pct,
            total_npl_impact=total_npl_impact,
            total_prepayment=total_prepayment,
            total_reinvestment=total_reinvestment,
            modeled_cashflows=modeled_cashflows.to_dict('records')
        )
        
        return response
        
    except Exception as e:
        logger.error(f"Stress test error: {str(e)}")
        logger.exception(e)
        raise ValueError(f"Stress test calculation failed: {str(e)}")

def perform_enhanced_stress_test(original_cashflows: pd.DataFrame, request) -> dict:
    """
    Handles enhanced stress test requests with additional parameters.
    
    This function converts the API request model to the internal model
    and executes the stress test with enhanced scenario parameters.
    
    Args:
        original_cashflows: DataFrame containing cash flow data
        request: Enhanced stress test request from the API
        
    Returns:
        Dictionary containing baseline, stress test, and difference results
    """
    try:
        logger.info(f"Starting enhanced stress test: {request.scenario.name}")
        
        # Convert from API request model to internal model
        structure = ABSStructure(
            start_date=request.structure.start_date.strftime("%Y-%m-%d"),
            a_tranches=[
                ClassATranche(
                    maturity_days=request.structure.a_maturities[i],
                    base_rate=request.structure.a_base_rates[i],
                    spread=request.structure.a_spreads[i],
                    reinvest_rate=request.structure.a_reinvest_rates[i],
                    nominal=request.structure.a_nominals[i]
                ) for i in range(len(request.structure.a_maturities))
            ],
            b_tranche=ClassBTranche(
                maturity_days=request.structure.b_maturity,
                base_rate=request.structure.b_base_rate,
                spread=request.structure.b_spread,
                reinvest_rate=request.structure.b_reinvest_rate,
                nominal=request.structure.b_nominal
            ),
            ops_expenses=request.structure.ops_expenses
        )
        
        # Create baseline scenario (no stress factors)
        baseline_scenario = StressScenario(
            name="Baseline",
            npl_rate=0.0,
            prepayment_rate=0.0,
            reinvestment_shift=0.0,
            recovery_rate=request.scenario.recovery_rate,
            recovery_lag=request.scenario.recovery_lag,
            delinquency_rate=0.0,
            delinquency_recovery_rate=request.scenario.delinquency_recovery_rate,
            delinquency_to_default_rate=request.scenario.delinquency_to_default_rate,
            repeat_delinquency_factor=request.scenario.repeat_delinquency_factor
        )
        
        # Create stress scenario with all enhanced parameters
        stress_scenario = StressScenario(
            name=request.scenario.name,
            npl_rate=request.scenario.npl_rate,
            prepayment_rate=request.scenario.prepayment_rate,
            reinvestment_shift=request.scenario.reinvestment_shift,
            recovery_rate=request.scenario.recovery_rate,
            recovery_lag=request.scenario.recovery_lag,
            delinquency_rate=request.scenario.delinquency_rate,
            delinquency_recovery_rate=request.scenario.delinquency_recovery_rate,
            delinquency_to_default_rate=request.scenario.delinquency_to_default_rate,
            repeat_delinquency_factor=request.scenario.repeat_delinquency_factor
        )
        
        # Calculate baseline results
        baseline_request = StressTestRequest(structure=structure, scenario=baseline_scenario)
        baseline_results = perform_stress_test(original_cashflows, baseline_request)
        
        # Calculate stress test results
        stress_request = StressTestRequest(structure=structure, scenario=stress_scenario)
        stress_results = perform_stress_test(original_cashflows, stress_request)
        
        # Prepare API response
        response = {
            "baseline": {
                "class_b_coupon_rate": baseline_results.original_class_b_rate,
                "total_cashflow": sum(cf["original_cashflow"] for cf in baseline_results.modeled_cashflows)
            },
            "stress_test": {
                "class_b_coupon_rate": stress_results.stressed_class_b_rate,
                "total_cashflow": sum(cf["total_actual_cashflow"] for cf in stress_results.modeled_cashflows),
                "total_npl_impact": stress_results.total_npl_impact,
                "total_prepayment": stress_results.total_prepayment,
                "total_reinvestment": stress_results.total_reinvestment
            },
            "difference": {
                "class_b_coupon_rate": stress_results.difference,
                "cashflow_reduction_pct": stress_results.cashflow_reduction_pct
            },
            "cashflows": {
                "baseline": baseline_results.modeled_cashflows[:10],  # Return only first 10 cashflows for brevity
                "stress": stress_results.modeled_cashflows[:10]
            }
        }
        
        logger.info(f"Enhanced stress test completed: {request.scenario.name}")
        return response
        
    except Exception as e:
        logger.error(f"Enhanced stress test error: {str(e)}")
        logger.exception(e)
        raise ValueError(f"Enhanced stress test calculation failed: {str(e)}")

======================================================================

