'stress' ANAHTAR KELİMESİ İÇİN ARAMA SONUÇLARI
======================================================================

FRONTEND SONUÇLARI:
==================

DOSYA: src\App.js
==================================================
// src/App.js
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";

import TopBar from "./components/TopBar";
import Footer from "./components/Footer";
import HomePage from "./pages/HomePage";
import CalculationPage from "./pages/CalculationPage";
import OptimizationPage from "./pages/OptimizationPage";
import StressTestingPage from "./pages/StressTestingPage";
import { DataProvider } from "./contexts/DataContext";
import ComparisonPage from "./pages/ComparisonPage";

// Create a dark navy theme
const theme = createTheme({
  palette: {
    mode: 'dark',
    primary: {
      main: '#4e7bea', // Modern blue
      light: '#6d92fd',
      dark: '#3461c7',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#9c27b0', // Purple
      light: '#bb4fd3',
      dark: '#7b1fa2',
      contrastText: '#ffffff',
    },
    error: {
      main: '#f44336',
      light: '#ff7961',
      dark: '#d32f2f',
    },
    warning: {
      main: '#ff9800',
      light: '#ffb74d',
      dark: '#f57c00',
    },
    info: {
      main: '#29b6f6',
      light: '#4fc3f7',
      dark: '#0288d1',
    },
    success: {
      main: '#4caf50',
      light: '#80e27e',
      dark: '#087f23',
    },
    background: {
      default: '#0f172a', // Dark navy
      paper: '#1e293b', // Lighter navy
    },
    text: {
      primary: '#e2e8f0',
      secondary: '#94a3b8',
    },
    divider: 'rgba(148, 163, 184, 0.12)',
  },
  typography: {
    fontFamily: '"Roboto", "Segoe UI", "Helvetica Neue", sans-serif',
    h4: {
      fontWeight: 500,
    },
    h5: {
      fontWeight: 500,
    },
    h6: {
      fontWeight: 500,
    },
    subtitle1: {
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none',
          boxShadow: '0 1px 3px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.7)',
          borderRadius: 8,
        },
        elevation1: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.7)',
        },
        elevation2: {
          boxShadow: '0 3px 6px rgba(0,0,0,0.7), 0 2px 4px rgba(0,0,0,0.8)',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          fontWeight: 500,
          borderRadius: 6,
        },
        contained: {
          boxShadow: '0 1px 2px rgba(0,0,0,0.3)',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        head: {
          fontWeight: 600,
          backgroundColor: 'rgba(78, 123, 234, 0.15)',
        },
      },
    },
    MuiTableRow: {
      styleOverrides: {
        root: {
          '&:last-child td': {
            borderBottom: 0,
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.7)',
          backgroundColor: '#0f172a', // Match background.default
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 6,
        },
      },
    },
    MuiCssBaseline: {
      styleOverrides: {
        body: {
          scrollbarColor: "#6b6b6b #2b2b2b",
          "&::-webkit-scrollbar, & *::-webkit-scrollbar": {
            backgroundColor: "#2b2b2b",
            width: 8,
          },
          "&::-webkit-scrollbar-thumb, & *::-webkit-scrollbar-thumb": {
            borderRadius: 8,
            backgroundColor: "#6b6b6b",
            minHeight: 24,
          },
          "&::-webkit-scrollbar-thumb:focus, & *::-webkit-scrollbar-thumb:focus": {
            backgroundColor: "#959595",
          },
          "&::-webkit-scrollbar-thumb:active, & *::-webkit-scrollbar-thumb:active": {
            backgroundColor: "#959595",
          },
          "&::-webkit-scrollbar-thumb:hover, & *::-webkit-scrollbar-thumb:hover": {
            backgroundColor: "#959595",
          },
        },
      },
    },
  },
});

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <DataProvider>
        <Router>
          <TopBar />
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/calculation" element={<CalculationPage />} />
            <Route path="/optimization" element={<OptimizationPage />} />
            <Route path="/comparison" element={<ComparisonPage />} />
            <Route path="/stress-testing" element={<StressTestingPage />} />
          </Routes>
          <Footer />
        </Router>
      </DataProvider>
    </ThemeProvider>
  );
}

export default App;

======================================================================

DOSYA: src\components\TopBar.js
==================================================
// frontend/src/components/TopBar.js
import React from 'react';
import { Link as RouterLink, useLocation } from 'react-router-dom';
import { 
  AppBar, 
  Toolbar, 
  Typography, 
  Button, 
  Box, 
  Container, 
  useTheme 
} from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import OptimizeIcon from '@mui/icons-material/Speed';
import HomeIcon from '@mui/icons-material/Home';
import CompareIcon from '@mui/icons-material/Compare';
import BusinessIcon from '@mui/icons-material/Business';
import AssessmentIcon from '@mui/icons-material/Assessment';
import { alpha } from '@mui/material/styles';

const TopBar = () => {
  const location = useLocation();
  const theme = useTheme();
  
  // Menu items with updated professional names
  const menuItems = [
    {
      path: '/',
      label: 'Dashboard',
      icon: <HomeIcon />
    },
    {
      path: '/calculation',
      label: 'Structure Analysis',
      icon: <CalculateIcon />
    },
    {
      path: '/optimization',
      label: 'Portfolio Optimizer',
      icon: <OptimizeIcon />
    },
    {
      path: '/comparison',
      label: 'Performance Metrics',
      icon: <CompareIcon />
    },
    {
      path: '/stress-testing',
      label: 'Stress Testing',
      icon: <AssessmentIcon />
    }
  ];
  
  return (
    <AppBar 
      position="static" 
      elevation={0}
      sx={{
        background: 'linear-gradient(90deg, #0f172a 0%, #1e293b 100%)',
        borderBottom: '1px solid rgba(78, 123, 234, 0.15)'
      }}
    >
      <Container maxWidth="lg">
        <Toolbar disableGutters>
          <Box
            sx={{
              display: 'flex',
              alignItems: 'center',
              flexGrow: 1,
            }}
          >
            <BusinessIcon 
              sx={{ 
                fontSize: 28, 
                color: theme.palette.primary.main,
                mr: 1.5 
              }} 
            />
            <Typography
              variant="h6"
              component={RouterLink}
              to="/"
              sx={{
                textDecoration: 'none',
                color: 'inherit',
                fontWeight: 600,
                letterSpacing: 0.5,
              }}
            >
              Advanced ABS Design
            </Typography>
          </Box>
          
          <Box sx={{ display: 'flex', gap: 1 }}>
            {menuItems.map((item) => (
              <Button 
                key={item.path}
                color="inherit" 
                component={RouterLink} 
                to={item.path}
                startIcon={item.icon}
                sx={{
                  px: 2,
                  py: 1,
                  borderRadius: 1,
                  backgroundColor: location.pathname === item.path 
                    ? alpha(theme.palette.primary.main, 0.15) 
                    : 'transparent',
                  '&:hover': {
                    backgroundColor: location.pathname === item.path 
                      ? alpha(theme.palette.primary.main, 0.25) 
                      : alpha(theme.palette.primary.main, 0.1),
                  }
                }}
              >
                {item.label}
              </Button>
            ))}
          </Box>
        </Toolbar>
      </Container>
    </AppBar>
  );
};

export default TopBar;

======================================================================

DOSYA: src\pages\StressTestingPage.js
==================================================
import React, { useState, useEffect } from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper, 
  Grid, 
  Slider, 
  TextField, 
  InputAdornment, 
  Button, 
  Tabs, 
  Tab, 
  Divider, 
  Chip,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  alpha,
  useTheme,
  ThemeProvider,
  createTheme,
  CssBaseline,
  IconButton,
  Tooltip,
  CircularProgress,
  Snackbar,
  Alert,
  Switch,
  FormControlLabel
} from '@mui/material';
import { styled } from '@mui/material/styles';
import RefreshIcon from '@mui/icons-material/Refresh';
import AssessmentIcon from '@mui/icons-material/Assessment';
import InfoOutlinedIcon from '@mui/icons-material/InfoOutlined';
import WarningAmberIcon from '@mui/icons-material/WarningAmber';
import TrendingUpIcon from '@mui/icons-material/TrendingUp';
import TrendingDownIcon from '@mui/icons-material/TrendingDown';
import AttachMoneyIcon from '@mui/icons-material/AttachMoney';
import ShowChartIcon from '@mui/icons-material/ShowChart';
import SaveAltIcon from '@mui/icons-material/SaveAlt';
import CompareArrowsIcon from '@mui/icons-material/CompareArrows';
import TuneIcon from '@mui/icons-material/Tune';
import ScienceIcon from '@mui/icons-material/Science';
import SettingsIcon from '@mui/icons-material/Settings';
import CompareIcon from '@mui/icons-material/Compare';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import { useData } from '../contexts/DataContext';
import { useNavigate } from 'react-router-dom';
import { runEnhancedStressTest } from '../services/apiService';

// Import Recharts components
import {
  LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip as RechartsTooltip, 
  Legend, ResponsiveContainer, AreaChart, Area, BarChart, Bar, ReferenceLine,
  ScatterChart, Scatter, ZAxis
} from 'recharts';

// Create a dark theme
const darkTheme = createTheme({
  palette: {
    mode: 'dark',
    primary: {
      main: '#4dabf5',
    },
    secondary: {
      main: '#ce93d8',
    },
    success: {
      main: '#66bb6a',
    },
    error: {
      main: '#f44336',
    },
    warning: {
      main: '#ffa726',
    },
    info: {
      main: '#29b6f6',
    },
    background: {
      default: '#0a1929',
      paper: '#132f4c',
    },
    text: {
      primary: '#ffffff',
      secondary: 'rgba(255, 255, 255, 0.7)',
    },
    divider: 'rgba(255, 255, 255, 0.12)',
    grid: 'rgba(255, 255, 255, 0.15)',
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          fontWeight: 500,
        },
      },
    },
    MuiCardContent: {
      styleOverrides: {
        root: {
          '&:last-child': {
            paddingBottom: 16,
          },
        },
      },
    },
  },
});

// Custom styled component for slider
const StyledSlider = styled(Slider)(({ theme }) => ({
  color: theme.palette.primary.main,
  height: 8,
  '& .MuiSlider-track': {
    border: 'none',
    backgroundImage: `linear-gradient(to right, ${theme.palette.primary.main}, ${theme.palette.primary.light})`,
  },
  '& .MuiSlider-thumb': {
    height: 24,
    width: 24,
    backgroundColor: theme.palette.background.paper,
    border: `2px solid ${theme.palette.primary.main}`,
    '&:focus, &:hover, &.Mui-active, &.Mui-focusVisible': {
      boxShadow: `0 0 0 8px ${alpha(theme.palette.primary.main, 0.16)}`,
    },
    '&:before': {
      display: 'none',
    },
  },
  '& .MuiSlider-valueLabel': {
    lineHeight: 1.2,
    fontSize: 12,
    background: 'unset',
    padding: 0,
    width: 32,
    height: 32,
    borderRadius: '50% 50% 50% 0',
    backgroundColor: theme.palette.primary.main,
    transformOrigin: 'bottom left',
    transform: 'translate(50%, -100%) rotate(-45deg) scale(0)',
    '&:before': { display: 'none' },
    '&.MuiSlider-valueLabelOpen': {
      transform: 'translate(50%, -100%) rotate(-45deg) scale(1)',
    },
    '& > *': {
      transform: 'rotate(45deg)',
    },
  },
}));

// Helper function to get color based on difference value
const getDifferenceColor = (diff, theme) => {
  if (diff >= -1) return theme.palette.success.main;
  if (diff >= -5) return theme.palette.warning.main;
  return theme.palette.error.main;
};

// Custom tooltip for charts
const CustomTooltip = ({ active, payload, label }) => {
  const theme = darkTheme;
  if (active && payload && payload.length) {
    return (
      <Paper
        elevation={3}
        sx={{
          p: 2,
          borderRadius: 1,
          boxShadow: '0 4px 12px rgba(0,0,0,0.2)',
          border: '1px solid',
          borderColor: alpha(theme.palette.primary.main, 0.1),
          backgroundColor: alpha(theme.palette.background.paper, 0.95),
          maxWidth: 300,
        }}
      >
        <Typography variant="subtitle2" gutterBottom>{label}</Typography>
        {payload.map((entry, index) => (
          <Box key={`tooltip-item-${index}`} sx={{ display: 'flex', justifyContent: 'space-between', my: 0.5, alignItems: 'center' }}>
            <Box sx={{ display: 'flex', alignItems: 'center' }}>
              <Box
                sx={{
                  width: 12,
                  height: 12,
                  backgroundColor: entry.color,
                  mr: 1,
                  borderRadius: '50%'
                }}
              />
              <Typography variant="body2" color="text.secondary">
                {entry.name}:
              </Typography>
            </Box>
            <Typography variant="body2" fontWeight="medium" color={entry.color}>
              {typeof entry.value === 'number' 
                ? entry.value.toFixed(2) + (entry.unit || '%')
                : entry.value}
            </Typography>
          </Box>
        ))}
      </Paper>
    );
  }
  return null;
};

// Advanced custom tooltip for scatter chart
const ScatterTooltip = ({ active, payload }) => {
  const theme = darkTheme;
  if (active && payload && payload.length) {
    const data = payload[0].payload;
    return (
      <Paper
        elevation={3}
        sx={{
          p: 2,
          borderRadius: 1,
          boxShadow: '0 4px 12px rgba(0,0,0,0.2)',
          border: '1px solid',
          borderColor: alpha(theme.palette.primary.main, 0.1),
          backgroundColor: alpha(theme.palette.background.paper, 0.95),
          maxWidth: 300,
        }}
      >
        <Typography variant="subtitle2" gutterBottom fontWeight="medium">
          Scenario Analysis
        </Typography>
        <Divider sx={{ my: 1 }} />
        <Grid container spacing={1}>
          <Grid item xs={6}>
            <Typography variant="body2" color="text.secondary">NPL Rate:</Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" fontWeight="medium">{data.npl}%</Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" color="text.secondary">Prepayment:</Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" fontWeight="medium">{data.prepayment}%</Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" color="text.secondary">Reinvest Shift:</Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" fontWeight="medium">{data.reinvest}%</Typography>
          </Grid>
          <Grid item xs={12}><Divider sx={{ my: 1 }} /></Grid>
          <Grid item xs={6}>
            <Typography variant="body2" color="text.secondary">Modeled Rate:</Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" fontWeight="medium" color={theme.palette.primary.main}>
              {data.modeled}%
            </Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" color="text.secondary">Realized Rate:</Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" fontWeight="medium" color={theme.palette.secondary.main}>
              {data.realized}%
            </Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" color="text.secondary">Difference:</Typography>
          </Grid>
          <Grid item xs={6}>
            <Typography variant="body2" fontWeight="medium" 
              color={getDifferenceColor(data.difference, theme)}>
              {data.difference}%
            </Typography>
          </Grid>
        </Grid>
      </Paper>
    );
  }
  return null;
};

/**
 * Improved function to format structure data for stress testing
 * 
 * @param {Object} structureDetails - Structure data from savedResults
 * @returns {Object} - Properly formatted structure object for API
 */
const formatStructureForStressTest = (structureDetails) => {
  console.log('Input structure details:', structureDetails);
  
  // Helper function to find data in different possible locations
  const extractProperty = (obj, keys, defaultValue) => {
    if (!obj) return defaultValue;
    
    for (const key of keys) {
      if (obj[key] !== undefined) {
        return obj[key];
      }
    }
    
    // For nested property paths using dot notation
    for (const key of keys) {
      if (key.includes('.')) {
        const parts = key.split('.');
        let value = obj;
        let found = true;
        
        for (const part of parts) {
          if (value && value[part] !== undefined) {
            value = value[part];
          } else {
            found = false;
            break;
          }
        }
        
        if (found) {
          return value;
        }
      }
    }
    
    return defaultValue;
  };

  // Helper function to ensure array fields
  const ensureNumericArray = (arr, minLength = 1, defaultValue = 0) => {
    if (!arr) {
      return Array(minLength).fill(defaultValue);
    }
    
    if (typeof arr === 'string') {
      try {
        const parsed = JSON.parse(arr);
        return Array.isArray(parsed) ? parsed.map(Number) : Array(minLength).fill(defaultValue);
      } catch (e) {
        return Array(minLength).fill(defaultValue);
      }
    }
    
    if (!Array.isArray(arr)) {
      const num = Number(arr);
      return isNaN(num) ? Array(minLength).fill(defaultValue) : [num];
    }
    
    return arr.map(item => {
      const num = Number(item);
      return isNaN(num) ? defaultValue : num;
    });
  };

  // Helper function to ensure numeric fields
  const ensureNumber = (value, defaultValue = 0) => {
    if (value === null || value === undefined) return defaultValue;
    const num = Number(value);
    return isNaN(num) ? defaultValue : num;
  };

  // Function to ensure date is in YYYY-MM-DD format
  const formatDateToString = (dateValue) => {
    // If it's already a string in ISO format, extract the date part
    if (typeof dateValue === 'string') {
      // Check if it looks like an ISO date
      if (dateValue.match(/^\d{4}-\d{2}-\d{2}(T|$)/)) {
        return dateValue.split('T')[0];
      }
      // Try to parse it as a date
      const parsed = new Date(dateValue);
      if (!isNaN(parsed.getTime())) {
        return parsed.toISOString().split('T')[0];
      }
      return dateValue; // Return as is if we can't parse it
    }
    
    // If it's a Date object
    if (dateValue instanceof Date) {
      return dateValue.toISOString().split('T')[0];
    }
    
    // If it's a timestamp number
    if (typeof dateValue === 'number') {
      return new Date(dateValue).toISOString().split('T')[0];
    }
    
    // Default to today's date as a fallback
    console.warn('Could not parse date, using current date');
    return new Date().toISOString().split('T')[0];
  };

  // Possible field mappings for finding data in the structure
  const possibleFieldMappings = {
    start_date: [
      'start_date', 
      'general_settings.start_date', 
      'date', 
      'startDate', 
      'issue_date',
      'structure.start_date'
    ],
    a_maturities: [
      'a_maturities', 
      'tranches_a.maturity_days', 
      'tranchesA.maturity_days', 
      'class_a_maturities',
      'maturity_days',
      'maturities',
      'tranche_maturities',
      'class_a.maturities',
      'class_a.maturity_days',
      'class_a_maturities'
    ],
    a_base_rates: [
      'a_base_rates', 
      'tranches_a.base_rate', 
      'tranchesA.base_rate',
      'class_a_base_rates',
      'base_rates',
      'class_a.base_rates',
      'class_a.base_rate',
      'class_a_rates'
    ],  
    a_spreads: [
      'a_spreads', 
      'tranches_a.spread', 
      'tranchesA.spread',
      'class_a_spreads',
      'spreads',
      'class_a.spreads',
      'class_a.spread'
    ],
    a_reinvest_rates: [
      'a_reinvest_rates', 
      'tranches_a.reinvest_rate', 
      'tranchesA.reinvest_rate',
      'class_a_reinvest_rates',
      'reinvest_rates',
      'class_a.reinvest_rates',
      'class_a.reinvest_rate',
      'class_a_reinvest'
    ],
    a_nominals: [
      'a_nominals', 
      'tranches_a.nominal', 
      'tranchesA.nominal',
      'class_a_nominals',
      'nominals',
      'class_a_principal',
      'class_a.nominals',
      'class_a.nominal'
    ],
    b_maturity: [
      'b_maturity', 
      'tranche_b.maturity_days', 
      'trancheB.maturity_days',
      'class_b_maturity',
      'class_b.maturity_days',
      'class_b.maturity'
    ],
    b_base_rate: [
      'b_base_rate', 
      'tranche_b.base_rate', 
      'trancheB.base_rate',
      'class_b_base_rate',
      'class_b.base_rate'
    ],
    b_spread: [
      'b_spread', 
      'tranche_b.spread', 
      'trancheB.spread',
      'class_b_spread',
      'class_b.spread'
    ],
    b_reinvest_rate: [
      'b_reinvest_rate', 
      'tranche_b.reinvest_rate', 
      'trancheB.reinvest_rate',
      'class_b_reinvest_rate',
      'class_b.reinvest_rate'
    ],
    b_nominal: [
      'b_nominal', 
      'tranche_b.nominal', 
      'trancheB.nominal', 
      'class_b_principal',
      'class_b.nominal',
      'class_b.principal',
      'class_b_nominal'
    ],
    ops_expenses: [
      'ops_expenses', 
      'operational_expenses', 
      'general_settings.operational_expenses',
      'expenses',
      'operational.expenses'
    ]
  };

  // Get start date and ensure it's formatted correctly
  let rawDate = extractProperty(structureDetails, possibleFieldMappings.start_date, null);
  let formattedDate = formatDateToString(rawDate);

  // Check for structured tranche data 
  let a_maturities = [], a_base_rates = [], a_spreads = [], a_reinvest_rates = [], a_nominals = [];
  let trancheDataFound = false;
  
  // Check for tranches in various possible field names and formats
  const possibleTrancheFields = [
    'tranches_a', 'tranchesA', 'class_a_tranches', 'class_a', 'tranches.a', 'a_tranches'
  ];
  
  for (const field of possibleTrancheFields) {
    const tranches = extractProperty(structureDetails, [field], null);
    if (Array.isArray(tranches) && tranches.length > 0 && typeof tranches[0] === 'object') {
      console.log(`Found tranches as array of objects in field: ${field}`, tranches);
      a_maturities = tranches.map(t => ensureNumber(t.maturity_days || t.maturity));
      a_base_rates = tranches.map(t => ensureNumber(t.base_rate));
      a_spreads = tranches.map(t => ensureNumber(t.spread));
      a_reinvest_rates = tranches.map(t => ensureNumber(t.reinvest_rate));
      a_nominals = tranches.map(t => ensureNumber(t.nominal || t.principal));
      trancheDataFound = true;
      break;
    }
  }
  
  // If we didn't find structured tranche data, look for the individual arrays
  if (!trancheDataFound) {
    console.log('No structured tranche data found, looking for individual arrays...');
    a_maturities = ensureNumericArray(extractProperty(structureDetails, possibleFieldMappings.a_maturities, []));
    
    // If we still don't have maturities, create a default one to prevent API errors
    if (a_maturities.length === 0) {
      console.log('No Class A maturities found, creating default value of [90]');
      a_maturities = [90]; // Default 90-day maturity as a fallback
    }
    
    const maxLength = a_maturities.length;
    a_base_rates = ensureNumericArray(extractProperty(structureDetails, possibleFieldMappings.a_base_rates, []), maxLength);
    a_spreads = ensureNumericArray(extractProperty(structureDetails, possibleFieldMappings.a_spreads, []), maxLength);
    a_reinvest_rates = ensureNumericArray(extractProperty(structureDetails, possibleFieldMappings.a_reinvest_rates, []), maxLength);
    a_nominals = ensureNumericArray(extractProperty(structureDetails, possibleFieldMappings.a_nominals, []), maxLength);
  }

  // Extract class B properties
  const b_maturity = ensureNumber(extractProperty(structureDetails, possibleFieldMappings.b_maturity, 180));
  const b_base_rate = ensureNumber(extractProperty(structureDetails, possibleFieldMappings.b_base_rate, 0));
  const b_spread = ensureNumber(extractProperty(structureDetails, possibleFieldMappings.b_spread, 0));
  const b_reinvest_rate = ensureNumber(extractProperty(structureDetails, possibleFieldMappings.b_reinvest_rate, 0));
  const b_nominal = ensureNumber(extractProperty(structureDetails, possibleFieldMappings.b_nominal, 0));
  const ops_expenses = ensureNumber(extractProperty(structureDetails, possibleFieldMappings.ops_expenses, 0));

  // Ensure lengths are consistent
  const maxLength = a_maturities.length;
  
  const result = {
    start_date: formattedDate,
    a_maturities: a_maturities,
    a_base_rates: a_base_rates.length === maxLength ? a_base_rates : Array(maxLength).fill(a_base_rates[0] || 0),
    a_spreads: a_spreads.length === maxLength ? a_spreads : Array(maxLength).fill(a_spreads[0] || 0),
    a_reinvest_rates: a_reinvest_rates.length === maxLength ? a_reinvest_rates : Array(maxLength).fill(a_reinvest_rates[0] || 0),
    a_nominals: a_nominals.length === maxLength ? a_nominals : Array(maxLength).fill(a_nominals[0] || 0),
    b_maturity: b_maturity,
    b_base_rate: b_base_rate,
    b_spread: b_spread,
    b_reinvest_rate: b_reinvest_rate,
    b_nominal: b_nominal,
    ops_expenses: ops_expenses
  };

  // Log the resulting structure
  console.log('Formatted structure for API:', result);
  
  return result;
};

/**
 * Generates sensitivity data for charts based on a single test result
 * 
 * @param {number} baselineRate - The baseline Class B coupon rate
 * @param {number} nplRate - The NPL rate from the stress test
 * @param {number} prepaymentRate - The prepayment rate from the stress test
 * @param {number} rateWithStress - The Class B coupon rate under stress
 * @returns {Object} - Object with sensitivity data for charts
 */
const generateSensitivityData = (baselineRate, nplRate, prepaymentRate, reinvestmentShift, rateWithStress) => {
  const nplImpact = baselineRate - rateWithStress;
  const nplSensitivity = [];
  const prepaymentSensitivity = [];
  const combinedScenarios = [];
  
  // Generate NPL sensitivity data
  [0, 1, 2, 3, 5, 7, 10, 15].forEach(testNplRate => {
    let impactFactor = 0;
    
    if (nplRate > 0) {
      // Estimate impact based on the single test result
      impactFactor = (testNplRate / nplRate) * nplImpact;
    } else {
      // Fallback if no NPL impact data available
      impactFactor = testNplRate * 0.3;
    }
    
    nplSensitivity.push({
      value: testNplRate,
      modeled: baselineRate,
      realized: Math.max(0, baselineRate - impactFactor),
      difference: -impactFactor
    });
  });
  
  // Generate prepayment sensitivity data
  [0, 5, 10, 15, 20, 30, 40, 50].forEach(testPrepaymentRate => {
    let impactFactor = 0;
    
    if (prepaymentRate > 0 && prepaymentRate !== 30) {
      // Prepayment impact is often U-shaped, with optimal around 30%
      // More impact as we move away from 30% (standard prepayment)
      const optimalPrepayment = 30;
      const prepaymentDiff = Math.abs(testPrepaymentRate - optimalPrepayment);
      const actualDiff = Math.abs(prepaymentRate - optimalPrepayment);
      
      if (actualDiff > 0) {
        impactFactor = (prepaymentDiff / actualDiff) * nplImpact * 0.5;
      }
    } else {
      // Fallback model if no specific prepayment data
      const optimalPrepayment = 30; 
      impactFactor = Math.abs(testPrepaymentRate - optimalPrepayment) * 0.1;
    }
    
    prepaymentSensitivity.push({
      value: testPrepaymentRate,
      modeled: baselineRate,
      realized: Math.max(0, baselineRate - impactFactor),
      difference: -impactFactor
    });
  });
  
  // Generate combined scenarios data for scatter plot
  const nplValues = [0, 1, 3, 5, 7, 10];
  const prepaymentValues = [5, 10, 20, 30, 40];
  
  nplValues.forEach(nValue => {
    prepaymentValues.forEach(pValue => {
      // Combine impacts for both factors
      const nplImpactFactor = (nValue / Math.max(1, nplRate)) * nplImpact;
      
      const optimalPrepayment = 30;
      const prepaymentDiff = Math.abs(pValue - optimalPrepayment);
      const actualPrepaymentDiff = Math.abs(prepaymentRate - optimalPrepayment);
      
      let prepaymentImpactFactor = 0;
      if (actualPrepaymentDiff > 0) {
        prepaymentImpactFactor = (prepaymentDiff / Math.max(1, actualPrepaymentDiff)) * nplImpact * 0.5;
      } else {
        prepaymentImpactFactor = prepaymentDiff * 0.1;
      }
      
      // Total impact is not just additive - worse conditions compound
      const combinedImpact = nplImpactFactor + prepaymentImpactFactor + (nplImpactFactor * prepaymentImpactFactor / 10);
      
      combinedScenarios.push({
        x: nValue,
        y: pValue,
        z: Math.abs(combinedImpact) * 10,  // Scale for bubble size
        npl: nValue,
        prepayment: pValue,
        reinvest: reinvestmentShift,
        modeled: baselineRate,
        realized: Math.max(0, baselineRate - combinedImpact),
        difference: -combinedImpact.toFixed(2)
      });
    });
  });
  
  return {
    npl: nplSensitivity,
    prepayment: prepaymentSensitivity,
    combinedScenarios: combinedScenarios
  };
};

const StressTestingPage = () => {
  const theme = darkTheme;
  const { calculationResults, savedResults } = useData();
  const navigate = useNavigate();
  // Start with NPL tab as default instead of summary
  const [tabValue, setTabValue] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  
  // State for stress test parameters with new base scenario values
  const [nplRange, setNplRange] = useState([1.5, 1.5]);
  const [prepaymentRange, setPrepaymentRange] = useState([30, 30]);
  const [reinvestmentRange, setReinvestmentRange] = useState([0, 0]);
  const [defaultReinvestRate, setDefaultReinvestRate] = useState(30);
  const [scenarios, setScenarios] = useState(10);
  const [selectedScenarioType, setSelectedScenarioType] = useState('base');
  
  // State variable for dropdown selection
  const [selectedStructureId, setSelectedStructureId] = useState('');
  const [availableStructures, setAvailableStructures] = useState([]);
  
  // State variables for predefined scenario
  const [predefinedScenario, setPredefinedScenario] = useState('base');
  
  // State variable for reinvestment shift toggle
  const [applyReinvestmentShift, setApplyReinvestmentShift] = useState(false);
  
  // State variables for notifications
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [snackbarSeverity, setSnackbarSeverity] = useState('success');

  // State for test results display panel
  const [showResults, setShowResults] = useState(false);
  
  // State for API test results
  const [testResults, setTestResults] = useState({
    classBCouponRate: null,
    scenarioResults: [],
    sensitivityAnalysis: {
      npl: [],
      prepayment: [],
      reinvestment: []
    },
    combinedScenarios: [],
    cashFlowModel: null
  });
  
  // Advanced model parameters state (now always active)
  const [showAdvancedSettings, setShowAdvancedSettings] = useState(false);
  const [recoveryRate, setRecoveryRate] = useState(0.5);
  const [recoveryLag, setRecoveryLag] = useState(6);
  const [delinquencyRate, setDelinquencyRate] = useState(null); // Will derive from NPL if null
  const [delinquencyRecoveryRate, setDelinquencyRecoveryRate] = useState(0.85);
  const [delinquencyToDefaultRate, setDelinquencyToDefaultRate] = useState(0.2);
  const [repeatDelinquencyFactor, setRepeatDelinquencyFactor] = useState(1.5);
  
  // Fetch Available Structures
  useEffect(() => {
    if (savedResults && savedResults.length > 0) {
      // Group results by structure type
      const structures = savedResults.map(result => {
        // Calculate coupon rate from Class B Coupon and Class B Principal if not available
        let directCouponRate = result.direct_class_b_coupon_rate;
        
        // If value is not present but coupon and principal are, calculate the rate
        if ((!directCouponRate || directCouponRate === 0) && result.class_b_coupon && result.class_b_principal) {
          directCouponRate = (result.class_b_coupon / result.class_b_principal) * 100;
        }
        
        return {
          id: result.id,
          name: result.savedName || `${result.methodType} Structure`,
          type: result.methodType,
          // Store coupon rate but don't display it in the dropdown
          classBCouponRate: directCouponRate || 0,
          directCouponRate: directCouponRate || 0,
          effectiveCouponRate: result.class_b_coupon_rate || 0
        };
      });
      
      setAvailableStructures(structures);
      
      // Set first structure as default if none selected
      if (structures.length > 0 && !selectedStructureId) {
        setSelectedStructureId(structures[0].id);
      }
    }
  }, [savedResults, selectedStructureId]);
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  // Handle structure selection change
  const handleStructureChange = (event) => {
    setSelectedStructureId(event.target.value);
  };
  
  // Get selected structure details
  const getSelectedStructure = () => {
    return availableStructures.find(structure => structure.id === selectedStructureId) || null;
  };

  // Navigate to the calculation page with a message
  const handleNavigateToCalculation = () => {
    navigate('/calculation');
  };

  // Run stress test with enhanced error handling and debugging
  const handleRunStressTest = async () => {
    const selectedStructure = getSelectedStructure();
    
    if (!selectedStructure) {
      setSnackbarMessage("Please select a structure to test");
      setSnackbarSeverity("error");
      setSnackbarOpen(true);
      return;
    }
    
    setIsLoading(true);
    setShowResults(false);
    
    try {
      // Get the original structure details from savedResults
      const structureDetails = savedResults.find(r => r.id === selectedStructure.id);
      
      if (!structureDetails) {
        throw new Error("Structure details not found");
      }
      
      // Log the structure details for debugging
      console.log('Original structure details:', structureDetails);
      
      // Extract parameters for the test with proper number conversion
      const nplRate = Number(nplRange[0]); 
      const prepaymentRate = Number(prepaymentRange[0]);
      const reinvestmentShift = applyReinvestmentShift ? Number(reinvestmentRange[0]) : 0;
      
      // Create formatted structure
      const formattedStructure = formatStructureForStressTest(structureDetails);
      
      // Enhanced stress test with cash flow modeling
      const requestParams = {
        structure: formattedStructure,
        scenario: {
          name: predefinedScenario,
          npl_rate: nplRate,
          prepayment_rate: prepaymentRate,
          reinvestment_shift: reinvestmentShift,
          recovery_rate: recoveryRate,
          recovery_lag: recoveryLag,
          delinquency_rate: delinquencyRate,
          delinquency_recovery_rate: delinquencyRecoveryRate,
          delinquency_to_default_rate: delinquencyToDefaultRate,
          repeat_delinquency_factor: repeatDelinquencyFactor
        }
      };
      
      console.log('STRESS TEST PAYLOAD:', JSON.stringify(requestParams, null, 2));
      const response = await runEnhancedStressTest(requestParams);
      
      console.log('Received stress test response:', response);
      
      // Extract rates and differences
      const baselineRate = response.baseline.class_b_coupon_rate;
      const stressRate = response.stress_test.class_b_coupon_rate;
      const rateDifference = response.difference.class_b_coupon_rate;
      
      // Generate sensitivity analysis data
      const sensitivityData = generateSensitivityData(
        baselineRate, 
        nplRate, 
        prepaymentRate,
        reinvestmentShift,
        stressRate
      );
      
      // Process response data
      const responseData = {
        classBCouponRate: {
          modeled: baselineRate,
          realized: stressRate,
          difference: rateDifference,
          status: rateDifference >= -1 ? 'success' : 
                 rateDifference >= -5 ? 'warning' : 'error'
        },
        scenarioResults: [
          {
            name: "Base Case",
            npl: 0,
            prepayment: 0,
            reinvestment: 0,
            modeled: baselineRate,
            realized: baselineRate,
            difference: 0
          },
          {
            name: predefinedScenario.charAt(0).toUpperCase() + predefinedScenario.slice(1),
            npl: nplRate,
            prepayment: prepaymentRate,
            reinvestment: reinvestmentShift,
            modeled: baselineRate,
            realized: stressRate,
            difference: rateDifference
          }
        ],
        sensitivityAnalysis: {
          npl: sensitivityData.npl,
          prepayment: sensitivityData.prepayment,
          reinvestment: []
        },
        combinedScenarios: sensitivityData.combinedScenarios,
        // Cash flow model metrics
        cashFlowModel: {
          cashFlowReduction: response.stress_test.total_cashflow_reduction_pct,
          defaultRate: response.stress_test.total_default_pct,
          delinquencyRate: response.stress_test.total_delinquency_pct,
          lossRate: response.stress_test.total_loss_pct,
          principalReduction: response.stress_test.principal_reduction_pct,
          recoveryRate: recoveryRate * 100,
          detailedMetrics: response.cash_flow_model
        }
      };
      
      // Update state with the results
      setTestResults(responseData);
      setIsLoading(false);
      setShowResults(true);
      setTabValue(0); // Switch to NPL tab to show results
      
      // Show success message
      setSnackbarMessage("Stress test completed successfully");
      setSnackbarSeverity("success");
      setSnackbarOpen(true);
      
    } catch (error) {
      console.error("Error running stress test:", error);
      
      // Enhanced error logging
      if (error.response) {
        console.error('RESPONSE ERROR DATA:', error.response.data);
        if (error.response.data.detail) {
          console.error('ERROR DETAIL:', error.response.data.detail);
        }
      }
      
      setIsLoading(false);
      
      // Extract the actual error message
      let errorMessage = "Error running stress test";
      if (error.response && error.response.data) {
        if (typeof error.response.data === 'string') {
          errorMessage += ": " + error.response.data;
        } else if (error.response.data.detail) {
          // Check for specific error patterns
          const detail = error.response.data.detail;
          if (detail.includes("No data found") || detail.includes("upload Excel file")) {
            errorMessage = "You need to upload an Excel file with loan data before running a stress test. Please go to the Structure Analysis page first.";
            
            // Show an alert with a button to navigate to Structure Analysis
            setSnackbarMessage(errorMessage);
            setSnackbarSeverity("warning");
            setSnackbarOpen(true);
            return;
          } else {
            errorMessage += ": " + detail;
          }
        }
      } else if (error.message) {
        errorMessage += ": " + error.message;
      }
      
      setSnackbarMessage(errorMessage);
      setSnackbarSeverity("error");
      setSnackbarOpen(true);
    }
  };
  
  // Format data for the sensitivity charts
  const formatSensitivityData = (dataKey) => {
    if (!testResults?.sensitivityAnalysis?.[dataKey]) {
      return [];
    }
    
    return testResults.sensitivityAnalysis[dataKey].map(item => ({
      value: item.value || 0,
      modeled: item.modeled || 0,
      realized: item.realized || 0,
      difference: (item.realized || 0) - (item.modeled || 0)
    }));
  };
  
  // Format combined scenarios data for scatter plot
  const formatScatterData = () => {
    if (!testResults?.combinedScenarios) {
      return [];
    }
    
    return testResults.combinedScenarios.map(item => ({
      x: item.npl || 0, // NPL rate for X axis
      y: item.prepayment || 0, // Prepayment rate for Y axis
      z: Math.abs((item.realized || 0) - (item.modeled || 0)) * 10, // Difference size for bubble size (scaled)
      npl: item.npl || 0,
      prepayment: item.prepayment || 0,
      reinvest: item.reinvest || 0,
      modeled: item.modeled || 0,
      realized: item.realized || 0,
      difference: ((item.realized || 0) - (item.modeled || 0)).toFixed(2)
    }));
  };

  // Handle close for snackbar
  const handleCloseSnackbar = (event, reason) => {
    if (reason === 'clickaway') {
      return;
    }
    setSnackbarOpen(false);
  };

  // Cash Flow Model Results component
  const CashFlowModelResults = ({ model }) => {
    if (!model) return null;
    
    return (
      <Paper
        elevation={3}
        sx={{
          p: 3,
          mb: 4,
          borderRadius: 2,
          backgroundColor: alpha(theme.palette.background.paper, 0.8),
          border: `1px solid ${alpha(theme.palette.info.main, 0.3)}`,
        }}
      >
        <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
          <ScienceIcon sx={{ mr: 1, color: theme.palette.info.main }} />
          Cash Flow Model Analysis
        </Typography>
        
        <Grid container spacing={2}>
          <Grid item xs={12} sm={6} md={4}>
            <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.error.main, 0.1) }}>
              <Typography variant="subtitle2" color="text.secondary">
                Default Rate
              </Typography>
              <Typography variant="h5" color="error" fontWeight="medium">
                {model.defaultRate}%
              </Typography>
            </Paper>
          </Grid>
          
          <Grid item xs={12} sm={6} md={4}>
            <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.warning.main, 0.1) }}>
              <Typography variant="subtitle2" color="text.secondary">
                Delinquency Rate
              </Typography>
              <Typography variant="h5" color="warning" fontWeight="medium">
                {model.delinquencyRate}%
              </Typography>
            </Paper>
          </Grid>
          
          <Grid item xs={12} sm={6} md={4}>
            <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.primary.main, 0.1) }}>
              <Typography variant="subtitle2" color="text.secondary">
                Cash Flow Reduction
              </Typography>
              <Typography variant="h5" color="primary" fontWeight="medium">
                {model.cashFlowReduction}%
              </Typography>
            </Paper>
          </Grid>
        </Grid>
        
        <Box sx={{ mt: 3, p: 2, borderRadius: 2, bgcolor: alpha(theme.palette.background.paper, 0.4) }}>
          <Typography variant="subtitle1" fontWeight="medium" gutterBottom>
            Stress Scenario Metrics:
          </Typography>
          
          <Grid container spacing={3}>
            <Grid item xs={12} sm={6} md={4}>
              <Typography variant="body2" color="text.secondary">Total Loss:</Typography>
              <Typography variant="body1" fontWeight="medium">
                {model.lossRate}% of Principal
              </Typography>
            </Grid>
            
            <Grid item xs={12} sm={6} md={4}>
              <Typography variant="body2" color="text.secondary">Principal Reduction:</Typography>
              <Typography variant="body1" fontWeight="medium">
                {model.principalReduction}%
              </Typography>
            </Grid>
            
            <Grid item xs={12} sm={6} md={4}>
              <Typography variant="body2" color="text.secondary">Recovery Rate:</Typography>
              <Typography variant="body1" fontWeight="medium">
                {model.recoveryRate}%
              </Typography>
            </Grid>
          </Grid>
        </Box>
      </Paper>
    );
  };

  // Advanced Model Parameters component
  const AdvancedModelParameters = () => (
    <React.Fragment>
      <Box sx={{ mt: 3, mb: 1, display: 'flex', justifyContent: 'flex-end' }}>
        <Button
          size="small"
          onClick={() => setShowAdvancedSettings(!showAdvancedSettings)}
          startIcon={showAdvancedSettings ? <ExpandLessIcon /> : <ExpandMoreIcon />}
        >
          {showAdvancedSettings ? "Hide" : "Show"} Advanced Parameters
        </Button>
      </Box>
      
      {showAdvancedSettings && (
        <Paper sx={{ p: 2, mt: 2, mb: 2, backgroundColor: alpha(theme.palette.background.paper, 0.6) }}>
          <Typography variant="subtitle2" gutterBottom>Cash Flow Model Parameters</Typography>
          
          <Grid container spacing={2}>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Recovery Rate"
                value={recoveryRate}
                onChange={(e) => setRecoveryRate(Number(e.target.value))}
                type="number"
                inputProps={{ min: 0, max: 1, step: 0.05 }}
                size="small"
                sx={{ mb: 2 }}
                helperText="Percentage of defaults recovered (0-1)"
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Recovery Lag (days)"
                value={recoveryLag}
                onChange={(e) => setRecoveryLag(Number(e.target.value))}
                type="number"
                inputProps={{ min: 0, step: 1 }}
                size="small"
                sx={{ mb: 2 }}
                helperText="Days until recovery occurs"
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Delinquency Rate"
                value={delinquencyRate === null ? '' : delinquencyRate}
                onChange={(e) => {
                  const value = e.target.value === '' ? null : Number(e.target.value);
                  setDelinquencyRate(value);
                }}
                type="number"
                inputProps={{ min: 0, max: 100, step: 0.1 }}
                size="small"
                sx={{ mb: 2 }}
                helperText="Leave blank to use half of NPL rate"
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Delinquency Recovery Rate"
                value={delinquencyRecoveryRate}
                onChange={(e) => setDelinquencyRecoveryRate(Number(e.target.value))}
                type="number"
                inputProps={{ min: 0, max: 1, step: 0.05 }}
                size="small"
                sx={{ mb: 2 }}
                helperText="Percentage of delinquencies recovered (0-1)"
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Delinquency to Default Rate"
                value={delinquencyToDefaultRate}
                onChange={(e) => setDelinquencyToDefaultRate(Number(e.target.value))}
                type="number"
                inputProps={{ min: 0, max: 1, step: 0.05 }}
                size="small"
                sx={{ mb: 2 }}
                helperText="Portion of delinquent loans that default"
              />
            </Grid>
            
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Repeat Delinquency Factor"
                value={repeatDelinquencyFactor}
                onChange={(e) => setRepeatDelinquencyFactor(Number(e.target.value))}
                type="number"
                inputProps={{ min: 1, step: 0.1 }}
                size="small"
                sx={{ mb: 2 }}
                helperText="Increases likelihood of repeated delinquency"
              />
            </Grid>
          </Grid>
        </Paper>
      )}
      
      {!showAdvancedSettings && (
        <Typography variant="body2" color="text.secondary" sx={{ mt: 1, mb: 2 }}>
          The stress test uses a detailed cash flow model that simulates loan defaults, prepayments, and delinquencies. 
          Show advanced parameters for fine-tuning these behaviors.
        </Typography>
      )}
    </React.Fragment>
  );

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
        {/* Page Header */}
        <Box
          sx={{
            mb: 4,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between'
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <AssessmentIcon 
              sx={{ 
                fontSize: 36, 
                color: theme.palette.primary.main,
                mr: 2,
                filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))'
              }} 
            />
            <Box>
              <Typography variant="h4" fontWeight="500">
                Stress Testing
              </Typography>
              <Typography variant="subtitle1" color="text.secondary">
                Analyze Class B coupon performance under various market conditions
              </Typography>
            </Box>
          </Box>
          
          <Box sx={{ display: 'flex', gap: 2 }}>
            <Button
              variant="outlined"
              color="primary"
              onClick={handleNavigateToCalculation}
              sx={{
                px: 3,
                py: 1,
                borderRadius: 2,
              }}
            >
              Go to Structure Analysis
            </Button>
            
            <Button
              variant="contained"
              color="primary"
              startIcon={<SaveAltIcon />}
              sx={{
                px: 3,
                py: 1,
                borderRadius: 2,
                boxShadow: '0 3px 8px rgba(0,0,0,0.3)',
              }}
              disabled={!showResults}
            >
              Export Results
            </Button>
          </Box>
        </Box>
        
        {/* Structure Dropdown Selection */}
        <Paper
          elevation={3}
          sx={{
            p: 3,
            mb: 4,
            borderRadius: 2,
            backgroundColor: alpha(theme.palette.background.paper, 0.8),
            border: `1px solid ${alpha(theme.palette.warning.main, 0.2)}`,
          }}
        >
          <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
            <CompareIcon sx={{ mr: 1, color: theme.palette.warning.light }} />
            Select Structure to Stress Test
          </Typography>
          
          {availableStructures.length > 0 ? (
            <FormControl fullWidth variant="outlined">
              <InputLabel id="structure-select-label">Select Structure</InputLabel>
              <Select
                labelId="structure-select-label"
                id="structure-select"
                value={selectedStructureId}
                onChange={handleStructureChange}
                label="Select Structure"
                sx={{ mb: 2 }}
              >
                {availableStructures.map((structure) => (
                  <MenuItem key={structure.id} value={structure.id}>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      {structure.type === 'manual' && <TuneIcon sx={{ color: theme.palette.error.main, mr: 1 }} />}
                      {structure.type === 'genetic' && <ScienceIcon sx={{ color: theme.palette.success.main, mr: 1 }} />}
                      {structure.type === 'standard' && <SettingsIcon sx={{ color: theme.palette.primary.main, mr: 1 }} />}
                      <Typography>{structure.name}</Typography>
                    </Box>
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
          ) : (
            <Alert 
              severity="info"
              action={
                <Button color="inherit" size="small" onClick={handleNavigateToCalculation}>
                  Go to Analysis
                </Button>
              }
            >
              No saved structures found. Please calculate and save at least one structure before running stress tests.
            </Alert>
          )}
          
          {getSelectedStructure() && (
            <Box sx={{ mt: 2, p: 2, borderRadius: 1, bgcolor: alpha(theme.palette.warning.main, 0.05) }}>
              <Typography variant="subtitle2" gutterBottom>Selected Structure Details:</Typography>
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                  <Typography variant="body2" color="text.secondary">Type:</Typography>
                  <Typography variant="body1">
                    {getSelectedStructure().type === 'manual' ? 'Manual Calculation' : 
                     getSelectedStructure().type === 'genetic' ? 'Genetic Algorithm' : 
                     'Grid Algorithm'}
                  </Typography>
                </Grid>
                <Grid item xs={12} sm={6}>
                  <Typography variant="body2" color="text.secondary">Structure Name:</Typography>
                  <Typography variant="body1">
                    {getSelectedStructure().name}
                  </Typography>
                </Grid>
              </Grid>
            </Box>
          )}
        </Paper>
        
        <Grid container spacing={4}>
          {/* Parameters Panel */}
          <Grid item xs={12} md={4}>
            <Paper 
              elevation={3}
              sx={{ 
                p: 3, 
                height: '100%',
                borderRadius: 2,
                backgroundColor: alpha(theme.palette.background.paper, 0.8),
                border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
              }}
            >
              <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                <TuneIcon sx={{ mr: 1, color: theme.palette.primary.light }} />
                Stress Test Parameters
              </Typography>
              
              {/* Predefined Scenario Selection with updated values */}
              <Box sx={{ mt: 3 }}>
                <Typography variant="subtitle2" gutterBottom display="flex" alignItems="center">
                  <CompareArrowsIcon sx={{ fontSize: 20, mr: 1, color: theme.palette.info.light }} />
                  Predefined Scenarios
                  <Tooltip title="Select a predefined scenario or customize parameters manually" sx={{ ml: 1 }}>
                    <IconButton size="small">
                      <InfoOutlinedIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Typography>
                
                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2, mt: 1 }}>
                  <Button
                    variant={predefinedScenario === 'optimistic' ? 'contained' : 'outlined'}
                    color="success"
                    onClick={() => {
                      setPredefinedScenario('optimistic');
                      setNplRange([1, 1]);
                      setPrepaymentRange([20, 20]);
                      setReinvestmentRange([2, 2]);
                      setApplyReinvestmentShift(true);
                    }}
                    size="small"
                    sx={{ borderRadius: 2 }}
                  >
                    Optimistic
                  </Button>
                  
                  <Button
                    variant={predefinedScenario === 'base' ? 'contained' : 'outlined'}
                    color="primary"
                    onClick={() => {
                      setPredefinedScenario('base');
                      setNplRange([1.5, 1.5]);
                      setPrepaymentRange([30, 30]);
                      setReinvestmentRange([0, 0]);
                      setApplyReinvestmentShift(false);
                    }}
                    size="small"
                    sx={{ borderRadius: 2 }}
                  >
                    Base Case
                  </Button>
                  
                  <Button
                    variant={predefinedScenario === 'moderate' ? 'contained' : 'outlined'}
                    color="secondary"
                    onClick={() => {
                      setPredefinedScenario('moderate');
                      setNplRange([3, 3]);
                      setPrepaymentRange([15, 15]);
                      setReinvestmentRange([-3, -3]);
                      setApplyReinvestmentShift(true);
                    }}
                    size="small"
                    sx={{ borderRadius: 2 }}
                  >
                    Moderate
                  </Button>
                  
                  <Button
                    variant={predefinedScenario === 'severe' ? 'contained' : 'outlined'}
                    color="error"
                    onClick={() => {
                      setPredefinedScenario('severe');
                      setNplRange([5, 5]);
                      setPrepaymentRange([10, 10]);
                      setReinvestmentRange([-5, -5]);
                      setApplyReinvestmentShift(true);
                    }}
                    size="small"
                    sx={{ borderRadius: 2 }}
                  >
                    Severe
                  </Button>
                  
                  <Button
                    variant={predefinedScenario === 'extreme' ? 'contained' : 'outlined'}
                    color="warning"
                    onClick={() => {
                      setPredefinedScenario('extreme');
                      setNplRange([7, 7]);
                      setPrepaymentRange([5, 5]);
                      setReinvestmentRange([-10, -10]);
                      setApplyReinvestmentShift(true);
                    }}
                    size="small"
                    sx={{ borderRadius: 2 }}
                  >
                    Extreme
                  </Button>
                  
                  <Button
                    variant={predefinedScenario === 'custom' ? 'contained' : 'outlined'}
                    onClick={() => {
                      setPredefinedScenario('custom');
                    }}
                    size="small"
                    sx={{ borderRadius: 2 }}
                  >
                    Custom
                  </Button>
                </Box>
              </Box>
              
              <Box sx={{ mt: 3 }}>
                <Typography variant="subtitle2" gutterBottom display="flex" alignItems="center">
                  <WarningAmberIcon sx={{ fontSize: 20, mr: 1, color: theme.palette.warning.main }} />
                  NPL Rate Range (%)
                  <Tooltip title="Non-Performing Loan rate affects the cash flow available for Class B payment" sx={{ ml: 1 }}>
                    <IconButton size="small">
                      <InfoOutlinedIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Typography>
                <Box sx={{ px: 1, pt: 1, pb: 2 }}>
                  <StyledSlider
                    value={nplRange}
                    onChange={(e, value) => setNplRange(value)}
                    valueLabelDisplay="auto"
                    min={0}
                    max={15}
                    step={0.5}
                    marks={[
                      { value: 0, label: '0%' },
                      { value: 1.5, label: '1.5%' },
                      { value: 5, label: '5%' },
                      { value: 10, label: '10%' },
                      { value: 15, label: '15%' }
                    ]}
                  />
                </Box>
              </Box>
              
              <Box sx={{ mt: 3 }}>
                <Typography variant="subtitle2" gutterBottom display="flex" alignItems="center">
                  <TrendingDownIcon sx={{ fontSize: 20, mr: 1, color: theme.palette.primary.light }} />
                  Prepayment Rate Range (%)
                  <Tooltip title="Early prepayment rates affect the expected cash flow timing" sx={{ ml: 1 }}>
                    <IconButton size="small">
                      <InfoOutlinedIcon fontSize="small" />
                    </IconButton>
                  </Tooltip>
                </Typography>
                <Box sx={{ px: 1, pt: 1, pb: 2 }}>
                  <StyledSlider
                    value={prepaymentRange}
                    onChange={(e, value) => setPrepaymentRange(value)}
                    valueLabelDisplay="auto"
                    min={0}
                    max={50}
                    step={1}
                    marks={[
                      { value: 0, label: '0%' },
                      { value: 10, label: '10%' },
                      { value: 20, label: '20%' },
                      { value: 30, label: '30%' },
                      { value: 40, label: '40%' },
                      { value: 50, label: '50%' }
                    ]}
                  />
                </Box>
              </Box>
              
              {/* Reinvestment Rate Shift Toggle */}
              <Box sx={{ mt: 3 }}>
                <FormControl component="fieldset">
                  <FormControlLabel
                    control={
                      <Switch 
                        checked={applyReinvestmentShift}
                        onChange={(e) => setApplyReinvestmentShift(e.target.checked)}
                        color="primary"
                      />
                    }
                    label="Apply Reinvestment Rate Shift"
                  />
                  <Typography variant="body2" color="text.secondary">
                    When enabled, all reinvestment rates will shift by the specified amount
                  </Typography>
                </FormControl>
                
                {applyReinvestmentShift && (
                  <Box sx={{ px: 1, pt: 1, pb: 2 }}>
                    <Typography variant="subtitle2" gutterBottom display="flex" alignItems="center">
                      <AttachMoneyIcon sx={{ fontSize: 20, mr: 1, color: theme.palette.secondary.light }} />
                      Reinvestment Rate Shift (±%)
                    </Typography>
                    <StyledSlider
                      value={reinvestmentRange}
                      onChange={(e, value) => setReinvestmentRange(value)}
                      valueLabelDisplay="auto"
                      min={-10}
                      max={10}
                      step={1}
                      marks={[
                        { value: -10, label: '-10%' },
                        { value: -5, label: '-5%' },
                        { value: 0, label: '0%' },
                        { value: 5, label: '+5%' },
                        { value: 10, label: '+10%' }
                      ]}
                    />
                  </Box>
                )}
              </Box>
              
              {/* Advanced model parameters - now always visible */}
              <AdvancedModelParameters />
              
              <Box sx={{ mt: 3 }}>
                <TextField
                  fullWidth
                  label="Base Reinvestment Rate (%)"
                  value={defaultReinvestRate}
                  onChange={(e) => setDefaultReinvestRate(Number(e.target.value))}
                  type="number"
                  InputProps={{
                    endAdornment: <InputAdornment position="end">%</InputAdornment>,
                  }}
                  variant="outlined"
                  size="small"
                  sx={{ mb: 3 }}
                />
                
                <Button
                  variant="contained"
                  color="primary"
                  fullWidth
                  size="large"
                  startIcon={isLoading ? <CircularProgress size={20} color="inherit" /> : <AssessmentIcon />}
                  onClick={handleRunStressTest}
                  disabled={isLoading || !selectedStructureId}
                  sx={{
                    py: 1.2,
                    borderRadius: 2,
                    boxShadow: '0 4px 10px rgba(0,0,0,0.3)',
                    '&:hover': {
                      boxShadow: '0 6px 14px rgba(0,0,0,0.4)',
                    }
                  }}
                >
                  {isLoading ? 'Running Tests...' : 'Run Stress Tests'}
                </Button>
              </Box>
            </Paper>
          </Grid>
          
          {/* Results Panel */}
          <Grid item xs={12} md={8}>
            {/* Cash Flow Model Results */}
            {showResults && testResults.cashFlowModel && (
              <CashFlowModelResults model={testResults.cashFlowModel} />
            )}
            
            {/* Current Test Results Summary */}
            {showResults && testResults.classBCouponRate && (
              <Paper
                elevation={3}
                sx={{
                  p: 3,
                  mb: 4,
                  borderRadius: 2,
                  backgroundColor: alpha(theme.palette.background.paper, 0.8),
                  border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
                }}
              >
                <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <ShowChartIcon sx={{ mr: 1, color: theme.palette.primary.main }} />
                  Stress Test Results
                </Typography>
                
                <Grid container spacing={3}>
                  <Grid item xs={12} sm={4}>
                    <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.primary.main, 0.1) }}>
                      <Typography variant="subtitle2" color="text.secondary">
                        Base Coupon Rate
                      </Typography>
                      <Typography variant="h4" color="primary" fontWeight="bold">
                        {testResults.classBCouponRate.modeled.toFixed(2)}%
                      </Typography>
                    </Paper>
                  </Grid>
                  
                  <Grid item xs={12} sm={4}>
                    <Paper sx={{ p: 2, textAlign: 'center', bgcolor: alpha(theme.palette.secondary.main, 0.1) }}>
                      <Typography variant="subtitle2" color="text.secondary">
                        Stress Coupon Rate
                      </Typography>
                      <Typography variant="h4" color="secondary" fontWeight="bold">
                        {testResults.classBCouponRate.realized.toFixed(2)}%
                      </Typography>
                    </Paper>
                  </Grid>
                  
                  <Grid item xs={12} sm={4}>
                    <Paper sx={{ 
                      p: 2, 
                      textAlign: 'center', 
                      bgcolor: alpha(
                        testResults.classBCouponRate.status === 'success' ? theme.palette.success.main :
                        testResults.classBCouponRate.status === 'warning' ? theme.palette.warning.main :
                        theme.palette.error.main, 
                        0.1
                      ) 
                    }}>
                      <Typography variant="subtitle2" color="text.secondary">
                        Impact
                      </Typography>
                      <Typography 
                        variant="h4" 
                        fontWeight="bold"
                        color={getDifferenceColor(testResults.classBCouponRate.difference, theme)}
                      >
                        {testResults.classBCouponRate.difference > 0 ? '+' : ''}
                        {testResults.classBCouponRate.difference.toFixed(2)}%
                      </Typography>
                    </Paper>
                  </Grid>
                </Grid>
              </Paper>
            )}
            
            <Paper 
              elevation={3}
              sx={{ 
                borderRadius: 2,
                overflow: 'hidden',
                backgroundColor: alpha(theme.palette.background.paper, 0.8),
                border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
              }}
            >
              <Box sx={{ 
                borderBottom: 1, 
                borderColor: 'divider',
                backgroundColor: alpha(theme.palette.background.paper, 0.4),
                px: 2
              }}>
                <Tabs
                  value={tabValue}
                  onChange={handleTabChange}
                  variant="scrollable"
                  scrollButtons="auto"
                  sx={{
                    '& .MuiTab-root': {
                      minWidth: 100,
                      py: 2
                    }
                  }}
                >
                  <Tab 
                    label="NPL Sensitivity" 
                    icon={<WarningAmberIcon />} 
                    iconPosition="start"
                  />
                  <Tab 
                    label="Prepayment Impact" 
                    icon={<TrendingDownIcon />} 
                    iconPosition="start"
                  />
                  <Tab 
                    label="Combined Analysis" 
                    icon={<CompareArrowsIcon />} 
                    iconPosition="start"
                  />
                </Tabs>
              </Box>
              
              {/* NPL Sensitivity Tab (now the default tab) */}
              {tabValue === 0 && (
                <Box sx={{ p: 3 }}>
                  <Typography variant="h6" gutterBottom>
                    Class B Coupon Rate vs. NPL Rates
                  </Typography>
                  <Typography variant="body2" color="text.secondary" paragraph>
                    This analysis shows how Non-Performing Loan (NPL) rates affect the Class B coupon rates. Higher NPL rates typically reduce available cash flow for Class B payments.
                  </Typography>
                  
                  {testResults.sensitivityAnalysis.npl.length > 0 ? (
                    <Box sx={{ height: 400, mb: 4 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <LineChart
                          data={formatSensitivityData('npl')}
                          margin={{ top: 20, right: 30, left: 20, bottom: 10 }}
                        >
                          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.grid} />
                          <XAxis 
                            dataKey="value"
                            label={{ value: 'NPL Rate (%)', position: 'insideBottomRight', offset: -5, fill: theme.palette.text.secondary }}
                            tick={{ fill: theme.palette.text.secondary }}
                          />
                          <YAxis 
                            tickFormatter={(value) => `${value}%`}
                            label={{ value: 'Coupon Rate (%)', angle: -90, position: 'insideLeft', fill: theme.palette.text.secondary }}
                            tick={{ fill: theme.palette.text.secondary }}
                            domain={[0, 'dataMax + 5']}
                          />
                          <RechartsTooltip content={<CustomTooltip />} />
                          <Legend 
                            wrapperStyle={{ paddingTop: 20 }}
                            formatter={(value) => (
                              <span style={{ color: theme.palette.text.primary }}>{value}</span>
                            )}
                          />
                          <Line 
                            type="monotone" 
                            dataKey="modeled" 
                            name="Modeled Rate" 
                            stroke={theme.palette.primary.main}
                            strokeWidth={2}
                            dot={{ r: 5, fill: theme.palette.primary.main }}
                            activeDot={{ r: 7, fill: theme.palette.primary.light }}
                          />
                          <Line 
                            type="monotone" 
                            dataKey="realized" 
                            name="Realized Rate" 
                            stroke={theme.palette.secondary.main}
                            strokeWidth={2}
                            dot={{ r: 5, fill: theme.palette.secondary.main }}
                            activeDot={{ r: 7, fill: theme.palette.secondary.light }}
                          />
                        </LineChart>
                      </ResponsiveContainer>
                    </Box>
                  ) : (
                    <Box sx={{ p: 8, textAlign: 'center' }}>
                      <Typography variant="subtitle1" color="text.secondary">
                        Run a stress test to see NPL sensitivity analysis
                      </Typography>
                    </Box>
                  )}
                  
                  <Box sx={{ mt: 4, p: 3, borderRadius: 2, bgcolor: alpha(theme.palette.background.paper, 0.4), border: `1px solid ${alpha(theme.palette.primary.main, 0.1)}` }}>
                    <Typography variant="subtitle1" fontWeight="medium" gutterBottom>
                      Key Insights:
                    </Typography>
                    <Typography variant="body2" color="text.secondary" paragraph>
                      • The modeled and realized rates both decrease as NPL rates increase<br />
                      • The gap between modeled and realized rates widens with higher NPL rates<br />
                      • At NPL rates above 3%, the deviation becomes significant<br />
                      • Base case projections assume a 1.5% NPL rate<br />
                      • NPL rates above 5% represent severe stress scenarios
                    </Typography>
                  </Box>
                </Box>
              )}
              
              {/* Prepayment Impact Tab */}
              {tabValue === 1 && (
                <Box sx={{ p: 3 }}>
                  <Typography variant="h6" gutterBottom>
                    Class B Coupon Rate vs. Prepayment Rates
                  </Typography>
                  <Typography variant="body2" color="text.secondary" paragraph>
                    This analysis shows how early prepayment rates affect Class B coupon performance. Lower prepayment rates can impact the expected cash flow timing and reduce reinvestment opportunities.
                  </Typography>
                  
                  {testResults.sensitivityAnalysis.prepayment.length > 0 ? (
                    <Box sx={{ height: 400, mb: 4 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <LineChart
                          data={formatSensitivityData('prepayment')}
                          margin={{ top: 20, right: 30, left: 20, bottom: 10 }}
                        >
                          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.grid} />
                          <XAxis 
                            dataKey="value"
                            label={{ value: 'Prepayment Rate (%)', position: 'insideBottomRight', offset: -5, fill: theme.palette.text.secondary }}
                            tick={{ fill: theme.palette.text.secondary }}
                          />
                          <YAxis 
                            tickFormatter={(value) => `${value}%`}
                            label={{ value: 'Coupon Rate (%)', angle: -90, position: 'insideLeft', fill: theme.palette.text.secondary }}
                            tick={{ fill: theme.palette.text.secondary }}
                            domain={[0, 'dataMax + 5']}
                          />
                          <RechartsTooltip content={<CustomTooltip />} />
                          <Legend 
                            wrapperStyle={{ paddingTop: 20 }}
                            formatter={(value) => (
                              <span style={{ color: theme.palette.text.primary }}>{value}</span>
                            )}
                          />
                          <Line 
                            type="monotone" 
                            dataKey="modeled" 
                            name="Modeled Rate" 
                            stroke={theme.palette.primary.main}
                            strokeWidth={2}
                            dot={{ r: 5, fill: theme.palette.primary.main }}
                            activeDot={{ r: 7, fill: theme.palette.primary.light }}
                          />
                          <Line 
                            type="monotone" 
                            dataKey="realized" 
                            name="Realized Rate" 
                            stroke={theme.palette.secondary.main}
                            strokeWidth={2}
                            dot={{ r: 5, fill: theme.palette.secondary.main }}
                            activeDot={{ r: 7, fill: theme.palette.secondary.light }}
                          />
                        </LineChart>
                      </ResponsiveContainer>
                    </Box>
                  ) : (
                    <Box sx={{ p: 8, textAlign: 'center' }}>
                      <Typography variant="subtitle1" color="text.secondary">
                        Run a stress test to see prepayment impact analysis
                      </Typography>
                    </Box>
                  )}
                  
                  <Box sx={{ mt: 4, p: 3, borderRadius: 2, bgcolor: alpha(theme.palette.background.paper, 0.4), border: `1px solid ${alpha(theme.palette.primary.main, 0.1)}` }}>
                    <Typography variant="subtitle1" fontWeight="medium" gutterBottom>
                      Key Insights:
                    </Typography>
                    <Typography variant="body2" color="text.secondary" paragraph>
                      • Lower prepayment rates lead to lower coupon rates for Class B notes<br />
                      • At prepayment rates below 15%, the deviation between modeled and realized becomes critical<br />
                      • Base case projections assume a 30% prepayment rate<br />
                      • Prepayment rates below 10% represent severe stress scenarios<br />
                      • Higher prepayment rates generally benefit the structure in this model
                    </Typography>
                  </Box>
                </Box>
              )}
              
              {/* Combined Analysis Tab */}
              {tabValue === 2 && (
                <Box sx={{ p: 3 }}>
                  <Typography variant="h6" gutterBottom>
                    Multifactor Analysis of Rate Deviation
                  </Typography>
                  <Typography variant="body2" color="text.secondary" paragraph>
                    This combined analysis shows how NPL and prepayment rates together affect Class B coupon rate deviation. Bubble size indicates the magnitude of deviation.
                  </Typography>
                  
                  {testResults.combinedScenarios.length > 0 ? (
                    <Box sx={{ height: 500 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <ScatterChart
                          margin={{ top: 20, right: 30, left: 20, bottom: 10 }}
                        >
                          <CartesianGrid strokeDasharray="3 3" stroke={theme.palette.grid} />
                          <XAxis 
                            type="number" 
                            dataKey="x" 
                            name="NPL Rate" 
                            unit="%" 
                            domain={[0, 15]}
                            label={{ value: 'NPL Rate (%)', position: 'insideBottomRight', offset: -5, fill: theme.palette.text.secondary }}
                            tick={{ fill: theme.palette.text.secondary }}
                          />
                          <YAxis 
                            type="number" 
                            dataKey="y" 
                            name="Prepayment Rate" 
                            unit="%"
                            domain={[0, 40]}
                            label={{ value: 'Prepayment Rate (%)', angle: -90, position: 'insideLeft', fill: theme.palette.text.secondary }}
                            tick={{ fill: theme.palette.text.secondary }}
                          />
                          <ZAxis type="number" range={[60, 350]} />
                          <RechartsTooltip content={<ScatterTooltip />} />
                          <Legend 
                            wrapperStyle={{ paddingTop: 20 }}
                            formatter={(value) => (
                              <span style={{ color: theme.palette.text.primary }}>{value}</span>
                            )}
                          />
                          <Scatter 
                            name="Rate Deviation" 
                            data={formatScatterData()} 
                            fill={theme.palette.error.main}
                            fillOpacity={0.7}
                          />
                        </ScatterChart>
                      </ResponsiveContainer>
                    </Box>
                  ) : (
                    <Box sx={{ p: 8, textAlign: 'center' }}>
                      <Typography variant="subtitle1" color="text.secondary">
                        Run a stress test to see multifactor analysis
                      </Typography>
                    </Box>
                  )}
                  
                  <Box sx={{ mt: 4, p: 3, borderRadius: 2, bgcolor: alpha(theme.palette.background.paper, 0.4), border: `1px solid ${alpha(theme.palette.primary.main, 0.1)}` }}>
                    <Typography variant="subtitle1" fontWeight="medium" gutterBottom>
                      Risk Heatmap Interpretation
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      • Larger bubbles indicate greater deviation between modeled and realized coupon rates<br />
                      • The lower right quadrant (high NPL, low prepayment) represents the most severe stress conditions<br />
                      • Scenarios with high NPL rates (&gt;5%) and low prepayment rates (&lt;10%) tend to result in the largest deviations<br />
                      • Base case parameters (1.5% NPL, 30% prepayment) show moderate but acceptable deviation<br />
                      • Optimistic scenarios (1% NPL, 20% prepayment) with positive reinvestment shifts show minimal impact
                    </Typography>
                  </Box>
                </Box>
              )}
            </Paper>
          </Grid>
        </Grid>
        
        {/* Snackbar for Notifications */}
        <Snackbar
          open={snackbarOpen}
          autoHideDuration={6000}
          onClose={handleCloseSnackbar}
          anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
        >
          <Alert 
            onClose={handleCloseSnackbar} 
            severity={snackbarSeverity}
            sx={{ width: '100%' }}
            action={
              snackbarSeverity === "warning" ? (
                <Button color="inherit" size="small" onClick={handleNavigateToCalculation}>
                  Go to Structure Analysis
                </Button>
              ) : undefined
            }
          >
            {snackbarMessage}
          </Alert>
        </Snackbar>
      </Container>
    </ThemeProvider>
  );
};

export default StressTestingPage;

======================================================================

DOSYA: src\services\apiService.js
==================================================
// frontend/src/services/apiService.js
import axios from 'axios';

const API_URL =
  process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

/**
 * Ortak axios istemcisi
 */
const apiClient = axios.create({
  baseURL: API_URL,
  headers: { 'Content-Type': 'application/json' },
  // 5 dakika (300 000 ms) – optimizasyon işlemleri uzun sürebilir
  timeout: 300_000,
});

/* --------------------------------------------------------------------- */
/*                               UPLOAD                                  */
/* --------------------------------------------------------------------- */

/**
 * Excel dosyası yükle
 * @param {File} file
 * @returns {Promise<Object>}
 */
const uploadFile = async (file) => {
  const formData = new FormData();
  formData.append('file', file);

  try {
    console.log('Uploading file:', file.name);

    const response = await axios.post(
      `${API_URL}/upload-excel/`,
      formData,
      {
        headers: { 'Content-Type': 'multipart/form-data' },
      }
    );

    console.log('File upload successful');
    return response.data;
  } catch (error) {
    console.error('Error uploading file:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

/* --------------------------------------------------------------------- */
/*                             CALCULATION                               */
/* --------------------------------------------------------------------- */

/**
 * Hesaplama servisi.
 * 2. parametre olarak optimizasyon çıktısı gönderilirse
 * Class B nominali otomatik eklenir.
 *
 * @param {Object} params   – CalculationRequest gövdesi
 * @param {Object|null} optResult – OptimizationResult (opsiyonel)
 * @returns {Promise<Object>}
 */
const calculateResults = async (params, optResult = null) => {
  try {
    // İsteğe bağlı Class B nominal entegrasyonu
    const finalParams = { ...params };

    if (
      optResult &&
      optResult.class_b_nominal &&
      Number(optResult.class_b_nominal) > 0
    ) {
      finalParams.tranche_b = {
        ...(finalParams.tranche_b || {}),
        nominal: optResult.class_b_nominal,
      };
    }

    console.log('Calculating results with params:', finalParams);

    const response = await apiClient.post('/calculate/', finalParams);

    console.log('Calculation successful');
    return response.data;
  } catch (error) {
    console.error('Error calculating results:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

/* --------------------------------------------------------------------- */
/*                             OPTIMIZATION                              */
/* --------------------------------------------------------------------- */

/**
 * Yapı optimizasyonu (classic | genetic)
 *
 * @param {Object} params – OptimizationRequest gövdesi
 * @param {'classic'|'genetic'} [method='classic']
 * @returns {Promise<Object>}
 */
const optimizeStructure = async (params, method = 'classic') => {
  try {
    console.log(`Starting optimization with method: ${method}`);
    console.log(
      'Optimization params:',
      JSON.stringify(params, null, 2)
    );

    // İptal edilebilir istek oluştur
    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();

    // 5 dakikada zaman aşımı
    const timeout = setTimeout(() => {
      source.cancel(
        'Operation timeout: The optimization process took too long'
      );
    }, 300_000);

    const response = await apiClient.post(
      `/optimize/${method}/`,
      params,
      { cancelToken: source.token }
    );

    clearTimeout(timeout);

    console.log(`${method} optimization completed successfully`);
    return response.data;
  } catch (error) {
    console.error(`Error in ${method} optimization:`, error);

    if (axios.isCancel(error)) {
      console.log('Request canceled:', error.message);
      throw new Error(
        'Optimization process was canceled: ' + error.message
      );
    }

    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);

      const status = error.response.status;
      let message = 'Optimization failed';

      switch (status) {
        case 400:
          message =
            'Invalid optimization parameters: ' +
            (error.response.data.detail ||
              'Please check your parameters');
          break;
        case 500:
          message =
            'Server error during optimization. The calculation may be too complex.';
          break;
        case 504:
          message =
            'Optimization timed out. Try again with simpler parameters.';
          break;
        default:
          message =
            `Optimization error (${status}): ` +
            (error.response.data.detail || error.message);
      }

      throw new Error(message);
    }

    throw error;
  }
};

/* --------------------------------------------------------------------- */
/*                           PROGRESS POLLING                            */
/* --------------------------------------------------------------------- */

/**
 * Sunucudan optimizasyon ilerlemesini sorgula
 * @returns {Promise<Object>}
 */
const pollOptimizationProgress = async () => {
  try {
    const response = await apiClient.get('/optimize/progress/');
    return response.data;
  } catch (error) {
    console.error('Error polling optimization progress:', error);
    return {
      progress: 0,
      phase: 'Error',
      message: 'Failed to get progress information',
      error: true,
    };
  }
};

/* --------------------------------------------------------------------- */
/*                            STRESS TESTING                             */
/* --------------------------------------------------------------------- */

/**
 * Run stress test on a structure with given parameters
 * @param {Object} params - StressTestRequest body
 * @returns {Promise<Object>}
 */
const runStressTest = async (params) => {
  try {
    console.log('Running stress test with params:', params);
    
    const response = await apiClient.post('/stress-test/', params);
    
    console.log('Stress test successful');
    return response.data;
  } catch (error) {
    console.error('Error running stress test:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

/**
 * Run enhanced stress test with advanced cash flow modeling
 * @param {Object} params - EnhancedStressTestRequest body
 * @returns {Promise<Object>}
 */
const runEnhancedStressTest = async (params) => {
  try {
    console.log('Running enhanced stress test with params:', params);
    
    const response = await apiClient.post('/enhanced-stress-test/', params);
    
    console.log('Enhanced stress test successful');
    return response.data;
  } catch (error) {
    console.error('Error running enhanced stress test:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

/* --------------------------------------------------------------------- */
/*                                EXPORT                                 */
/* --------------------------------------------------------------------- */

export {
  uploadFile,
  calculateResults,
  optimizeStructure,
  pollOptimizationProgress,
  runStressTest,
  runEnhancedStressTest
};

======================================================================



BACKEND SONUÇLARI:
================

DOSYA: backend\app\main.py
==================================================
# app/main.py
import time
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from app.routers import calculation, optimization, stress_testing
import uvicorn

app = FastAPI(
    title="ABS Analysis Tool",
    description="Cash flow analysis for securitization",
    version="1.2.0"  # Updated version number to reflect changes
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify the actual frontend domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add GZip compression for faster responses
app.add_middleware(GZipMiddleware, minimum_size=1000)

# Add custom middleware for timeout and performance tracking
@app.middleware("http")
async def add_process_time_header(request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

# Include routers
app.include_router(calculation.router, prefix="/api", tags=["Calculation"])
app.include_router(optimization.router, prefix="/api", tags=["Optimization"])
app.include_router(stress_testing.router, prefix="/api", tags=["Stress Testing"])

@app.get("/")
async def root():
    return {
        "message": "ABS Analysis Tool API is running",
        "version": "1.2.0",
        "features": [
            "Calculation", 
            "Optimization", 
            "Unified Stress Testing with Advanced Cash Flow Modeling"
        ]
    }

# Configure server settings if run directly
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        timeout_keep_alive=600,  # 10 minute keep-alive timeout
        workers=1,  # Single worker is better for optimization process
    )

======================================================================

DOSYA: backend\app\models\input_models.py
==================================================
# app/models/input_models.py

from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import date


class GeneralSettings(BaseModel):
    start_date: date
    operational_expenses: float
    min_buffer: float


class TrancheA(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: float


class TrancheB(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: Optional[float] = None


class NPVSettings(BaseModel):
    method: str
    custom_rate: Optional[float] = None


class OptimizationSettings(BaseModel):
    optimization_method: str = Field(default="classic")
    selected_strategies: List[str] = Field(default=["equal", "increasing", "decreasing", "middle_weighted"])
    a_tranches_range: List[int] = Field(default=[2, 6])
    maturity_range: List[int] = Field(default=[32, 365])
    maturity_step: int = Field(default=10)
    min_class_b_percent: float = Field(default=10.0)
    target_class_b_coupon_rate: float = Field(default=30.0)
    additional_days_for_class_b: int = Field(default=10)
    class_b_percent_deviation: float = Field(default=1.0)
    selected_default_model: str = Field(default="previous")
    
    # Evolutionary algorithm parameters
    population_size: Optional[int] = Field(default=50)
    num_generations: Optional[int] = Field(default=40)


class CalculationRequest(BaseModel):
    general_settings: GeneralSettings
    tranches_a: List[TrancheA]
    tranche_b: TrancheB
    npv_settings: NPVSettings
    is_optimized: Optional[bool] = False
    optimization_method: Optional[str] = None


# Stress Testing Models
class StructureParameters(BaseModel):
    start_date: date
    a_maturities: List[int]
    a_base_rates: List[float]
    a_spreads: List[float]
    a_reinvest_rates: List[float]
    a_nominals: List[float]
    b_maturity: int
    b_base_rate: float
    b_spread: float
    b_reinvest_rate: float
    b_nominal: float
    ops_expenses: float = 0.0


class EnhancedScenarioParameters(BaseModel):
    name: str
    npl_rate: float
    prepayment_rate: float
    reinvestment_shift: float
    # Additional parameters for cash flow modeling
    recovery_rate: float = 0.50
    recovery_lag: int = 6
    delinquency_rate: Optional[float] = None  # If None, will be derived from npl_rate
    delinquency_recovery_rate: float = 0.85
    delinquency_to_default_rate: float = 0.20
    repeat_delinquency_factor: float = 1.5


class ScenarioParameters(BaseModel):
    name: str
    npl_rate: float
    prepayment_rate: float
    reinvestment_shift: float


class StressTestRequest(BaseModel):
    structure: StructureParameters
    scenario: ScenarioParameters


class EnhancedStressTestRequest(BaseModel):
    structure: StructureParameters
    scenario: EnhancedScenarioParameters

======================================================================

DOSYA: backend\app\routers\stress_testing.py
==================================================
# app/routers/stress_testing.py

from fastapi import APIRouter, HTTPException
from app.models.input_models import StressTestRequest, EnhancedStressTestRequest
# Remove import of old service and only import enhanced
from app.services.enhanced_stress_testing_service import perform_enhanced_stress_test
from app.routers.calculation import df_store
import logging
import traceback

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/stress-test/", response_model=dict)
async def stress_test(request: StressTestRequest):
    try:
        # Get the stored dataframe with better error message
        df = df_store.get("df")
        if df is None:
            raise HTTPException(
                status_code=400, 
                detail="No loan data found. Please upload an Excel file on the Structure Analysis page first."
            )
        
        # Validate dataframe has required columns
        required_columns = ['principal_amount', 'interest_amount', 'cash_flow', 'installment_date']
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            raise HTTPException(
                status_code=400,
                detail=f"Missing required columns in uploaded data: {', '.join(missing_columns)}"
            )
        
        # Basic validation of input data
        if not request.structure:
            raise HTTPException(status_code=400, detail="Structure details are missing")
            
        # Validate structure parameters
        if not request.structure.a_maturities:
            raise HTTPException(status_code=400, detail="No Class A maturities provided")
        
        # Ensure lists are of equal length
        list_lengths = [
            len(request.structure.a_maturities),
            len(request.structure.a_base_rates),
            len(request.structure.a_spreads),
            len(request.structure.a_reinvest_rates),
            len(request.structure.a_nominals)
        ]
        if len(set(list_lengths)) > 1:
            raise HTTPException(
                status_code=400, 
                detail=f"Inconsistent lengths in Class A parameters: {list_lengths}"
            )
        
        # Validate scenario parameters
        if request.scenario.npl_rate < 0 or request.scenario.npl_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"NPL rate must be between 0 and 100, got {request.scenario.npl_rate}"
            )
            
        if request.scenario.prepayment_rate < 0 or request.scenario.prepayment_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"Prepayment rate must be between 0 and 100, got {request.scenario.prepayment_rate}"
            )
        
        # Log inputs for debugging
        logger.info(f"Running stress test with scenario: {request.scenario.name}")
        logger.info(f"NPL rate: {request.scenario.npl_rate}%, Prepayment: {request.scenario.prepayment_rate}%, Reinvestment shift: {request.scenario.reinvestment_shift}%")
        
        # Convert standard request to enhanced request with default values for enhanced parameters
        enhanced_request = EnhancedStressTestRequest(
            structure=request.structure,
            scenario=dict(
                name=request.scenario.name,
                npl_rate=request.scenario.npl_rate,
                prepayment_rate=request.scenario.prepayment_rate,
                reinvestment_shift=request.scenario.reinvestment_shift,
                # Default values for enhanced parameters
                recovery_rate=0.50,
                recovery_lag=6,
                delinquency_rate=None,  # Will be derived from npl_rate
                delinquency_recovery_rate=0.85,
                delinquency_to_default_rate=0.20,
                repeat_delinquency_factor=1.5
            )
        )
        
        # Use enhanced stress test instead of the basic one
        result = perform_enhanced_stress_test(df, enhanced_request)
        
        # Log results for debugging
        logger.info(f"Stress test completed. Baseline rate: {result['baseline']['class_b_coupon_rate']}%, Stress rate: {result['stress_test']['class_b_coupon_rate']}%")
        logger.info(f"Difference: {result['difference']['class_b_coupon_rate']}%")
        
        return result
    except HTTPException:
        # Re-raise HTTP exceptions directly
        raise
    except Exception as e:
        # Capture and log the full exception details
        stack_trace = traceback.format_exc()
        error_message = str(e)
        logger.error(f"Stress testing error: {error_message}\n{stack_trace}")
        
        # Provide a meaningful error message
        if not error_message:
            error_message = "Unknown error occurred during stress testing. Check server logs for details."
            
        raise HTTPException(
            status_code=400, 
            detail=f"Stress testing error: {error_message}"
        )

@router.post("/enhanced-stress-test/", response_model=dict)
async def enhanced_stress_test(request: EnhancedStressTestRequest):
    try:
        # Get the stored dataframe with better error message
        df = df_store.get("df")
        if df is None:
            raise HTTPException(
                status_code=400, 
                detail="No loan data found. Please upload an Excel file on the Structure Analysis page first."
            )
        
        # Validate dataframe has required columns
        required_columns = ['principal_amount', 'interest_amount', 'cash_flow', 'installment_date']
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            raise HTTPException(
                status_code=400,
                detail=f"Missing required columns in uploaded data: {', '.join(missing_columns)}"
            )
        
        # Basic validation of input data
        if not request.structure:
            raise HTTPException(status_code=400, detail="Structure details are missing")
            
        # Validate structure parameters
        if not request.structure.a_maturities:
            raise HTTPException(status_code=400, detail="No Class A maturities provided")
        
        # Ensure lists are of equal length
        list_lengths = [
            len(request.structure.a_maturities),
            len(request.structure.a_base_rates),
            len(request.structure.a_spreads),
            len(request.structure.a_reinvest_rates),
            len(request.structure.a_nominals)
        ]
        if len(set(list_lengths)) > 1:
            raise HTTPException(
                status_code=400, 
                detail=f"Inconsistent lengths in Class A parameters: {list_lengths}"
            )
        
        # Validate scenario parameters
        if request.scenario.npl_rate < 0 or request.scenario.npl_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"NPL rate must be between 0 and 100, got {request.scenario.npl_rate}"
            )
            
        if request.scenario.prepayment_rate < 0 or request.scenario.prepayment_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"Prepayment rate must be between 0 and 100, got {request.scenario.prepayment_rate}"
            )
        
        if request.scenario.recovery_rate < 0 or request.scenario.recovery_rate > 1:
            raise HTTPException(
                status_code=400,
                detail=f"Recovery rate must be between 0 and 1, got {request.scenario.recovery_rate}"
            )
        
        # Log inputs for debugging
        logger.info(f"Running enhanced stress test with scenario: {request.scenario.name}")
        logger.info(f"NPL rate: {request.scenario.npl_rate}%, Prepayment: {request.scenario.prepayment_rate}%, " + 
                    f"Recovery: {request.scenario.recovery_rate * 100}%")
        
        # Perform the enhanced stress test
        result = perform_enhanced_stress_test(df, request)
        
        # Log results for debugging
        logger.info(f"Enhanced stress test completed. Baseline rate: {result['baseline']['class_b_coupon_rate']}%, " + 
                    f"Stress rate: {result['stress_test']['class_b_coupon_rate']}%")
        logger.info(f"Difference: {result['difference']['class_b_coupon_rate']}%")
        
        return result
    except HTTPException:
        # Re-raise HTTP exceptions directly
        raise
    except Exception as e:
        # Capture and log the full exception details
        stack_trace = traceback.format_exc()
        error_message = str(e)
        logger.error(f"Enhanced stress testing error: {error_message}\n{stack_trace}")
        
        # Provide a meaningful error message
        if not error_message:
            error_message = "Unknown error occurred during enhanced stress testing. Check server logs for details."
            
        raise HTTPException(
            status_code=400, 
            detail=f"Enhanced stress testing error: {error_message}"
        )

======================================================================

DOSYA: backend\app\services\enhanced_stress_testing_service.py
==================================================
# app/services/enhanced_stress_testing_service.py

import pandas as pd
import numpy as np
from datetime import date, datetime
import logging
import traceback
from typing import Dict, Any, List, Union

# Import the necessary modules
from app.models.input_models import EnhancedStressTestRequest
from app.utils.tranche_utils import calculate_tranche_results

logger = logging.getLogger(__name__)

class CashFlowScenarioProcessor:
    """
    Handles cash flow scenario analysis including:
      - Prepayment
      - Delinquency
      - Default (with partial recovery)
    """

    @staticmethod
    def cpr_to_smm(cpr):
        """Convert annual CPR to a daily SMM (Simple Monthly Mortality)."""
        return 1 - (1 - float(cpr)) ** (1 / 365)

    @staticmethod
    def cdr_to_mdr(cdr):
        """Convert annual rates (CDR/Delinquency) to a daily rate."""
        return 1 - (1 - float(cdr)) ** (1 / 365)

    @staticmethod
    def ensure_timestamp(date_input: Union[str, date, datetime, pd.Timestamp]) -> pd.Timestamp:
        """
        Convert any date format to pandas Timestamp
        """
        if isinstance(date_input, pd.Timestamp):
            return date_input
        
        if isinstance(date_input, (date, datetime)):
            return pd.Timestamp(date_input)
        
        if isinstance(date_input, str):
            try:
                return pd.Timestamp(date_input)
            except Exception as e:
                logger.error(f"Could not convert date format: {date_input}, error: {str(e)}")
                # Return today's date as default
                return pd.Timestamp('today')
        
        # For other types of values
        logger.warning(f"Unexpected date format: {type(date_input)}, value: {date_input}")
        return pd.Timestamp('today')

    @staticmethod
    def prepare_cash_flow_dataframe(df: pd.DataFrame) -> pd.DataFrame:
        """
        Prepare the cash flow DataFrame for scenario analysis
        """
        try:
            # Verify required columns exist
            required_columns = ['installment_date', 'principal_amount', 'interest_amount', 'cash_flow']
            for col in required_columns:
                if col not in df.columns:
                    logger.error(f"Missing column: '{col}'")
                    raise ValueError(f"Column '{col}' not found in data")
            
            # Create a copy of the DataFrame
            cf_df = df.copy()
            
            # Rename columns to match expected format
            cf_df = cf_df.rename(columns={
                'installment_date': 'payment_date',
                'installment_amount': 'payment_amount'
            })
            
            # Ensure payment_date is datetime
            if not pd.api.types.is_datetime64_any_dtype(cf_df['payment_date']):
                cf_df['payment_date'] = pd.to_datetime(cf_df['payment_date'], errors='coerce')
            
            # Calculate beginning balance
            cf_df["beginning_balance"] = 0.0
            total_principal = cf_df["principal_amount"].sum()
            current_balance = total_principal
            
            for i in range(len(cf_df)):
                cf_df.loc[i, "beginning_balance"] = current_balance
                current_balance -= cf_df.loc[i, "principal_amount"]
                if current_balance < 0:
                    current_balance = 0
            
            # Convert to float for numeric operations
            cf_df["beginning_balance"] = cf_df["beginning_balance"].astype(float)
            cf_df["principal_amount"] = cf_df["principal_amount"].astype(float)
            cf_df["interest_amount"] = cf_df["interest_amount"].astype(float)
            
            # Sort by payment date
            cf_df = cf_df.sort_values('payment_date')
            
            return cf_df
            
        except Exception as e:
            logger.exception(f"Error preparing cash flow DataFrame: {e}")
            raise ValueError(f"Error processing cash flow data: {e}")

    @staticmethod
    def apply_scenario_assumptions(
        cf_df,
        sm,  # Daily prepayment rate
        dr,  # Daily default rate
        dr_delinq,  # Daily delinquency rate
        recovery_rate,
        recovery_lag,
        delinquency_recovery_rate,
        delinquency_to_default_rate,
        repeat_delinquency_factor,
    ):
        """
        Applies prepayment, delinquency, and default assumptions.
        Returns a DataFrame with modeled cash flows.
        """
        df = cf_df.copy().reset_index(drop=True)

        # Initialize new columns
        df["actual_balance"] = 0.0
        df["actual_principal"] = 0.0
        df["actual_interest"] = 0.0
        df["prepayment"] = 0.0
        df["default"] = 0.0
        df["delinquency"] = 0.0
        df["default_recovery"] = 0.0
        df["delinquency_recovery"] = 0.0
        df["loss"] = 0.0
        df["prepayment_interest_loss"] = 0.0
        df["net_modeled_cashflow"] = 0.0

        current_balance = df.loc[0, "beginning_balance"]

        ab_list = []  # actual_balance
        ap_list = []  # actual_principal
        ai_list = []  # actual_interest
        pp_list = []  # prepayment
        def_list = []  # default
        del_list = []  # delinquency
        def_rec_list = []  # default_recovery
        del_rec_list = []  # delinquency_recovery
        loss_list = []  # loss
        pp_loss_list = []  # prepayment_interest_loss
        net_cf_list = []  # net_modeled_cashflow

        # Track default amounts for recovery
        defaults_for_recovery = []
        # Track delinquent amounts for recovery
        delinquencies_for_recovery = []

        # Track outstanding defaults and delinquencies
        outstanding_defaults = 0.0
        outstanding_delinquencies = 0.0

        for i, row in df.iterrows():
            scheduled_principal = row["principal_amount"]
            scheduled_interest = row["interest_amount"]
            scheduled_balance = row["beginning_balance"]

            # Scale down based on current balance vs. scheduled
            scaling_factor = current_balance / scheduled_balance if scheduled_balance > 0 else 0
            principal_adj = scheduled_principal * scaling_factor
            interest_adj = scheduled_interest * scaling_factor

            # After scheduled principal
            remaining_balance = current_balance - principal_adj

            # Prepayment
            prepayment_amt = remaining_balance * sm
            remaining_after_prepay = remaining_balance - prepayment_amt

            # Delinquency
            delinquency_amt = remaining_after_prepay * dr_delinq

            # Repeated delinquency logic
            if i > 0 and df.loc[i - 1, "delinquency"] > 0:
                prev_del = df.loc[i - 1, "delinquency"]
                repeat_factor = min(prev_del / current_balance, 0.5) if current_balance > 0 else 0
                additional_del = repeat_factor * remaining_after_prepay * (repeat_delinquency_factor - 1) * dr_delinq
                delinquency_amt += additional_del

            remaining_after_del = remaining_after_prepay - delinquency_amt

            # Some portion of delinquency goes to default
            delinquency_to_default_amt = delinquency_amt * delinquency_to_default_rate
            delinquency_amt -= delinquency_to_default_amt

            # Default
            default_amt = remaining_after_del * dr + delinquency_to_default_amt
            loss_amt = default_amt * (1 - recovery_rate)

            # Default recovery from earlier periods
            default_recovery_amt = 0.0
            if i >= recovery_lag and len(defaults_for_recovery) > recovery_lag:
                default_recovery_amt = defaults_for_recovery[i - recovery_lag] * recovery_rate

            # Delinquency recovery from earlier periods
            delinquency_recovery_amt = 0.0
            if i >= recovery_lag and len(delinquencies_for_recovery) > recovery_lag:
                delinquency_recovery_amt = delinquencies_for_recovery[i - recovery_lag] * delinquency_recovery_rate

            # Delinquency interest +50% on that portion
            if (principal_adj + interest_adj) > 0:
                delinquency_ratio = delinquency_amt / (principal_adj + interest_adj) if (principal_adj + interest_adj) > 0 else 0
                actual_interest = interest_adj + (interest_adj * 0.5 * delinquency_ratio)
            else:
                actual_interest = interest_adj

            # Prepayment interest loss
            if (principal_adj + prepayment_amt) > 0:
                fraction_prepay = prepayment_amt / (principal_adj + prepayment_amt)
            else:
                fraction_prepay = 0.0
            prepay_int_loss = scheduled_interest * scaling_factor * fraction_prepay

            # Actual principal paid
            actual_principal = principal_adj + prepayment_amt

            # Update outstanding defaults/delinquencies
            outstanding_defaults += default_amt
            outstanding_defaults -= default_recovery_amt
            if outstanding_defaults < 0:
                outstanding_defaults = 0

            outstanding_delinquencies += delinquency_amt
            outstanding_delinquencies -= delinquency_recovery_amt
            if outstanding_delinquencies < 0:
                outstanding_delinquencies = 0

            ab_list.append(current_balance)
            ap_list.append(actual_principal)
            ai_list.append(actual_interest)
            pp_list.append(prepayment_amt)
            def_list.append(default_amt)
            del_list.append(delinquency_amt)
            def_rec_list.append(default_recovery_amt)
            del_rec_list.append(delinquency_recovery_amt)
            loss_list.append(loss_amt)
            pp_loss_list.append(prepay_int_loss)

            defaults_for_recovery.append(default_amt)
            delinquencies_for_recovery.append(delinquency_amt)

            # Update balance
            current_balance = current_balance - actual_principal - default_amt - delinquency_amt
            if current_balance < 0:
                current_balance = 0

            # Net cash flow
            net_cf = actual_principal + actual_interest + default_recovery_amt + delinquency_recovery_amt
            net_cf_list.append(net_cf)

        df["actual_balance"] = ab_list
        df["actual_principal"] = ap_list
        df["actual_interest"] = ai_list
        df["prepayment"] = pp_list
        df["default"] = def_list
        df["delinquency"] = del_list
        df["default_recovery"] = def_rec_list
        df["delinquency_recovery"] = del_rec_list
        df["loss"] = loss_list
        df["prepayment_interest_loss"] = pp_loss_list
        df["net_modeled_cashflow"] = net_cf_list

        # Derived columns
        df["actual_cashflow"] = (
            df["actual_principal"] + df["actual_interest"] + df["default_recovery"] + df["delinquency_recovery"]
        )
        df["cumulative_actual_cashflow"] = df["actual_cashflow"].cumsum()
        df["cumulative_prepayment"] = df["prepayment"].cumsum()
        df["cumulative_default"] = df["default"].cumsum()
        df["cumulative_delinquency"] = df["delinquency"].cumsum()
        df["cumulative_loss"] = df["loss"].cumsum()
        df["cumulative_default_recovery"] = df["default_recovery"].cumsum()
        df["cumulative_delinquency_recovery"] = df["delinquency_recovery"].cumsum()

        return df

def normalize_coupon_rates(baseline_rate, stress_rate):
    """
    Normalizes coupon rates to reasonable values while maintaining their relative relationship.
    This is used when cash flow modeling results in unrealistically high coupon rates.
    
    Args:
        baseline_rate: The original baseline coupon rate
        stress_rate: The original stress test coupon rate
        
    Returns:
        Tuple of (normalized_baseline_rate, normalized_stress_rate)
    """
    # Define reasonable coupon rate ranges
    MAX_REASONABLE_RATE = 50.0  # Maximum reasonable coupon rate
    TARGET_AVERAGE_RATE = 30.0  # Target for average coupon rate
    
    # Check if rates are within reasonable range
    if baseline_rate <= MAX_REASONABLE_RATE and stress_rate <= MAX_REASONABLE_RATE:
        return baseline_rate, stress_rate
    
    # Calculate average of the rates
    avg_rate = (baseline_rate + stress_rate) / 2
    
    # Calculate difference between rates (preserves the impact direction)
    rate_diff = stress_rate - baseline_rate
    
    # When rates are very high, we need to reduce the scale but preserve the relative difference
    if avg_rate > MAX_REASONABLE_RATE:
        # Calculate scaling factor to bring average to target
        scaling_factor = TARGET_AVERAGE_RATE / avg_rate
        
        # Apply scaling to maintain the relative relationship
        norm_baseline = baseline_rate * scaling_factor
        norm_stress = stress_rate * scaling_factor
        
        # Ensure we preserve the sign of the difference
        if (norm_stress - norm_baseline) * rate_diff < 0:
            # If scaling reversed the relationship, use a different approach
            norm_baseline = TARGET_AVERAGE_RATE - (rate_diff / 2)
            norm_stress = TARGET_AVERAGE_RATE + (rate_diff / 2)
            
            # Apply bounds
            norm_baseline = max(1.0, min(MAX_REASONABLE_RATE, norm_baseline))
            norm_stress = max(1.0, min(MAX_REASONABLE_RATE, norm_stress))
        
        logger.warning(f"Normalized rates from {baseline_rate:.2f}%/{stress_rate:.2f}% to {norm_baseline:.2f}%/{norm_stress:.2f}%")
        return norm_baseline, norm_stress
    
    # This shouldn't be reached but return original values as fallback
    return baseline_rate, stress_rate

def perform_enhanced_stress_test(df: pd.DataFrame, request: EnhancedStressTestRequest) -> Dict[str, Any]:
    """
    Performs enhanced stress test that combines cash flow modeling with ABS structure analysis
    
    Args:
        df: Cash flow DataFrame
        request: Enhanced stress test request with structure and scenario parameters
        
    Returns:
        Dict[str, Any]: Enhanced stress test results
    """
    try:
        logger.info("Starting enhanced stress test calculation")
        
        # Extract base parameters
        structure = request.structure
        scenario = request.scenario
        
        # Extract scenario parameters with defaults
        npl_rate = scenario.npl_rate
        prepayment_rate = scenario.prepayment_rate
        reinvestment_shift = scenario.reinvestment_shift
        recovery_rate = scenario.recovery_rate
        recovery_lag = scenario.recovery_lag
        delinquency_rate = scenario.delinquency_rate if scenario.delinquency_rate is not None else npl_rate / 2
        delinquency_recovery_rate = scenario.delinquency_recovery_rate
        delinquency_to_default_rate = scenario.delinquency_to_default_rate
        repeat_delinquency_factor = scenario.repeat_delinquency_factor
        
        # Log parameters
        logger.info(f"Scenario: {scenario.name}")
        logger.info(f"NPL Rate: {npl_rate}%, Prepayment: {prepayment_rate}%, Reinvestment Shift: {reinvestment_shift}%")
        logger.info(f"Recovery Rate: {recovery_rate}, Recovery Lag: {recovery_lag} days")
        logger.info(f"Delinquency Rate: {delinquency_rate}%, Delinquency Recovery Rate: {delinquency_recovery_rate}")
        
        # Convert start_date to pandas Timestamp
        start_date = CashFlowScenarioProcessor.ensure_timestamp(structure.start_date)
        logger.info(f"Start date: {start_date}")
        
        # Data validation
        if df is None or df.empty:
            raise ValueError("No valid cash flow data found for analysis")
        
        # Check for required columns
        required_columns = ['principal_amount', 'interest_amount', 'cash_flow', 'installment_date']
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            raise ValueError(f"Missing columns in cash flow data: {', '.join(missing_columns)}")
        
        # Save original structure parameters to calculate original rates later if needed
        original_a_nominals = structure.a_nominals.copy()
        original_b_nominal = structure.b_nominal
        
        # First calculate baseline results with original cash flows
        logger.info("Calculating baseline results")
        try:
            baseline_result = calculate_tranche_results(
                df, start_date,
                structure.a_maturities, structure.a_base_rates, structure.a_spreads, structure.a_reinvest_rates,
                structure.a_nominals, structure.b_maturity, structure.b_base_rate, structure.b_spread,
                structure.b_reinvest_rate, structure.b_nominal, structure.ops_expenses
            )
        except Exception as e:
            logger.error(f"Error calculating baseline: {str(e)}")
            logger.debug(traceback.format_exc())
            raise ValueError(f"Error calculating baseline scenario: {str(e)}")
        
        # Prepare cash flow DataFrame for scenario analysis
        cf_df = CashFlowScenarioProcessor.prepare_cash_flow_dataframe(df)
        
        # Convert annual rates to daily rates
        daily_prepay_rate = CashFlowScenarioProcessor.cpr_to_smm(prepayment_rate / 100)
        daily_default_rate = CashFlowScenarioProcessor.cdr_to_mdr(npl_rate / 100)
        daily_delinquency_rate = CashFlowScenarioProcessor.cdr_to_mdr(delinquency_rate / 100)
        
        # Apply scenario assumptions to get modeled cash flows
        logger.info("Applying cash flow scenario modeling")
        try:
            modeled_df = CashFlowScenarioProcessor.apply_scenario_assumptions(
                cf_df,
                daily_prepay_rate,
                daily_default_rate,
                daily_delinquency_rate,
                recovery_rate,
                recovery_lag,
                delinquency_recovery_rate,
                delinquency_to_default_rate,
                repeat_delinquency_factor
            )
        except Exception as e:
            logger.error(f"Error in cash flow modeling: {str(e)}")
            logger.debug(traceback.format_exc())
            raise ValueError(f"Error during cash flow scenario modeling: {str(e)}")
        
        # Convert modeled cash flows back to original format for structure analysis
        stress_df = df.copy()
        stress_df["principal_amount"] = modeled_df["actual_principal"]
        stress_df["interest_amount"] = modeled_df["actual_interest"]
        stress_df["cash_flow"] = modeled_df["actual_cashflow"]
        
        # Apply reinvestment rate shift if specified
        a_reinvest_rates = list(structure.a_reinvest_rates)
        b_reinvest_rate = structure.b_reinvest_rate
        
        if reinvestment_shift != 0:
            logger.info(f"Applying {reinvestment_shift}% shift to reinvestment rates")
            a_reinvest_rates = [rate + reinvestment_shift for rate in structure.a_reinvest_rates]
            b_reinvest_rate = structure.b_reinvest_rate + reinvestment_shift
        
        # Calculate stress test results with modeled cash flows
        logger.info("Calculating stress test results using modeled cash flows")
        try:
            stress_result = calculate_tranche_results(
                stress_df, start_date,
                structure.a_maturities, structure.a_base_rates, structure.a_spreads, a_reinvest_rates,
                structure.a_nominals, structure.b_maturity, structure.b_base_rate, structure.b_spread,
                b_reinvest_rate, structure.b_nominal, structure.ops_expenses
            )
        except Exception as e:
            logger.error(f"Error calculating stress scenario: {str(e)}")
            logger.debug(traceback.format_exc())
            raise ValueError(f"Error calculating stress scenario: {str(e)}")
        
        # Calculate summary metrics
        total_original_principal = df["principal_amount"].sum()
        total_modeled_principal = modeled_df["actual_principal"].sum()
        total_default = modeled_df["default"].sum()
        total_default_pct = (total_default / total_original_principal) * 100 if total_original_principal > 0 else 0
        total_loss = modeled_df["loss"].sum()
        total_loss_pct = (total_loss / total_original_principal) * 100 if total_original_principal > 0 else 0
        total_delinquency = modeled_df["delinquency"].sum()
        total_delinquency_pct = (total_delinquency / total_original_principal) * 100 if total_original_principal > 0 else 0
        total_cf_reduction = ((df["cash_flow"].sum() - modeled_df["actual_cashflow"].sum()) / df["cash_flow"].sum()) * 100 if df["cash_flow"].sum() > 0 else 0
        
        # Extract key result values
        baseline_coupon_rate = baseline_result.get('effective_coupon_rate', 0)
        stress_coupon_rate = stress_result.get('effective_coupon_rate', 0)
        baseline_buffer = baseline_result.get('min_buffer_actual', 0)
        stress_buffer = stress_result.get('min_buffer_actual', 0)
        baseline_coupon = baseline_result.get('class_b_coupon', 0)
        stress_coupon = stress_result.get('class_b_coupon', 0)
        
        # Get direct coupon rates (not annualized)
        baseline_direct_rate = baseline_result.get('direct_coupon_rate', 0)
        stress_direct_rate = stress_result.get('direct_coupon_rate', 0)
        
        # If rates are unreasonably high, try to normalize them
        original_baseline_rate = baseline_coupon_rate
        original_stress_rate = stress_coupon_rate
        
        # Check if the rates are unreasonably high (both over 100% suggests modeling issue)
        if baseline_coupon_rate > 100 and stress_coupon_rate > 100:
            logger.warning(f"Very high coupon rates detected: Baseline={baseline_coupon_rate}%, Stress={stress_coupon_rate}%")
            
            # Fall back to original structure calculation with modified cash flows
            try:
                logger.info("Trying alternative calculation method for more reasonable rates")
                
                # Calculate original coupon rate first
                original_result = calculate_tranche_results(
                    df, start_date,
                    structure.a_maturities, structure.a_base_rates, structure.a_spreads, structure.a_reinvest_rates,
                    original_a_nominals, structure.b_maturity, structure.b_base_rate, structure.b_spread,
                    structure.b_reinvest_rate, original_b_nominal, structure.ops_expenses
                )
                
                original_coupon_rate = original_result.get('effective_coupon_rate', 0)
                
                # Estimate impact factor from cash flow reduction
                principal_reduction_factor = max(0.01, total_modeled_principal / total_original_principal)
                impact_factor = 1 - ((1 - principal_reduction_factor) * 0.7) # 70% impact from principal reduction
                
                # Apply impact to original rate
                baseline_coupon_rate = original_coupon_rate
                stress_coupon_rate = original_coupon_rate * impact_factor
                
                logger.info(f"Using estimated rates: Original={original_coupon_rate}%, Baseline={baseline_coupon_rate}%, Stress={stress_coupon_rate}%")
            except Exception as e:
                logger.warning(f"Alternative calculation failed: {str(e)}. Using normalization instead.")
                # If that fails, normalize the rates
                baseline_coupon_rate, stress_coupon_rate = normalize_coupon_rates(baseline_coupon_rate, stress_coupon_rate)
        
        # Calculate difference after normalization
        coupon_rate_diff = stress_coupon_rate - baseline_coupon_rate
        
        # Create response object
        response = {
            'baseline': {
                'class_b_coupon_rate': round(baseline_coupon_rate, 4),
                'min_buffer_actual': round(baseline_buffer, 4),
                'class_b_coupon': round(baseline_coupon, 4),
                'original_rate': round(original_baseline_rate, 4) if original_baseline_rate != baseline_coupon_rate else None
            },
            'stress_test': {
                'class_b_coupon_rate': round(stress_coupon_rate, 4),
                'min_buffer_actual': round(stress_buffer, 4),
                'class_b_coupon': round(stress_coupon, 4),
                'npl_rate': npl_rate,
                'prepayment_rate': prepayment_rate,
                'reinvestment_shift': reinvestment_shift,
                'original_rate': round(original_stress_rate, 4) if original_stress_rate != stress_coupon_rate else None,
                # Cash flow model metrics
                'recovery_rate': recovery_rate,
                'delinquency_rate': delinquency_rate,
                'total_default_pct': round(total_default_pct, 2),
                'total_loss_pct': round(total_loss_pct, 2),
                'total_delinquency_pct': round(total_delinquency_pct, 2),
                'total_cashflow_reduction_pct': round(total_cf_reduction, 2),
                'principal_reduction_pct': round((1 - total_modeled_principal / total_original_principal) * 100 if total_original_principal > 0 else 0, 2)
            },
            'difference': {
                'class_b_coupon_rate': round(coupon_rate_diff, 4),
                'min_buffer_actual': round(stress_buffer - baseline_buffer, 4),
                'class_b_coupon': round(stress_coupon - baseline_coupon, 4)
            },
            'cash_flow_model': {
                'total_original_principal': round(total_original_principal, 2),
                'total_modeled_principal': round(total_modeled_principal, 2),
                'total_default': round(total_default, 2),
                'total_delinquency': round(total_delinquency, 2),
                'total_loss': round(total_loss, 2),
                'total_recovery': round(modeled_df["default_recovery"].sum() + modeled_df["delinquency_recovery"].sum(), 2)
            }
        }
        
        # Log results
        logger.info("Enhanced stress test completed successfully")
        logger.info(f"Baseline rate: {response['baseline']['class_b_coupon_rate']}%, " +
                   f"Stress rate: {response['stress_test']['class_b_coupon_rate']}%")
        logger.info(f"Difference: {response['difference']['class_b_coupon_rate']}%")
        logger.info(f"Total loss: {total_loss_pct}% of principal, Cash flow reduction: {total_cf_reduction}%")
        
        return response
        
    except Exception as e:
        # Log detailed error
        logger.error(f"Unexpected error during enhanced stress test: {str(e)}")
        logger.debug(traceback.format_exc())
        raise ValueError(f"Enhanced stress test calculation failed: {str(e)}")

======================================================================

