BACKEND KLASÃ–R YAPISI:
=====================

ðŸ“¦backend
  â”£ ðŸ“œDockerfile
  â”£ ðŸ“œrequirements.txt
  â”£ ðŸ“‚app
    â”£ ðŸ“œmain.py
    â”£ ðŸ“œ__init__.py
    â”£ ðŸ“‚models
      â”£ ðŸ“œinput_models.py
      â”£ ðŸ“œoutput_models.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚routers
      â”£ ðŸ“œcalculation.py
      â”£ ðŸ“œoptimization.py
      â”£ ðŸ“œstress_testing.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚services
      â”£ ðŸ“œcalculation_service.py
      â”£ ðŸ“œoptimization_service.py
      â”£ ðŸ“œstress_testing_service.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚utils
      â”£ ðŸ“œcash_flow_utils.py
      â”£ ðŸ“œfinance_utils.py
      â”£ ðŸ“œtranche_utils.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚__pycache__


BACKEND DOSYALARI VE Ä°Ã‡ERÄ°KLERÄ°:
==============================

DOSYA: backend\Dockerfile
==================================================
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

======================================================================

DOSYA: backend\requirements.txt
==================================================
# backend/requirements.txt
fastapi==0.104.1
uvicorn==0.23.2
pydantic==2.4.2
pandas==2.1.1
numpy==1.26.0
python-multipart==0.0.6
openpyxl==3.1.2
python-dateutil==2.8.2
scikit-optimize==0.9.0

======================================================================

DOSYA: backend\app\main.py
==================================================
import time
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from app.routers import calculation, optimization, stress_testing
import uvicorn

app = FastAPI(
    title="ABS Analysis Tool",
    description="Cash flow analysis for securitization",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify the actual frontend domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add GZip compression for faster responses
app.add_middleware(GZipMiddleware, minimum_size=1000)

# Add custom middleware for timeout and performance tracking
@app.middleware("http")
async def add_process_time_header(request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

# Include routers
app.include_router(calculation.router, prefix="/api", tags=["Calculation"])
app.include_router(optimization.router, prefix="/api", tags=["Optimization"])
app.include_router(stress_testing.router, prefix="/api", tags=["Stress Testing"])

@app.get("/")
async def root():
    return {"message": "ABS Analysis Tool API is running"}

# Configure server settings if run directly
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        timeout_keep_alive=600,  # 10 dakika keep-alive timeout
        workers=1,  # Optimization iÅŸlemi iÃ§in tek bir iÅŸÃ§i daha iyi olabilir
    )

======================================================================

DOSYA: backend\app\__init__.py
==================================================


======================================================================

DOSYA: backend\app\models\input_models.py
==================================================
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import date


class GeneralSettings(BaseModel):
    start_date: date
    operational_expenses: float
    min_buffer: float


class TrancheA(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: float


class TrancheB(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: Optional[float] = None  # Added Optional nominal field


class NPVSettings(BaseModel):
    method: str  # "weighted_avg_rate" or "custom_rate"
    custom_rate: Optional[float] = None


class OptimizationSettings(BaseModel):
    optimization_method: str = Field(default="classic")
    selected_strategies: List[str] = Field(default=["equal", "increasing", "decreasing", "middle_weighted"])
    a_tranches_range: List[int] = Field(default=[2, 6])
    maturity_range: List[int] = Field(default=[32, 365])
    maturity_step: int = Field(default=10)
    min_class_b_percent: float = Field(default=10.0)
    target_class_b_coupon_rate: float = Field(default=30.0)
    additional_days_for_class_b: int = Field(default=10)
    class_b_percent_deviation: float = Field(default=1.0)  # New field with tighter default value
    selected_default_model: str = Field(default="previous")  # Added field for default model selection
    
    # Evolutionary algorithm parameters
    population_size: Optional[int] = Field(default=50)
    num_generations: Optional[int] = Field(default=40)


class CalculationRequest(BaseModel):
    general_settings: GeneralSettings
    tranches_a: List[TrancheA]
    tranche_b: TrancheB
    npv_settings: NPVSettings
    is_optimized: Optional[bool] = False
    optimization_method: Optional[str] = None


# Stress Testing Models
class StructureParameters(BaseModel):
    start_date: date
    a_maturities: List[int]
    a_base_rates: List[float]
    a_spreads: List[float]
    a_reinvest_rates: List[float]
    a_nominals: List[float]
    b_maturity: int
    b_base_rate: float
    b_spread: float
    b_reinvest_rate: float
    b_nominal: float
    ops_expenses: float = 0.0


class ScenarioParameters(BaseModel):
    name: str
    npl_rate: float
    prepayment_rate: float
    reinvestment_shift: float


class StressTestRequest(BaseModel):
    structure: StructureParameters
    scenario: ScenarioParameters

======================================================================

DOSYA: backend\app\models\output_models.py
==================================================
# backend/app/models/output_models.py
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

class CashFlowSummary(BaseModel):
    total_records: int
    total_principal: float
    total_interest: float
    total_cash_flow: float
    date_range: List[str]
    
class CalculationResult(BaseModel):
    class_a_total: float
    class_b_total: float
    class_a_principal: float
    class_b_principal: float
    class_a_interest: float
    class_b_coupon: float
    min_buffer_actual: float
    total_principal_paid: float
    total_loan_principal: float
    financing_cost: float
    tranche_results: List[Dict[str, Any]]
    interest_rate_conversions: List[Dict[str, Any]]
    
class OptimizationResult(BaseModel):
    best_strategy: str
    class_a_maturities: List[int]
    class_a_nominals: List[float]
    class_a_rates: List[float]
    class_a_reinvest: List[float]
    class_b_maturity: int
    class_b_rate: float
    class_b_reinvest: float
    class_b_nominal: float
    class_b_coupon_rate: float
    direct_class_b_coupon_rate: float = 0.0  # Add this new field with default value
    min_buffer_actual: float
    last_cash_flow_day: int
    additional_days: int
    results_by_strategy: Dict[str, Dict[str, Any]]
    class_b_percent: Optional[float] = None  # Optional field for Class B percentage

======================================================================

DOSYA: backend\app\routers\calculation.py
==================================================
# backend/app/routers/calculation.py
from fastapi import APIRouter, UploadFile, File, HTTPException
from app.models.input_models import CalculationRequest
from app.models.output_models import CalculationResult, CashFlowSummary
from app.services.calculation_service import perform_calculation, load_excel_data
import pandas as pd
from typing import Dict, Any
import io

router = APIRouter()

# Global variable to store the dataframe after upload
# In a production app, you would use a database or Redis cache instead
df_store = {"df": None}

@router.post("/upload-excel/", response_model=CashFlowSummary)
async def upload_excel(file: UploadFile = File(...)):
    try:
        contents = await file.read()
        df = load_excel_data(contents)
        
        # Store the dataframe in memory for later use
        df_store["df"] = df
        
        # Return summary data
        return CashFlowSummary(
            total_records=len(df),
            total_principal=float(df['principal_amount'].sum()),
            total_interest=float(df['interest_amount'].sum()),
            total_cash_flow=float(df['cash_flow'].sum()),
            date_range=[df['installment_date'].min().strftime('%d/%m/%Y'), 
                      df['installment_date'].max().strftime('%d/%m/%Y')]
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Could not process file: {str(e)}")

@router.post("/calculate/", response_model=CalculationResult)
async def calculate(request: CalculationRequest):
    try:
        # Get the stored dataframe
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Perform the calculation
        result = perform_calculation(df, request)
        return result
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Calculation error: {str(e)}")

======================================================================

DOSYA: backend\app\routers\optimization.py
==================================================
import time
import traceback
import logging
import asyncio
from fastapi.responses import JSONResponse
from fastapi import APIRouter, HTTPException, Path
from app.models.input_models import OptimizationSettings, GeneralSettings
from app.models.output_models import OptimizationResult

# Import the optimization_progress object and all optimization functions
from app.services.optimization_service import (
    optimization_progress,  # Import the progress tracker
    perform_optimization, 
    perform_genetic_optimization
)
from app.routers.calculation import df_store  # Import the shared dataframe store

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

@router.post("/optimize/classic/", response_model=OptimizationResult)
async def optimize_classic(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    try:
        # Reset progress tracker
        optimization_progress.reset()
        
        # Get the stored dataframe
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Log the request including the selected default model
        logger.info(f"Starting classic optimization with parameters: {optimization_settings}")
        logger.info(f"Using default model: {optimization_settings.selected_default_model}")
        
        # Perform the optimization with classic method in a separate thread
        # to not block the event loop and allow progress updates
        def run_optimization():
            return perform_optimization(df, general_settings, optimization_settings)
        
        # Run the CPU-bound optimization task in a thread pool
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(None, run_optimization)
        
        # Log success
        logger.info("Classic optimization completed successfully")
        
        # Ensure progress is set to 100% when complete
        optimization_progress.update(
            step=100,
            phase="Complete",
            message="Optimization completed successfully"
        )
        
        return result
    except Exception as e:
        # Log the error
        logger.error(f"Classic optimization error: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Update progress tracker in case of error (don't reset)
        optimization_progress.update(
            phase="Error",
            message=f"Classic optimization error: {str(e)}",
            step=100
        )
        
        raise HTTPException(status_code=500, detail=f"Classic optimization error: {str(e)}")

@router.post("/optimize/genetic/", response_model=OptimizationResult)
async def optimize_genetic(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    try:
        # Reset progress tracker
        optimization_progress.reset()
        
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Log the request including the selected default model
        logger.info(f"Starting genetic optimization with parameters: {optimization_settings}")
        logger.info(f"Using default model: {optimization_settings.selected_default_model}")
        
        # Perform the optimization in a separate thread
        def run_optimization():
            return perform_genetic_optimization(df, general_settings, optimization_settings)
        
        # Run the CPU-bound optimization task in a thread pool
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(None, run_optimization)
        
        # Log success
        logger.info("Genetic optimization completed successfully")
        
        # Ensure progress is set to 100% when complete
        optimization_progress.update(
            step=100,
            phase="Complete",
            message="Optimization completed successfully"
        )
        
        return result
    except Exception as e:
        # Log the error
        logger.error(f"Genetic optimization error: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Update progress tracker in case of error (don't reset)
        optimization_progress.update(
            phase="Error",
            message=f"Genetic optimization error: {str(e)}",
            step=100
        )
        
        raise HTTPException(status_code=500, detail=f"Genetic optimization error: {str(e)}")

# Backward compatibility main endpoint - updated to only support classic and genetic
@router.post("/optimize/", response_model=OptimizationResult)
async def optimize(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    method = getattr(optimization_settings, "optimization_method", "classic")
    logger.info(f"Optimizing with method: {method}")
    logger.info(f"Using default model: {optimization_settings.selected_default_model}")
    
    # Reset progress before starting
    optimization_progress.reset()
    
    # Add timeout handling
    try:
        # SÄ±nÄ±rlÄ± kombinasyon sayÄ±sÄ± ve iterasyon
        if hasattr(optimization_settings, "maturity_range") and len(optimization_settings.maturity_range) == 2:
            # Ä°ÅŸlem sÃ¼resini azaltmak iÃ§in parametreleri sÄ±nÄ±rla
            range_diff = optimization_settings.maturity_range[1] - optimization_settings.maturity_range[0]
            if range_diff > 200 and optimization_settings.maturity_step < 15:
                logger.warning(f"Large maturity range ({range_diff}) with small step ({optimization_settings.maturity_step}). Adjusting step.")
                optimization_settings.maturity_step = max(15, optimization_settings.maturity_step)
        
        if method == "classic":
            return await optimize_classic(optimization_settings, general_settings)
        elif method == "genetic":
            return await optimize_genetic(optimization_settings, general_settings)
        else:
            # Default to classic method for any unsupported types
            logger.warning(f"Unknown optimization method: {method}, defaulting to classic")
            optimization_settings.optimization_method = "classic"
            return await optimize_classic(optimization_settings, general_settings)
    except Exception as e:
        # GÃ¼ncelleme yapmak iÃ§in hata durumunda progress'i gÃ¼ncelle
        optimization_progress.update(
            phase="Error", 
            message=f"Optimization error: {str(e)}",
            step=100
        )
        
        logger.error(f"Error in main optimize endpoint: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Optimization error: {str(e)}")

@router.get("/optimize/progress/")
async def get_optimization_progress():
    """Get the current status of the optimization process"""
    # Ä°lerleme sÄ±fÄ±rlanmÄ±ÅŸ olabileceÄŸinden force_update
    progress_data = optimization_progress.get_info()
    logger.debug(f"Progress data: {progress_data}")  # Debugging iÃ§in loglama ekleyin
    return progress_data

======================================================================

DOSYA: backend\app\routers\stress_testing.py
==================================================
from fastapi import APIRouter, HTTPException
from app.models.input_models import StressTestRequest
from app.services.stress_testing_service import perform_stress_test
from app.routers.calculation import df_store
import logging
import traceback

router = APIRouter()
logger = logging.getLogger(__name__)

@router.post("/stress-test/", response_model=dict)
async def stress_test(request: StressTestRequest):
    try:
        # Get the stored dataframe with better error message
        df = df_store.get("df")
        if df is None:
            raise HTTPException(
                status_code=400, 
                detail="No loan data found. Please upload an Excel file on the Structure Analysis page first."
            )
        
        # Validate dataframe has required columns
        required_columns = ['principal_amount', 'interest_amount', 'cash_flow', 'installment_date']
        missing_columns = [col for col in required_columns if col not in df.columns]
        if missing_columns:
            raise HTTPException(
                status_code=400,
                detail=f"Missing required columns in uploaded data: {', '.join(missing_columns)}"
            )
        
        # Basic validation of input data
        if not request.structure:
            raise HTTPException(status_code=400, detail="Structure details are missing")
            
        # Validate structure parameters
        if not request.structure.a_maturities:
            raise HTTPException(status_code=400, detail="No Class A maturities provided")
        
        # Ensure lists are of equal length
        list_lengths = [
            len(request.structure.a_maturities),
            len(request.structure.a_base_rates),
            len(request.structure.a_spreads),
            len(request.structure.a_reinvest_rates),
            len(request.structure.a_nominals)
        ]
        if len(set(list_lengths)) > 1:
            raise HTTPException(
                status_code=400, 
                detail=f"Inconsistent lengths in Class A parameters: {list_lengths}"
            )
        
        # Validate scenario parameters
        if request.scenario.npl_rate < 0 or request.scenario.npl_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"NPL rate must be between 0 and 100, got {request.scenario.npl_rate}"
            )
            
        if request.scenario.prepayment_rate < 0 or request.scenario.prepayment_rate > 100:
            raise HTTPException(
                status_code=400,
                detail=f"Prepayment rate must be between 0 and 100, got {request.scenario.prepayment_rate}"
            )
        
        # Log inputs for debugging
        logger.info(f"Running stress test with scenario: {request.scenario.name}")
        logger.info(f"NPL rate: {request.scenario.npl_rate}%, Prepayment: {request.scenario.prepayment_rate}%, Reinvestment shift: {request.scenario.reinvestment_shift}%")
        
        # Perform the stress test
        result = perform_stress_test(df, request)
        
        # Log results for debugging
        logger.info(f"Stress test completed. Baseline rate: {result['baseline']['class_b_coupon_rate']}%, Stress rate: {result['stress_test']['class_b_coupon_rate']}%")
        logger.info(f"Difference: {result['difference']['class_b_coupon_rate']}%")
        
        return result
    except HTTPException:
        # Re-raise HTTP exceptions directly
        raise
    except Exception as e:
        # Capture and log the full exception details
        stack_trace = traceback.format_exc()
        error_message = str(e)
        logger.error(f"Stress testing error: {error_message}\n{stack_trace}")
        
        # Provide a meaningful error message
        if not error_message:
            error_message = "Unknown error occurred during stress testing. Check server logs for details."
            
        raise HTTPException(
            status_code=400, 
            detail=f"Stress testing error: {error_message}"
        )

======================================================================

DOSYA: backend\app\services\calculation_service.py
==================================================
# -*- coding: utf-8 -*-
"""
Calculation Service â€“ 2025â€‘04â€‘18
* Ortak hesaplama mantÄ±ÄŸÄ±nÄ± tranche_utils.py'den kullanarak yeniden dÃ¼zenlenmiÅŸ
* Class B kupon oranÄ± hesaplama optimization ve calculation servisleri arasÄ±nda uyumlu
"""

from typing import List, Dict, Any
import io
import pandas as pd
import numpy as np

from app.models.input_models import CalculationRequest
from app.models.output_models import CalculationResult
from app.utils.tranche_utils import calculate_tranche_results

# --------------------------------------------------------------------------- #
#                               FILE LOADER                                   #
# --------------------------------------------------------------------------- #
def load_excel_data(contents: bytes) -> pd.DataFrame:
    """Excel dosyasÄ±nÄ± okuyup minimum temizliÄŸi yapar."""
    try:
        df = pd.read_excel(io.BytesIO(contents))
        df.rename(columns={"Copyinstallment_date": "installment_date"},
                  inplace=True, errors="ignore")
        df["installment_date"] = pd.to_datetime(
            df["installment_date"], dayfirst=True, errors="coerce"
        )

        required = {"principal_amount", "interest_amount"}
        if not required.issubset(df.columns):
            raise ValueError(f"Missing columns: {required - set(df.columns)}")

        df["cash_flow"] = df["principal_amount"] + df["interest_amount"]
        df["original_cash_flow"] = df["cash_flow"].copy()
        return df

    except Exception as exc:
        raise ValueError(f"Excel processing error: {exc}") from exc


# --------------------------------------------------------------------------- #
#                             MAIN CALCULATION                                #
# --------------------------------------------------------------------------- #
def perform_calculation(df: pd.DataFrame,
                        request: CalculationRequest) -> CalculationResult:
    """ABS nakitâ€‘akÄ±ÅŸÄ± hesabÄ± - ortak tranche_utils mantÄ±ÄŸÄ±nÄ± kullanÄ±r"""

    # --------------------------- GENEL VERÄ°LER ------------------------------ #
    start_date = pd.Timestamp(request.general_settings.start_date)
    ops_exp = request.general_settings.operational_expenses

    # ---------------------------- TRANCHE A -------------------------------- #
    a_maturities = [t.maturity_days for t in request.tranches_a]
    a_base_rates = [t.base_rate for t in request.tranches_a]
    a_spreads = [t.spread for t in request.tranches_a]
    a_reinvest_rates = [t.reinvest_rate for t in request.tranches_a]
    a_nominals = [round(t.nominal / 1_000) * 1_000 for t in request.tranches_a]

    # ---------------------------- TRANCHE B -------------------------------- #
    # â‘  nominal: optimize geldiyse kullan, yoksa %10.178 kuralÄ±
    if request.tranche_b.nominal and request.tranche_b.nominal > 0:
        b_nominal = request.tranche_b.nominal
    else:
        percent_b = 10.17811704
        total_a = sum(a_nominals)
        b_nominal = (total_a * percent_b) / (100 - percent_b)
        b_nominal = round(b_nominal / 1_000) * 1_000

    b_nominal = max(1_000, round(b_nominal / 1_000) * 1_000)

    # â‘¡ diÄŸer B parametreleri
    raw_b_day = request.tranche_b.maturity_days
    b_maturity = min(365, max(1, raw_b_day))          # 1â€‘365 sÄ±nÄ±rÄ±
    b_base_rate = request.tranche_b.base_rate
    b_spread = request.tranche_b.spread
    b_reinvest_rate = request.tranche_b.reinvest_rate

    # ----------------------- ORTAK HESAPLAMA MODÃœLÃœ KULLAN ---------------- #
    results = calculate_tranche_results(
        df, start_date,
        a_maturities, a_base_rates, a_spreads, a_reinvest_rates, a_nominals,
        b_maturity, b_base_rate, b_spread, b_reinvest_rate, b_nominal,
        ops_exp
    )

    # SonuÃ§larÄ± Ã§Ä±ktÄ± formatÄ±na dÃ¶nÃ¼ÅŸtÃ¼r
    return CalculationResult(
        class_a_total=results['class_a_total'],
        class_b_total=results['class_b_total'],
        class_a_principal=results['class_a_principal'],
        class_b_principal=results['class_b_principal'],
        class_a_interest=results['class_a_interest'],
        class_b_coupon=results['class_b_coupon'],
        min_buffer_actual=results['min_buffer_actual'],
        total_principal_paid=results['total_principal_paid'],
        total_loan_principal=results['total_loan_principal'],
        financing_cost=results['financing_cost'],
        tranche_results=results['tranche_results'],
        interest_rate_conversions=results['interest_rate_conversions'],
    )

======================================================================

DOSYA: backend\app\services\optimization_service.py
==================================================
"""
Optimization service for ABS structure analysis - Yeniden DÃ¼zenlenmiÅŸ.
Ortak hesaplama mantÄ±ÄŸÄ±nÄ± tranche_utils.py'den kullanarak uyumlu hale getirilmiÅŸ.
"""
import time
import pandas as pd
import numpy as np
import itertools
from datetime import datetime, timedelta
import random
import traceback
import logging
from typing import Dict, List, Any, Tuple, Optional

from app.models.input_models import OptimizationSettings, GeneralSettings
from app.models.output_models import OptimizationResult
from app.utils.finance_utils import (
    simple_to_compound_annual,
    get_nearest_maturity,
    get_last_cash_flow_day
)
from app.utils.cash_flow_utils import (
    assign_cash_flows_to_tranches,
    calculate_totals
)
from app.utils.tranche_utils import (
    calculate_tranche_results,
    adjust_class_a_nominals_for_target_coupon
)

# Configure logger
logger = logging.getLogger(__name__)

class OptimizationProgress:
    """Class to track and report optimization progress"""
    def __init__(self):
        self.reset()
        
    def reset(self):
        """Reset all progress tracking variables"""
        self.current_step = 0
        self.total_steps = 100
        self.current_phase = "Initializing"
        self.status_message = "Starting optimization..."
        self.progress = 0
        self.last_update_time = time.time()
        self.start_time = time.time()
        logger.info("Progress tracker reset")
        
    def update(self, step=None, total=None, phase=None, message=None):
        """Update progress information"""
        current_time = time.time()
        
        # Update more frequently
        force_update = (current_time - self.last_update_time) > 0.2
        
        if step is not None:
            self.current_step = step
        if total is not None:
            self.total_steps = total
        if phase is not None:
            self.current_phase = phase
        if message is not None:
            self.status_message = message
            
        # Calculate percentage
        if self.total_steps > 0:
            new_progress = min(99, int((self.current_step / self.total_steps) * 100))
            if self.current_phase == "Complete" or self.current_phase == "Error":
                new_progress = 100  # Set to 100% when complete or error
            
            progress_changed = new_progress != self.progress
            self.progress = new_progress
        
        # Log progress updates
        if phase is not None or message is not None or progress_changed or force_update:
            elapsed = current_time - self.start_time
            logger.info(f"Progress: {self.progress}% - {self.current_phase} - {self.status_message} (elapsed: {elapsed:.1f}s)")
            self.last_update_time = current_time
        
    def get_info(self):
        """Get current progress information with additional data"""
        current_time = time.time()
        elapsed = current_time - self.start_time
        
        return {
            "progress": self.progress,
            "phase": self.current_phase,
            "message": self.status_message,
            "step": self.current_step,
            "total_steps": self.total_steps,
            "timestamp": current_time,
            "elapsed_seconds": elapsed,
            "start_time": self.start_time
        }

# Create the global optimization_progress instance
optimization_progress = OptimizationProgress()

def evaluate_params(
    df: pd.DataFrame,
    start_date: pd.Timestamp,
    maturities: List[int], 
    nominals: List[float], 
    class_b_maturity: int, 
    maturity_to_base_rate_A: Dict[int, float], 
    maturity_to_reinvest_rate_A: Dict[int, float],
    class_b_base_rate: float, 
    class_b_reinvest_rate: float,
    target_class_b_percent: float, 
    class_b_percent_deviation: float,
    target_class_b_coupon_rate: float, 
    min_buffer: float,
    ops_expenses: float = 0.0
) -> Dict[str, Any]:
    """Helper function to evaluate a set of parameters using shared calculate_tranche_results logic"""
    # Verify input parameters
    if not maturities or not nominals or len(maturities) != len(nominals):
        return {
            'is_valid': False,
            'score': 0,
            'results': None,
            'error': "Invalid input dimensions",
            'b_nominal': 0,
            'class_b_percent': 0
        }
    
    # Ensure types are correct
    maturities = [int(m) for m in maturities]
    nominals = list(nominals)
    
    # Round nominals to nearest 1000 and ensure no zeros
    nominals = [max(1000, round(n / 1000) * 1000) for n in nominals]
    
    # Get rates from lookup tables with fallback values
    available_lookup_keys = list(maturity_to_base_rate_A.keys())
    base_rates = [maturity_to_base_rate_A.get(
        get_nearest_maturity(m, available_lookup_keys), 42.0) for m in maturities]
    
    reinvest_rates = [maturity_to_reinvest_rate_A.get(
        get_nearest_maturity(m, list(maturity_to_reinvest_rate_A.keys())), 30.0) for m in maturities]
    
    # Default all spreads to 0
    spreads = [0.0] * len(maturities)
    
    # Calculate total Class A nominal
    total_a_nominal = sum(nominals)
    if total_a_nominal <= 0:
        return {
            'is_valid': False,
            'score': 0,
            'results': None,
            'error': "Total Class A nominal must be positive",
            'b_nominal': 0,
            'class_b_percent': 0
        }
    
    # Calculate Class B nominal based on target percentage
    target_b_share = target_class_b_percent / 100
    class_b_nominal = (total_a_nominal * target_b_share) / (1 - target_b_share)
    
    # Round to nearest 1000
    class_b_nominal = round(class_b_nominal / 1_000) * 1_000
    
    # Calculate actual Class B percentage
    total_nominal = total_a_nominal + class_b_nominal
    actual_class_b_percent = (class_b_nominal / total_nominal) * 100
    
    # If the actual percentage is outside allowed range, adjust the nominal value
    min_class_b_percent = max(0.1, target_class_b_percent - class_b_percent_deviation)
    max_class_b_percent = min(50, target_class_b_percent + class_b_percent_deviation)
    
    if actual_class_b_percent < min_class_b_percent or actual_class_b_percent > max_class_b_percent:
        logger.debug(f"Adjusting Class B nominal to meet target percent. Current: {actual_class_b_percent:.2f}%, Target: {target_class_b_percent:.2f}%Â±{class_b_percent_deviation:.2f}%")
        
        # Calculate corrected B share
        if actual_class_b_percent < min_class_b_percent:
            corrected_b_share = min_class_b_percent / 100
        else:
            corrected_b_share = max_class_b_percent / 100
        
        # Recalculate B nominal
        class_b_nominal = (total_a_nominal * corrected_b_share) / (1 - corrected_b_share)
        class_b_nominal = round(class_b_nominal / 1_000) * 1_000
        
        # Recalculate actual percentage
        total_nominal = total_a_nominal + class_b_nominal
        actual_class_b_percent = (class_b_nominal / total_nominal) * 100
        
        logger.debug(f"Adjusted Class B percent to: {actual_class_b_percent:.2f}%")
    
    try:
        # Use shared calculation logic
        result = calculate_tranche_results(
            df, start_date,
            maturities, base_rates, spreads, reinvest_rates, nominals,
            class_b_maturity, class_b_base_rate, 0.0, class_b_reinvest_rate, class_b_nominal,
            ops_expenses
        )
        
        # Extract relevant metrics
        class_a_principal = result['class_a_principal']
        class_b_principal = result['class_b_principal']
        class_a_interest = result['class_a_interest']
        class_b_coupon = result['class_b_coupon']
        class_a_total = result['class_a_total']
        class_b_total = result['class_b_total']
        min_buffer_actual = result['min_buffer_actual']
        effective_coupon_rate = result['effective_coupon_rate']
        direct_coupon_rate = result['direct_coupon_rate']
        
        # Check if valid (meets minimum buffer requirement)
        is_valid = min_buffer_actual >= min_buffer
        
        # Check if Class B percentage is within acceptable range
        class_b_percent_diff = abs(actual_class_b_percent - target_class_b_percent)
        is_class_b_percent_valid = min_class_b_percent <= actual_class_b_percent <= max_class_b_percent
        
        # A solution is valid only if it meets both buffer and Class B percentage requirements
        is_valid = is_valid and is_class_b_percent_valid
        
        # Calculate coupon rate difference from target
        coupon_rate_diff = abs(effective_coupon_rate - target_class_b_coupon_rate)
        
        # Collect results
        result_dict = {
            'class_a_principal': class_a_principal,
            'class_b_principal': class_b_principal,
            'class_a_interest': class_a_interest, 
            'class_b_coupon': class_b_coupon,
            'class_a_total': class_a_total,
            'class_b_total': class_b_total,
            'min_buffer_actual': min_buffer_actual,
            'total_principal': class_a_principal + class_b_principal,
            'class_b_coupon_rate': effective_coupon_rate,
            'direct_coupon_rate': direct_coupon_rate,
            'class_b_percent': actual_class_b_percent,
            'class_b_percent_diff': class_b_percent_diff,
            'coupon_rate_diff': coupon_rate_diff,
            'num_a_tranches': len(maturities)
        }
        
        # Scoring with balanced weighting between coupon rate and Class B percentage
        coupon_rate_weight = np.exp(-coupon_rate_diff / 3.0)
        class_b_percent_weight = np.exp(-class_b_percent_diff / 2.0)
        combined_weight = (coupon_rate_weight * 0.6) + (class_b_percent_weight * 0.4)
        weighted_principal = result_dict['total_principal'] * combined_weight
        
        return {
            'is_valid': is_valid,
            'score': weighted_principal if is_valid else 0,
            'results': result_dict if is_valid else None,
            'b_nominal': class_b_nominal,
            'class_b_percent': actual_class_b_percent
        }
    
    except Exception as e:
        # Return invalid result on any error
        logger.error(f"Error in evaluate_params: {str(e)}")
        logger.debug(traceback.format_exc())
        return {
            'is_valid': False,
            'score': 0,
            'results': None,
            'error': str(e),
            'b_nominal': class_b_nominal,
            'class_b_percent': actual_class_b_percent
        }

def perform_optimization(df: pd.DataFrame, general_settings: GeneralSettings, optimization_settings: OptimizationSettings) -> OptimizationResult:
    """Perform ABS structure optimization with improved coupon rate and Class B percentage targeting
    
    Args:
        df: DataFrame containing cash flow data
        general_settings: General settings for the optimization
        optimization_settings: Optimization-specific settings
        
    Returns:
        OptimizationResult object with the optimized structure
    """
    
    # Initialize progress tracking
    optimization_progress.update(step=0, total=100, 
                                phase="Standard Optimization", 
                                message="Starting standard optimization...")
    
    # Extract settings
    min_a_tranches, max_a_tranches = optimization_settings.a_tranches_range
    maturity_range = optimization_settings.maturity_range
    maturity_step = optimization_settings.maturity_step
    
    # Get selected default model
    selected_default_model = getattr(optimization_settings, "selected_default_model", "previous")
    
    # Use the new Class B percentage targeting parameters 
    target_class_b_percent = getattr(optimization_settings, "min_class_b_percent", 15.0)
    class_b_percent_deviation = getattr(optimization_settings, "class_b_percent_deviation", 1.0)
    target_class_b_coupon_rate = optimization_settings.target_class_b_coupon_rate
    additional_days = optimization_settings.additional_days_for_class_b
    
    # Log the actual values used for debugging
    logger.info(f"Target Class B percent: {target_class_b_percent}, deviation: {class_b_percent_deviation}")
    logger.info(f"Selected default model: {selected_default_model}")
    
    # Get selected strategies - use all if not specified
    selected_strategies = getattr(optimization_settings, "selected_strategies", 
                                ["equal", "increasing", "decreasing", "middle_weighted"])
    
    optimization_progress.update(step=5, 
                               message=f"Selected strategies: {', '.join(selected_strategies)}")
    
    # Set maximum allowed difference for coupon rate - tightened for better matching
    max_allowed_diff = 0.5  # Maximum 0.5% difference (reduced from 1.0%)
    
    optimization_progress.update(step=5, 
                               message=f"Target coupon rate: {target_class_b_coupon_rate}%, Target Class B: {target_class_b_percent}Â±{class_b_percent_deviation}%")
    
    start_date = pd.Timestamp(general_settings.start_date)
    ops_expenses = general_settings.operational_expenses
    min_buffer = general_settings.min_buffer
    
    # Get original parameters for Class A based on selected default model
    if selected_default_model == "new":
        # New model parameters (April 16, 2025)
        original_maturities_A = [59, 94, 150, 189, 275]
        original_base_rates_A = [45.5, 45.5, 45.5, 45.5, 45.5]
        original_reinvest_rates_A = [41.0, 38.5, 35.0, 33.5, 31.5]
        
        # Class B values for new model
        class_b_maturity_orig = 346
        class_b_base_rate_orig = 0.0
        class_b_reinvest_rate_orig = 30.0
        
        # Calculate total nominal amount for new model
        total_a_nominal = 3169600000  # Sum of all Class A tranches in new model
    else:
        # Previous model parameters (February 13, 2025)
        original_maturities_A = [61, 120, 182, 274]
        original_base_rates_A = [45.6, 44.5, 43.3, 42.5]
        original_reinvest_rates_A = [40.0, 37.25, 32.5, 30.0]
        
        # Class B values for previous model
        class_b_maturity_orig = 300
        class_b_base_rate_orig = 0.0
        class_b_reinvest_rate_orig = 25.5
        
        # Calculate total nominal amount for previous model
        total_a_nominal = 1765000000  # Original sum from previous model
    
    optimization_progress.update(step=10, 
                               message="Creating rate lookup tables and preparing data...")
    
    # Create rate lookup tables for Class A
    maturity_to_base_rate_A = dict(zip(original_maturities_A, original_base_rates_A))
    maturity_to_reinvest_rate_A = dict(zip(original_maturities_A, original_reinvest_rates_A))
    
    # Define search space
    num_a_tranches_options = range(min_a_tranches, max_a_tranches + 1)
    possible_maturities = list(range(maturity_range[0], maturity_range[1] + 1, maturity_step))
    
    optimization_progress.update(step=15, 
                               message=f"Using tranches from {min_a_tranches} to {max_a_tranches}")
    
    # Dictionaries to track best results for each strategy
    strategy_names = ["equal", "increasing", "decreasing", "middle_weighted"]
    
    best_params_by_strategy = {strategy: None for strategy in strategy_names}
    best_results_by_strategy = {strategy: None for strategy in strategy_names}
    best_weighted_principal_by_strategy = {strategy: 0 for strategy in strategy_names}
    best_coupon_rate_diff_by_strategy = {strategy: float('inf') for strategy in strategy_names}
    best_class_b_percent_diff_by_strategy = {strategy: float('inf') for strategy in strategy_names}
    
    # Find last cash flow day
    last_cash_flow_day = get_last_cash_flow_day(df, start_date)
    
    optimization_progress.update(step=20, 
                               message=f"Last cash flow day: {last_cash_flow_day}")
    
    # Create a temporary copy of dataframe for calculations
    df_temp = df.copy()
    df_temp['cash_flow'] = df_temp['original_cash_flow'].copy()
    
    # Fix: Ensure target_date uses standard hyphen
    target_date = pd.Timestamp('2025-02-16')
    target_rows = df_temp[df_temp['installment_date'].dt.date == target_date.date()]
    
    if not target_rows.empty:
        t_idx = target_rows.index[0]
        orig_cf = df_temp.at[t_idx, 'cash_flow']
        new_cf = max(0, orig_cf - ops_expenses)
        df_temp.at[t_idx, 'cash_flow'] = new_cf
    
    # Initialize progress counter
    current_iteration = 0
    
    # Calculate total iterations (approximate)
    total_maturity_combinations = 0
    for num_a_tranches in num_a_tranches_options:
        # Rough estimate of combinations, will be reduced later
        total_maturity_combinations += min(1000, len(list(itertools.combinations(possible_maturities, num_a_tranches))))
    
    # 4 strategies per maturity combo
    total_iterations = total_maturity_combinations * len(selected_strategies)
    optimization_progress.update(message=f"Estimated iterations: {total_iterations}")
    
    # Progress tracking variables
    current_phase = "Testing Configurations"
    optimization_progress.update(phase=current_phase)
    
    # Fix: Ensure class_b_maturity is at least 1
    # Calculate Class B maturity as Last Cash Flow Day + Additional Days
    class_b_maturity = max(1, min(365, last_cash_flow_day + additional_days))
    
    # Loop through Class A tranche counts
    for num_a_tranches_idx, num_a_tranches in enumerate(num_a_tranches_options):
        tranche_progress_base = 20 + (num_a_tranches_idx * 15)  # 15% progress per tranche count
        
        optimization_progress.update(
            step=tranche_progress_base,
            message=f"Testing with {num_a_tranches} Class A tranches"
        )
        
        # Minimum gap between consecutive maturities
        min_gap = 15  # In days
        
        # Create sequential maturity combinations
        maturity_combinations = []
        for maturities in itertools.combinations(possible_maturities, num_a_tranches):
            # Check if sorted and with minimum gap
            sorted_maturities = sorted(maturities)
            if all(sorted_maturities[i+1] - sorted_maturities[i] >= min_gap for i in range(len(sorted_maturities)-1)):
                maturity_combinations.append(sorted_maturities)
        
        # More intelligent sampling of maturity combinations
        # If too many combinations, use stratified sampling
        max_samples = 20  # Reduced from 30 to 20 for faster processing
        if len(maturity_combinations) > max_samples:
            # Sort by average maturity and select samples from different parts of the distribution
            sorted_combinations = sorted(maturity_combinations, 
                                        key=lambda x: sum(x)/len(x))
            step = len(sorted_combinations) // max_samples
            sampled_indices = [i * step for i in range(max_samples)]
            maturity_combinations = [sorted_combinations[i] for i in sampled_indices]
        
        # Calculate progress step for this set of combinations
        combo_count = len(maturity_combinations)
        combo_progress_step = 10 / max(1, combo_count)
        
        # Track consecutive failures to optimize performance
        consecutive_failures = 0
        max_consecutive_failures = 10  # Fast-fail threshold
        
        # Process maturity combinations
        for combo_idx, maturities in enumerate(maturity_combinations):
            combo_progress = tranche_progress_base + (combo_idx * combo_progress_step)
            
            # Skip updates for most combinations to reduce overhead
            if combo_idx % 5 == 0:  # Update every 5 combinations
                optimization_progress.update(
                    step=int(combo_progress),
                    message=f"Testing maturity combination {combo_idx+1}/{combo_count}: {maturities}"
                )
            
            # Assign rates based on nearest original Class A maturity
            a_base_rates = []
            a_reinvest_rates = []
            for m in maturities:
                nearest = get_nearest_maturity(m, original_maturities_A)
                a_base_rates.append(maturity_to_base_rate_A[nearest])
                a_reinvest_rates.append(maturity_to_reinvest_rate_A[nearest])
            
            # Use the base rate of the longest Class A tranche for Class B
            # but always use the original reinvest rate from UI
            if len(a_base_rates) > 0:
                b_base_rate = a_base_rates[-1]  # Use the base rate of the longest-maturity Class A tranche
                b_reinvest_rate = class_b_reinvest_rate_orig  # Always use original reinvest rate
            else:
                b_base_rate = class_b_base_rate_orig
                b_reinvest_rate = class_b_reinvest_rate_orig
            
            # Different nominal distribution strategies
            distribution_strategies = [
                strategy for strategy in selected_strategies 
                if strategy in ["equal", "increasing", "decreasing", "middle_weighted"]
            ]
            
            # If no valid strategies, use all
            if not distribution_strategies:
                distribution_strategies = ["equal", "increasing", "decreasing", "middle_weighted"]
                logger.warning(f"No valid strategies selected, using all: {distribution_strategies}")
            
            # Reset consecutive failures counter for each new maturity combination
            consecutive_failures = 0
            
            # Process each strategy
            for strategy in distribution_strategies:
                # Calculate required Class B nominal to achieve target percentage
                # Formula: class_b_nominal = total_a_nominal * (target_percent / (100 - target_percent))
                target_b_share = target_class_b_percent / 100
                class_b_nominal = (total_a_nominal * target_b_share) / (1 - target_b_share)
                
                # Round to nearest 1000
                class_b_nominal = round(class_b_nominal / 1000) * 1000
                
                # Calculate total nominal amount based on Class A and B
                remaining_nominal = total_a_nominal
                
                # Distribute nominal amounts based on strategy
                if strategy == "equal":
                    a_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                    
                elif strategy == "increasing":
                    # Weight by maturity days
                    weights = np.array(maturities)
                    a_nominals = (weights / weights.sum()) * remaining_nominal
                    
                elif strategy == "decreasing":
                    # Inverse weight by maturity days
                    weights = 1 / np.array(maturities)
                    a_nominals = (weights / weights.sum()) * remaining_nominal
                    
                elif strategy == "middle_weighted":
                    # Give more weight to middle tranches
                    if num_a_tranches >= 3:
                        weights = np.ones(num_a_tranches)
                        mid_idx = num_a_tranches // 2
                        weights[mid_idx] = 1.5
                        if num_a_tranches > 3:
                            weights[mid_idx-1] = 1.3
                            weights[mid_idx+1] = 1.3
                        a_nominals = (weights / weights.sum()) * remaining_nominal
                    else:
                        a_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                else:
                    # Invalid strategy, use equal distribution as fallback
                    logger.warning(f"Unknown strategy: {strategy}, using equal distribution")
                    a_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                
                # Round to nearest 1000
                a_nominals = [round(n / 1000) * 1000 for n in a_nominals]
                
                # Ensure sum equals the remaining nominal
                adjustment = (remaining_nominal - sum(a_nominals)) / num_a_tranches
                a_nominals = [n + adjustment for n in a_nominals]
                a_nominals = [round(n / 1000) * 1000 for n in a_nominals]
                
                # Make final adjustment to last tranche to ensure exact total
                a_nominals[-1] += remaining_nominal - sum(a_nominals)
                
                # Now adjust the nominals to achieve target coupon rate - use shared utility function
                try:
                    # Generate default spreads (all zeros)
                    a_spreads = [0.0] * len(a_nominals)
                    b_spread = 0.0
                    
                    adjusted_a_nominals, adjustment_success, adjusted_b_percent = adjust_class_a_nominals_for_target_coupon(
                        df_temp, start_date,
                        maturities, a_nominals, a_base_rates, a_spreads, a_reinvest_rates,
                        class_b_maturity, b_base_rate, b_spread, b_reinvest_rate, class_b_nominal,
                        target_class_b_coupon_rate, target_class_b_percent, min_buffer, ops_expenses,
                        max_allowed_diff, class_b_percent_deviation
                    )
                    
                    if adjustment_success:
                        a_nominals = adjusted_a_nominals
                        # Reset consecutive failures counter on success
                        consecutive_failures = 0
                    else:
                        # Increment consecutive failures counter
                        consecutive_failures += 1
                except Exception as e:
                    logger.error(f"Error adjusting nominals: {str(e)}")
                    consecutive_failures += 1
                    # Continue with original nominals
                
                # Evaluate the result with the shared evaluate_params function
                eval_result = evaluate_params(
                    df_temp, start_date,
                    maturities, a_nominals, class_b_maturity,
                    maturity_to_base_rate_A, maturity_to_reinvest_rate_A,
                    b_base_rate, b_reinvest_rate,
                    target_class_b_percent, class_b_percent_deviation,
                    target_class_b_coupon_rate, min_buffer,
                    ops_expenses
                )
                
                # Check if valid and meets buffer requirement
                if eval_result['is_valid'] and eval_result['results']:
                    result_dict = eval_result['results']
                    total_principal = result_dict['total_principal']
                    class_b_coupon_rate = result_dict['class_b_coupon_rate']
                    min_buffer_actual = result_dict['min_buffer_actual']
                    class_b_percent = result_dict['class_b_percent']
                    class_b_percent_diff = result_dict['class_b_percent_diff']
                    coupon_rate_diff = result_dict['coupon_rate_diff']
                    
                    # Improved scoring function combining both objectives
                    # Exponential penalty for rate difference
                    coupon_rate_weight = np.exp(-coupon_rate_diff / 2.0)
                    # Exponential penalty for Class B percentage difference
                    class_b_percent_weight = np.exp(-class_b_percent_diff / 2.0)
                    # Combined weight with 60% emphasis on coupon rate, 40% on Class B percentage
                    combined_weight = (coupon_rate_weight * 0.6) + (class_b_percent_weight * 0.4)
                    
                    weighted_principal = total_principal * combined_weight
                    
                    # Check if this is the best solution for this strategy
                    # Use a balanced approach between coupon rate and Class B percentage matching
                    # with a slight preference for coupon rate matching
                    is_better = False
                    
                    # Determine if this solution is better based on combined criteria
                    if coupon_rate_diff <= best_coupon_rate_diff_by_strategy[strategy] * 1.1 and \
                       class_b_percent_diff <= best_class_b_percent_diff_by_strategy[strategy] * 1.1:
                        # If both metrics are comparable or better, use weighted principal as tiebreaker
                        if weighted_principal > best_weighted_principal_by_strategy[strategy]:
                            is_better = True
                    elif coupon_rate_diff <= max_allowed_diff and \
                         class_b_percent_diff <= class_b_percent_deviation and \
                         weighted_principal > best_weighted_principal_by_strategy[strategy] * 1.15:
                        # If within allowed differences and significantly better weighted principal
                        is_better = True
                    elif (coupon_rate_diff < best_coupon_rate_diff_by_strategy[strategy] * 0.7 or \
                          class_b_percent_diff < best_class_b_percent_diff_by_strategy[strategy] * 0.7) and \
                         weighted_principal > best_weighted_principal_by_strategy[strategy] * 0.9:
                        # If one metric is much better without sacrificing too much weighted principal
                        is_better = True
                    
                    if is_better:
                        best_coupon_rate_diff_by_strategy[strategy] = coupon_rate_diff
                        best_class_b_percent_diff_by_strategy[strategy] = class_b_percent_diff
                        best_weighted_principal_by_strategy[strategy] = weighted_principal
                        
                        # Reset consecutive failures on finding a good solution
                        consecutive_failures = 0
                        
                        best_params_by_strategy[strategy] = {
                            'num_a_tranches': num_a_tranches,
                            'a_maturity_days': list(maturities),
                            'a_base_rates': a_base_rates,
                            'a_reinvest_rates': a_reinvest_rates,
                            'a_nominal_amounts': a_nominals,
                            'b_maturity_days': [class_b_maturity],
                            'b_base_rates': [b_base_rate],
                            'b_reinvest_rates': [b_reinvest_rate],
                            'b_nominal': [class_b_nominal],
                            'strategy': strategy,
                            'last_cash_flow_day': last_cash_flow_day,
                            'added_days': additional_days,
                            'class_b_percent': class_b_percent,
                            'direct_coupon_rate': result_dict['direct_coupon_rate'],
                            'effective_coupon_rate': result_dict['class_b_coupon_rate']
                        }
                        
                        best_results_by_strategy[strategy] = {
                            'class_a_principal': result_dict['class_a_principal'],
                            'class_b_principal': result_dict['class_b_principal'],
                            'class_a_interest': result_dict['class_a_interest'],
                            'class_b_coupon': result_dict['class_b_coupon'],
                            'class_a_total': result_dict['class_a_total'],
                            'class_b_total': result_dict['class_b_total'],
                            'min_buffer_actual': min_buffer_actual,
                            'total_principal': total_principal,
                            'class_b_coupon_rate': class_b_coupon_rate,
                            'direct_coupon_rate': result_dict['direct_coupon_rate'],
                            'target_class_b_coupon_rate': target_class_b_coupon_rate,
                            'coupon_rate_diff': coupon_rate_diff,
                            'class_b_percent': class_b_percent,
                            'target_class_b_percent': target_class_b_percent,
                            'class_b_percent_diff': class_b_percent_diff,
                            'class_b_base_rate': b_base_rate,
                            'num_a_tranches': num_a_tranches
                        }
                        
                        optimization_progress.update(
                            message=f"Found better solution for {strategy}: coupon_rate={class_b_coupon_rate:.2f}%, " +
                                   f"diff={coupon_rate_diff:.2f}%, Class B={class_b_percent:.2f}%, " +
                                   f"total_principal={total_principal:,.2f}"
                        )
                
                # Update iteration counter
                current_iteration += 1
                
                # Update progress periodically
                if current_iteration % 20 == 0:  # Reduced frequency of updates
                    progress_percent = min(80, 20 + int(current_iteration / total_iterations * 60))
                    optimization_progress.update(
                        step=progress_percent,
                        message=f"Completed {current_iteration} iterations out of approximately {total_iterations}"
                    )
                
                # Check if we should skip remaining strategies for this maturity combination
                if consecutive_failures >= max_consecutive_failures:
                    optimization_progress.update(
                        message=f"Skipping remaining strategies for this maturity combination due to {consecutive_failures} consecutive failures"
                    )
                    break
            
            # Early termination if we've found very good solutions across multiple strategies
            good_strategies_count = sum(1 for strat in strategy_names if 
                                      best_coupon_rate_diff_by_strategy[strat] <= 0.3 and
                                      best_class_b_percent_diff_by_strategy[strat] <= 0.5)
            if good_strategies_count >= 2 and combo_idx > combo_count // 4:
                optimization_progress.update(
                    message=f"Found {good_strategies_count} very good solutions, ending search early"
                )
                break
    
    # Update progress to preparing results phase
    optimization_progress.update(
        step=85,
        phase="Finalizing Results",
        message="Comparing strategies and preparing results..."
    )
    
    # Compare valid strategies
    valid_strategies = {k: v for k, v in best_results_by_strategy.items() if v is not None}
    
    if not valid_strategies:
        # No valid solution found
        optimization_progress.update(
            step=90,
            message="No valid configuration found. Try adjusting optimization parameters."
        )
        raise ValueError("No valid configuration found. Try adjusting optimization parameters.")
    
    # Improved strategy selection with balanced weighting between coupon rate and Class B percentage
    # Find best overall strategy prioritizing both objectives
    best_overall_strategy = min(
        valid_strategies.items(),
        key=lambda x: (
            # First sort by normalized combined objective 
            (x[1]['coupon_rate_diff'] / target_class_b_coupon_rate * 0.6) + 
            (x[1]['class_b_percent_diff'] / target_class_b_percent * 0.4),
            # Then by negative principal (higher principal is better)
            -x[1]['total_principal']
        )
    )[0]
    
    # Get best parameters and results
    best_strategy = best_overall_strategy
    best_params = best_params_by_strategy[best_strategy]
    best_results = best_results_by_strategy[best_strategy]
    
    optimization_progress.update(
        step=95,
        message=f"Selected best strategy: {best_strategy}, coupon_rate: {best_results['class_b_coupon_rate']:.2f}%, " +
               f"diff: {best_results['coupon_rate_diff']:.2f}%, Class B: {best_results['class_b_percent']:.2f}%, " +
               f"total_principal: {best_results['total_principal']:,.2f}"
    )
    
    # Extract values for the result
    class_a_maturities = best_params['a_maturity_days']
    class_a_nominals = best_params['a_nominal_amounts']
    class_a_rates = best_params['a_base_rates']
    class_a_reinvest = best_params['a_reinvest_rates']
    
    class_b_maturity = best_params['b_maturity_days'][0]
    class_b_rate = best_params['b_base_rates'][0]
    class_b_reinvest = best_params['b_reinvest_rates'][0]
    class_b_nominal = best_params['b_nominal'][0]
    class_b_percent = best_params['class_b_percent']
    
    # Debug logging
    print(f"*** OPTIMIZATION RESULTS ***")
    print(f"Class B coupon rate (effective): {best_results['class_b_coupon_rate']}")
    print(f"Class B coupon rate (direct): {best_params.get('direct_coupon_rate', best_results['direct_coupon_rate'])}")
    print(f"Class B maturity: {class_b_maturity}")
    
    # Final progress update
    optimization_progress.update(
        step=100,
        phase="Complete",
        message="Optimization completed successfully."
    )
    
    # Return the optimization result with enhanced data
    return OptimizationResult(
        best_strategy=best_strategy,
        class_a_maturities=class_a_maturities,
        class_a_nominals=class_a_nominals,
        class_a_rates=class_a_rates,
        class_a_reinvest=class_a_reinvest,
        class_b_maturity=class_b_maturity,
        class_b_rate=class_b_rate,
        class_b_reinvest=class_b_reinvest,
        class_b_nominal=class_b_nominal,
        class_b_percent=class_b_percent,
        class_b_coupon_rate=best_results['class_b_coupon_rate'],
        direct_class_b_coupon_rate=best_results['direct_coupon_rate'],
        min_buffer_actual=best_results['min_buffer_actual'],
        last_cash_flow_day=last_cash_flow_day,
        additional_days=additional_days,
        results_by_strategy={k: v for k, v in best_results_by_strategy.items() if v is not None}
    )

def perform_genetic_optimization(df: pd.DataFrame, general_settings: GeneralSettings, optimization_settings: OptimizationSettings) -> OptimizationResult:
    """Genetic algorithm optimization with improved Class B percentage targeting - 
    Uses shared calculation logic from tranche_utils"""
    try:
        # Initialize progress tracking
        optimization_progress.update(step=0, total=100, 
                                    phase="Genetic Optimization", 
                                    message="Starting genetic algorithm optimization...")
        
        logger.info("Starting genetic algorithm optimization...")
        
        # Basic parameters
        start_date = pd.Timestamp(general_settings.start_date)
        ops_expenses = general_settings.operational_expenses
        min_buffer = general_settings.min_buffer
        
        # Get selected default model
        selected_default_model = getattr(optimization_settings, "selected_default_model", "previous")
        
        # Use the new Class B percentage targeting parameters
        target_class_b_percent = getattr(optimization_settings, "min_class_b_percent", 15.0)
        
        # Use the tighter class_b_percent_deviation value (default 1.0)
        class_b_percent_deviation = getattr(optimization_settings, "class_b_percent_deviation", 1.0)
        
        # Log the actual values used for debugging
        logger.info(f"Genetic: Target Class B percent: {target_class_b_percent}, deviation: {class_b_percent_deviation}")
        logger.info(f"Genetic: Selected default model: {selected_default_model}")
        
        target_class_b_coupon_rate = optimization_settings.target_class_b_coupon_rate
        additional_days = optimization_settings.additional_days_for_class_b
        population_size = getattr(optimization_settings, "population_size", 50)
        num_generations = getattr(optimization_settings, "num_generations", 40)
        
        optimization_progress.update(step=5, 
                                    message=f"Population size: {population_size}, generations: {num_generations}, " +
                                           f"Target Class B: {target_class_b_percent}Â±{class_b_percent_deviation}%")
        
        logger.info(f"Parameters: population_size={population_size}, num_generations={num_generations}, " +
                   f"target_class_b_percent={target_class_b_percent}Â±{class_b_percent_deviation}%")
        
        # Get last cash flow day
        last_cash_flow_day = get_last_cash_flow_day(df, start_date)
        
        # Update progress to 10%
        optimization_progress.update(step=10, 
                                    message=f"Last cash flow day: {last_cash_flow_day}")
        
        # Fix: Ensure class_b_maturity is at least 1 to avoid division by zero
        # Class B maturity as Last Cash Flow Day + Additional Days, capped at 365
        class_b_maturity = max(1, min(365, last_cash_flow_day + additional_days))
        
        # Get original parameters for Class A based on selected default model
        if selected_default_model == "new":
            # New model parameters (April 16, 2025)
            original_maturities_A = [59, 94, 150, 189, 275]
            original_base_rates_A = [45.5, 45.5, 45.5, 45.5, 45.5]
            original_reinvest_rates_A = [41.0, 38.5, 35.0, 33.5, 31.5]
            
            # Class B values for new model
            class_b_base_rate_orig = 0.0
            class_b_reinvest_rate_orig = 30.0
            
            # Calculate total nominal amount for new model
            total_a_nominal = 3169600000  # Sum of all Class A tranches in new model
            
            # Fixed number of tranches for new model
            default_num_a_tranches = 5  # New model has 5 tranches
        else:
            # Previous model parameters (February 13, 2025)
            original_maturities_A = [61, 120, 182, 274]
            original_base_rates_A = [45.6, 44.5, 43.3, 42.5]
            original_reinvest_rates_A = [40.0, 37.25, 32.5, 30.0]
            
            # Class B values for previous model
            class_b_base_rate_orig = 0.0
            class_b_reinvest_rate_orig = 25.5
            
            # Calculate total nominal amount for previous model
            total_a_nominal = 1765000000  # Original sum from previous model
            
            # Fixed number of tranches for previous model
            default_num_a_tranches = 4  # Previous model has 4 tranches
        
        # Create rate lookup tables for Class A
        maturity_to_base_rate_A = dict(zip(original_maturities_A, original_base_rates_A))
        maturity_to_reinvest_rate_A = dict(zip(original_maturities_A, original_reinvest_rates_A))
        
        # Update progress to 15%
        optimization_progress.update(step=15, 
                                    message="Preparing optimization data...")
        
        # Create temporary dataframe for calculation
        df_temp = df.copy()
        df_temp['cash_flow'] = df_temp['original_cash_flow'].copy()
        
        # Fix: Ensure target_date uses standard hyphen
        target_date = pd.Timestamp('2025-02-16')
        target_rows = df_temp[df_temp['installment_date'].dt.date == target_date.date()]
        
        if not target_rows.empty:
            t_idx = target_rows.index[0]
            orig_cf = df_temp.at[t_idx, 'cash_flow']
            new_cf = max(0, orig_cf - ops_expenses)
            df_temp.at[t_idx, 'cash_flow'] = new_cf
        
        # Fixed number of tranches - use the default for the selected model
        num_a_tranches = default_num_a_tranches
        
        # Parameter boundaries
        min_maturity = optimization_settings.maturity_range[0]
        max_maturity = optimization_settings.maturity_range[1]
        
        # Initialize population with valid individuals
        population = []
        min_gap = 15  # Minimum days between maturities
        
        optimization_progress.update(step=20, 
                                   phase="Initializing Population",
                                   message="Creating initial population...")
        
        logger.info("Initializing population...")
        
        # Function to create a valid individual with Class B percentage gene
        def create_valid_individual():
            # Generate valid maturities - ensure they are integers
            maturities = []
            maturities.append(random.randint(min_maturity, min_maturity + 60))
            
            for j in range(1, num_a_tranches):
                prev_maturity = maturities[j-1]
                min_new = prev_maturity + min_gap
                max_new = min(max_maturity, prev_maturity + 120)  # Cap max gap
                
                if min_new > max_new:
                    min_new = max_new
                
                maturities.append(random.randint(min_new, max_new))
            
            # Ensure all maturities are integers
            maturities = [int(m) for m in maturities]
            
            # Random weights
            weights = [random.random() for _ in range(num_a_tranches)]
            total_weight = sum(weights)
            weights = [w / total_weight for w in weights]
            
            # Convert to nominals
            nominals = [w * total_a_nominal for w in weights]
            
            # Random Class B percentage within allowed range
            # This is a key enhancement in the genetic algorithm
            min_percent = max(0.1, target_class_b_percent - class_b_percent_deviation)
            max_percent = min(50, target_class_b_percent + class_b_percent_deviation)
            random_b_percent = random.uniform(min_percent, max_percent)
            
            # Calculate Class B nominal based on random percentage
            # Formula: class_b_nominal = total_a_nominal * (b_percent / (100 - b_percent))
            b_share = random_b_percent / 100
            class_b_nominal = (total_a_nominal * b_share) / (1 - b_share)
            
            # Round to nearest 1000
            class_b_nominal = round(class_b_nominal / 1000) * 1000
            
            # Calculate actual Class B percentage
            total_nominal = total_a_nominal + class_b_nominal
            actual_b_percent = (class_b_nominal / total_nominal) * 100
            
            return {
                'maturities': maturities,
                'nominals': nominals,
                'class_b_nominal': class_b_nominal,
                'class_b_percent': actual_b_percent,
                'fitness': 0  # Will be evaluated
            }
        
        # Create initial population
        failure_count = 0
        for i in range(population_size):
            try:
                individual = create_valid_individual()
                population.append(individual)
                
                # Update progress periodically
                if i % 10 == 0:
                    optimization_progress.update(
                        step=20 + int((i / population_size) * 5),
                        message=f"Initializing population: {i+1}/{population_size}"
                    )
            except Exception as e:
                logger.error(f"Error creating individual {i}: {str(e)}")
                failure_count += 1
                # Try again
                if failure_count < 50:  # Limit retries
                    i -= 1  # Retry this index
                else:
                    logger.error("Too many failures creating population, proceeding with limited population")
                    break
        
        # Ensure we have at least some individuals
        if len(population) < 5:
            optimization_progress.update(
                phase="Error",
                message="Failed to create sufficient initial population"
            )
            raise ValueError("Failed to create sufficient initial population")
        
        # Update progress to 25%
        optimization_progress.update(step=25, 
                                   phase="Evolution",
                                   message="Starting genetic algorithm evolution...")
        
        # Evolution loop
        best_individual = None
        best_fitness = -float('inf')
        
        logger.info("Starting genetic algorithm evolution...")
        
        generation_progress_step = 50 / num_generations  # 50% of progress for generations
        
        # Tournament selection function
        def tournament_select(pop, tournament_size=3):
            if not pop:
                raise ValueError("Empty population for tournament selection")
                
            contestants = random.sample(pop, min(tournament_size, len(pop)))
            return max(contestants, key=lambda x: x.get('fitness', -float('inf')))
        
        for generation in range(num_generations):
            # Update progress for each generation
            generation_progress = 25 + int(generation * generation_progress_step)
            optimization_progress.update(
                step=generation_progress,
                message=f"Generation {generation+1} of {num_generations}"
            )
            
            logger.info(f"Generation {generation+1} of {num_generations}")
            
            # Evaluate fitness
            fitness_sum = 0
            valid_count = 0
            
            for idx, individual in enumerate(population):
                try:
                    maturities = individual['maturities']
                    nominals = individual['nominals']
                    class_b_nominal = individual['class_b_nominal']
                    
                    # Ensure maturities are integers for evaluation
                    maturities_int = [int(m) for m in maturities]
                    
                    # Get rates based on nearest maturity
                    a_base_rates = [maturity_to_base_rate_A.get(
                        get_nearest_maturity(m, list(maturity_to_base_rate_A.keys())), 42.0) for m in maturities_int]
                    
                    a_reinvest_rates = [maturity_to_reinvest_rate_A.get(
                        get_nearest_maturity(m, list(maturity_to_reinvest_rate_A.keys())), 30.0) for m in maturities_int]
                    
                    # Calculate actual Class B percentage
                    total_a_nominal = sum(nominals)
                    total_nominal = total_a_nominal + class_b_nominal
                    actual_b_percent = (class_b_nominal / total_nominal) * 100
                    
                    individual['class_b_percent'] = actual_b_percent
                    
                    # Try to adjust nominals for target coupon rate using the shared utility function
                    try:
                        # Generate default spreads (all zeros)
                        a_spreads = [0.0] * len(nominals)
                        b_spread = 0.0
                        
                        adjusted_nominals, adjustment_success, adjusted_b_percent = adjust_class_a_nominals_for_target_coupon(
                            df_temp, start_date,
                            maturities_int, nominals, a_base_rates, a_spreads, a_reinvest_rates,
                            class_b_maturity, class_b_base_rate_orig, b_spread, class_b_reinvest_rate_orig, class_b_nominal,
                            target_class_b_coupon_rate, target_class_b_percent, min_buffer, ops_expenses
                        )
                        
                        if adjustment_success:
                            nominals = adjusted_nominals
                            individual['nominals'] = nominals
                            individual['class_b_percent'] = adjusted_b_percent
                    except Exception as e:
                        logger.error(f"Error adjusting nominals: {str(e)}")
                        # Continue with original nominals
                    
                    # Evaluate the adjusted parameters using shared evaluate_params
                    eval_result = evaluate_params(
                        df_temp, start_date,
                        maturities_int, nominals, class_b_maturity,
                        maturity_to_base_rate_A, maturity_to_reinvest_rate_A,
                        class_b_base_rate_orig, class_b_reinvest_rate_orig,
                        target_class_b_percent, class_b_percent_deviation,
                        target_class_b_coupon_rate, min_buffer,
                        ops_expenses
                    )
                    
                    # Set fitness - ensure it's a number
                    if eval_result['is_valid']:
                        individual['fitness'] = float(eval_result['score'])
                        individual['result'] = eval_result
                        fitness_sum += individual['fitness']
                        valid_count += 1
                    else:
                        individual['fitness'] = -1.0 # Invalid but better than -inf for selection
                        individual['result'] = None
                    
                    # Track the best
                    if individual['fitness'] > best_fitness:
                        best_fitness = individual['fitness']
                        best_individual = individual.copy()
                        logger.info(f"Found better solution: score={best_fitness}")
                        
                        # Update progress message when finding better solution
                        if 'result' in individual and individual['result'] and 'results' in individual['result']:
                            results = individual['result']['results']
                            if results:
                                coupon_rate = results.get('class_b_coupon_rate', 0)
                                coupon_diff = abs(coupon_rate - target_class_b_coupon_rate)
                                class_b_percent = results.get('class_b_percent', 0)
                                percent_diff = abs(class_b_percent - target_class_b_percent)
                                
                                optimization_progress.update(
                                    message=f"Generation {generation+1}: Found better solution with score {best_fitness:.2f}, " +
                                           f"coupon rate: {coupon_rate:.2f}% (diff: {coupon_diff:.2f}%), " +
                                           f"Class B: {class_b_percent:.2f}% (diff: {percent_diff:.2f}%)"
                                )
                        else:
                            optimization_progress.update(
                                message=f"Generation {generation+1}: Found better solution with score {best_fitness:.2f}"
                            )
                except Exception as e:
                    logger.error(f"Error evaluating individual {idx} in generation {generation}: {str(e)}")
                    # Set very low fitness to avoid selection
                    individual['fitness'] = -float('inf')
                    individual['result'] = None
            
            # Log average fitness for valid individuals
            if valid_count > 0:
                avg_fitness = fitness_sum / valid_count
                logger.info(f"Generation {generation+1} average fitness: {avg_fitness:.2f} ({valid_count} valid individuals)")
            
            # Create next generation
            new_population = []
            
            # Elitism - keep best individuals
            sorted_pop = sorted(population, key=lambda x: x.get('fitness', -float('inf')), reverse=True)
            elite_count = max(2, population_size // 10)
            new_population.extend(sorted_pop[:elite_count])
            
            # Fill rest with crossover and mutation
            crossover_attempts = 0
            while len(new_population) < population_size and crossover_attempts < population_size * 2:
                crossover_attempts += 1
                try:
                    # Tournament selection
                    parent1 = tournament_select(population)
                    parent2 = tournament_select(population)
                    
                    # Crossover - mix maturities
                    child_maturities = []
                    for i in range(num_a_tranches):
                        # 50% chance from each parent
                        if random.random() < 0.5:
                            child_maturities.append(parent1['maturities'][i])
                        else:
                            child_maturities.append(parent2['maturities'][i])
                    
                    # Ensure maturities are valid integers
                    child_maturities = sorted([int(m) for m in child_maturities])
                    
                    # Fix any invalid gaps
                    for i in range(1, num_a_tranches):
                        if child_maturities[i] - child_maturities[i-1] < min_gap:
                            child_maturities[i] = child_maturities[i-1] + min_gap
                    
                    # Weight crossover with averaging
                    child_weights = []
                    for i in range(num_a_tranches):
                        weight1 = parent1['nominals'][i] / total_a_nominal
                        weight2 = parent2['nominals'][i] / total_a_nominal
                        child_weights.append((weight1 + weight2) / 2)
                    
                    # Normalize weights
                    total_weight = sum(child_weights)
                    child_weights = [w / total_weight for w in child_weights]
                    child_nominals = [w * total_a_nominal for w in child_weights]
                    
                    # Class B percentage crossover
                    # Use weighted average of parent percentages
                    if random.random() < 0.5:
                        # Weighted average with random weight
                        weight = random.random()
                        child_b_percent = (parent1['class_b_percent'] * weight) + (parent2['class_b_percent'] * (1 - weight))
                    else:
                        # Pick one parent's value
                        child_b_percent = parent1['class_b_percent'] if random.random() < 0.5 else parent2['class_b_percent']
                    
                    # Calculate Class B nominal from percentage
                    b_share = child_b_percent / 100
                    child_b_nominal = (total_a_nominal * b_share) / (1 - b_share)
                    child_b_nominal = round(child_b_nominal / 1000) * 1000
                    
                    # Mutation - mutate maturities
                    if random.random() < 0.3:  # 30% mutation rate
                        mutation_idx = random.randint(0, num_a_tranches-1)
                        
                        # Different mutation for different positions
                        if mutation_idx == 0:
                            # First maturity
                            child_maturities[0] = random.randint(min_maturity, min(child_maturities[1] - min_gap, min_maturity + 60))
                        elif mutation_idx == num_a_tranches - 1:
                            # Last maturity
                            child_maturities[-1] = random.randint(child_maturities[-2] + min_gap, max_maturity)
                        else:
                            # Middle maturity
                            min_val = child_maturities[mutation_idx-1] + min_gap
                            max_val = child_maturities[mutation_idx+1] - min_gap
                            
                            if min_val < max_val:
                                child_maturities[mutation_idx] = random.randint(min_val, max_val)
                    
                    # Mutation - mutate weights
                    if random.random() < 0.3:
                        mutation_idx = random.randint(0, num_a_tranches-1)
                        mutation_amount = random.uniform(-0.1, 0.1)
                        child_weights[mutation_idx] = max(0.1, min(0.4, child_weights[mutation_idx] + mutation_amount))
                        
                        # Renormalize
                        total_weight = sum(child_weights)
                        child_weights = [w / total_weight for w in child_weights]
                        child_nominals = [w * total_a_nominal for w in child_weights]
                    
                    # Mutation - mutate Class B percentage
                    if random.random() < 0.3:
                        mutation_amount = random.uniform(-class_b_percent_deviation / 2, class_b_percent_deviation / 2)
                        child_b_percent = max(0.1, min(50, child_b_percent + mutation_amount))
                        
                        # Recalculate B nominal
                        b_share = child_b_percent / 100
                        child_b_nominal = (total_a_nominal * b_share) / (1 - b_share)
                        child_b_nominal = round(child_b_nominal / 1000) * 1000
                    
                    # Add child to new population
                    new_population.append({
                        'maturities': child_maturities,  # These are already integers
                        'nominals': child_nominals,
                        'class_b_nominal': child_b_nominal,
                        'class_b_percent': child_b_percent,
                        'fitness': 0  # Will be evaluated in next generation
                    })
                except Exception as e:
                    logger.error(f"Error in crossover/mutation: {str(e)}")
                    continue
            
            # If we couldn't create enough children, fill with new random individuals
            while len(new_population) < population_size:
                try:
                    new_population.append(create_valid_individual())
                except Exception as e:
                    logger.error(f"Error creating new individual to fill population: {str(e)}")
                    # If we failed a few times, just break and proceed with smaller population
                    if len(new_population) > population_size * 0.7:
                        break
            
            # Replace population
            population = new_population
            
            # Early termination if we have an excellent solution
            if best_individual and best_individual.get('result') and best_individual['result'].get('results'):
                best_results = best_individual['result']['results']
                if best_results:
                    coupon_diff = abs(best_results.get('class_b_coupon_rate', 0) - target_class_b_coupon_rate)
                    percent_diff = abs(best_results.get('class_b_percent', 0) - target_class_b_percent)
                    
                    # Only terminate early if both objectives are very good
                    if coupon_diff < 0.2 and percent_diff < 0.5:
                        optimization_progress.update(
                            message=f"Found excellent solution (coupon diff < 0.2%, Class B diff < 0.5%), ending evolution early"
                        )
                        break
        
        # Update to 75% progress
        optimization_progress.update(step=75, 
                                phase="Finalizing",
                                message="Evolution complete, preparing final results...")
        
        # If no valid solution found
        if best_individual is None or best_fitness <= 0:
            optimization_progress.update(
                step=80,
                phase="Error",
                message="Genetic optimization failed: No valid solution found"
            )
            logger.error("Genetic optimization failed: No valid solution found")
            # Fall back to classic optimization
            optimization_progress.update(
                message="Falling back to classic optimization method..."
            )
            return perform_optimization(df, general_settings, optimization_settings)
        
        # Get the best result
        best_maturities = best_individual['maturities']
        best_nominals = best_individual['nominals']
        best_class_b_nominal = best_individual['class_b_nominal']
        best_class_b_percent = best_individual['class_b_percent']
        best_result = best_individual['result']
        
        # Get rates based on original data
        best_base_rates = [maturity_to_base_rate_A.get(get_nearest_maturity(m, original_maturities_A), 42.0) for m in best_maturities]
        best_reinvest_rates = [maturity_to_reinvest_rate_A.get(get_nearest_maturity(m, original_maturities_A), 30.0) for m in best_maturities]
        
        optimization_progress.update(step=90, 
                                message="Creating optimization result...")
        
        logger.info("Genetic optimization completed successfully")
        
        # Debug logging
        print(f"*** GENETIC OPTIMIZATION RESULTS ***")
        if best_result and best_result['results']:
            print(f"Class B coupon rate (effective): {best_result['results'].get('class_b_coupon_rate', 0)}")
            print(f"Class B coupon rate (direct): {best_result['results'].get('direct_coupon_rate', 0)}")
        print(f"Class B maturity: {class_b_maturity}")
        
        # Prepare the result from the best_result dictionary
        result_dict = best_result['results'] if best_result and best_result['results'] else {}
        
        # Final progress update to 100%
        optimization_progress.update(step=100, 
                                phase="Complete",
                                message="Genetic optimization completed successfully")
        
        # Return the optimization result with all necessary data
        return OptimizationResult(
            best_strategy="genetic",
            class_a_maturities=[int(m) for m in best_maturities],  # Ensure integers
            class_a_nominals=best_nominals,
            class_a_rates=best_base_rates,
            class_a_reinvest=best_reinvest_rates,
            class_b_maturity=int(class_b_maturity),
            class_b_rate=class_b_base_rate_orig,
            class_b_reinvest=class_b_reinvest_rate_orig,
            class_b_nominal=best_class_b_nominal,
            class_b_percent=best_class_b_percent,
            class_b_coupon_rate=result_dict.get('class_b_coupon_rate', 0),
            direct_class_b_coupon_rate=result_dict.get('direct_coupon_rate', 0),
            min_buffer_actual=result_dict.get('min_buffer_actual', 0),
            last_cash_flow_day=int(last_cash_flow_day),
            additional_days=int(additional_days),
            results_by_strategy={"genetic": result_dict}
        )
    except Exception as e:
        # Handle any exceptions
        logger.error(f"Error in genetic optimization: {str(e)}")
        logger.debug(traceback.format_exc())
        
        # Fall back to classic optimization
        optimization_progress.update(
            step=80,
            phase="Error Recovery",
            message=f"Error in genetic optimization: {str(e)}. Falling back to classic optimization method..."
        )
        return perform_optimization(df, general_settings, optimization_settings)

======================================================================

DOSYA: backend\app\services\stress_testing_service.py
==================================================
import pandas as pd
import numpy as np
from app.utils.tranche_utils import calculate_tranche_results
from typing import Dict, Any, List
from app.models.input_models import StressTestRequest
import logging

logger = logging.getLogger(__name__)

def adjust_cash_flow_for_npl(df: pd.DataFrame, npl_rate: float) -> pd.DataFrame:
    """
    Adjust cash flows by reducing principal payments based on NPL rate
    """
    try:
        df_adjusted = df.copy()
        
        # Ensure all required columns exist
        if 'principal_amount' not in df_adjusted.columns:
            logger.error("Missing 'principal_amount' column in DataFrame")
            raise ValueError("Missing 'principal_amount' column in data")
            
        if 'interest_amount' not in df_adjusted.columns:
            logger.error("Missing 'interest_amount' column in DataFrame")
            raise ValueError("Missing 'interest_amount' column in data")
            
        if 'cash_flow' not in df_adjusted.columns:
            logger.error("Missing 'cash_flow' column in DataFrame")
            raise ValueError("Missing 'cash_flow' column in data")
        
        # Convert npl_rate to a factor (e.g., 5% -> 0.05)
        npl_factor = npl_rate / 100.0
        
        # Reduce principal by NPL rate
        df_adjusted['principal_amount'] = df_adjusted['principal_amount'] * (1 - npl_factor)
        
        # Recalculate total cash flow
        df_adjusted['cash_flow'] = df_adjusted['principal_amount'] + df_adjusted['interest_amount']
        
        # Keep original cash flow for reference
        if 'original_cash_flow' not in df_adjusted.columns:
            df_adjusted['original_cash_flow'] = df['cash_flow'].copy()
        
        logger.info(f"Applied NPL rate of {npl_rate}%, reducing principal payments")
        return df_adjusted
        
    except Exception as e:
        logger.error(f"Error in adjust_cash_flow_for_npl: {str(e)}")
        raise ValueError(f"Failed to adjust cash flows for NPL rate: {str(e)}")

def adjust_cash_flow_for_prepayment(df: pd.DataFrame, prepayment_rate: float) -> pd.DataFrame:
    """
    Adjust cash flows by shifting some payments earlier based on prepayment rate
    """
    try:
        # If prepayment rate is zero or negative, no adjustment needed
        if prepayment_rate <= 0:
            return df
        
        df_adjusted = df.copy()
        
        # Ensure required columns exist
        if 'principal_amount' not in df_adjusted.columns:
            logger.error("Missing 'principal_amount' column in DataFrame")
            raise ValueError("Missing 'principal_amount' column in data")
            
        if 'installment_date' not in df_adjusted.columns:
            logger.error("Missing 'installment_date' column in DataFrame")
            raise ValueError("Missing 'installment_date' column in data")
        
        # Convert prepayment_rate to a factor
        prepayment_factor = prepayment_rate / 100.0
        
        # Sort by date
        if not pd.api.types.is_datetime64_any_dtype(df_adjusted['installment_date']):
            df_adjusted['installment_date'] = pd.to_datetime(df_adjusted['installment_date'])
            
        df_adjusted = df_adjusted.sort_values('installment_date')
        
        # Calculate running sum of principal
        total_principal = df_adjusted['principal_amount'].sum()
        
        # Calculate prepayment amount
        prepayment_amount = total_principal * prepayment_factor
        
        # Distribution function (more prepayments in early periods)
        n_rows = len(df_adjusted)
        if n_rows <= 1:
            logger.warning("Too few rows for prepayment adjustment")
            return df_adjusted
            
        prepayment_weights = np.linspace(3, 1, n_rows)
        prepayment_weights = prepayment_weights / prepayment_weights.sum()
        
        # Allocate prepayments by weight
        prepayment_allocations = prepayment_amount * prepayment_weights
        
        # Apply prepayments (reduce later periods, increase earlier periods)
        n = len(df_adjusted)
        reduction_indices = range(n//2, n)  # Reduce second half
        addition_indices = range(0, n//2)   # Add to first half
        
        # Reduce later payments (create a deep copy to avoid warnings)
        df_temp = df_adjusted.copy()
        for i in reduction_indices:
            if i < len(prepayment_allocations):
                max_reduction = df_temp.iloc[i]['principal_amount'] * 0.8
                reduction = min(prepayment_allocations[i], max_reduction)
                df_temp.iloc[i, df_temp.columns.get_loc('principal_amount')] -= reduction
        
        # Increase earlier payments
        for i in addition_indices:
            if i < len(prepayment_allocations):
                df_temp.iloc[i, df_temp.columns.get_loc('principal_amount')] += prepayment_allocations[i]
        
        # Update the adjusted dataframe
        df_adjusted = df_temp
        
        # Recalculate total cash flow
        if 'interest_amount' in df_adjusted.columns:
            df_adjusted['cash_flow'] = df_adjusted['principal_amount'] + df_adjusted['interest_amount']
            
        # Keep original cash flow for reference
        if 'original_cash_flow' not in df_adjusted.columns and 'cash_flow' in df.columns:
            df_adjusted['original_cash_flow'] = df['cash_flow'].copy()
        
        logger.info(f"Applied prepayment rate of {prepayment_rate}%, shifting principal payments")
        return df_adjusted
        
    except Exception as e:
        logger.error(f"Error in adjust_cash_flow_for_prepayment: {str(e)}")
        raise ValueError(f"Failed to adjust cash flows for prepayment rate: {str(e)}")

def perform_stress_test(df: pd.DataFrame, request: StressTestRequest) -> Dict[str, Any]:
    """
    Perform stress testing by adjusting cash flows and recalculating with the same structure
    """
    try:
        logger.info("Starting stress test calculation")
        
        # Extract parameters
        structure = request.structure
        scenario = request.scenario
        npl_rate = scenario.npl_rate
        prepayment_rate = scenario.prepayment_rate
        reinvestment_shift = scenario.reinvestment_shift
        
        # Log parameters for debugging
        logger.info(f"Scenario: {scenario.name}")
        logger.info(f"NPL Rate: {npl_rate}%, Prepayment Rate: {prepayment_rate}%, Reinvestment Shift: {reinvestment_shift}%")
        
        # First calculate baseline results with original data
        logger.info("Calculating baseline results")
        baseline_result = calculate_tranche_results(
            df, structure.start_date,
            structure.a_maturities, structure.a_base_rates, structure.a_spreads, structure.a_reinvest_rates,
            structure.a_nominals, structure.b_maturity, structure.b_base_rate, structure.b_spread,
            structure.b_reinvest_rate, structure.b_nominal, structure.ops_expenses
        )
        
        # Apply NPL rate
        df_adjusted = df.copy()
        if npl_rate > 0:
            logger.info(f"Adjusting cash flows for NPL rate: {npl_rate}%")
            df_adjusted = adjust_cash_flow_for_npl(df_adjusted, npl_rate)
        
        # Apply prepayment
        if prepayment_rate > 0:
            logger.info(f"Adjusting cash flows for prepayment rate: {prepayment_rate}%")
            df_adjusted = adjust_cash_flow_for_prepayment(df_adjusted, prepayment_rate)
        
        # Adjust reinvestment rates if shift is non-zero
        a_reinvest_rates = structure.a_reinvest_rates
        b_reinvest_rate = structure.b_reinvest_rate
        
        if reinvestment_shift != 0:
            logger.info(f"Applying reinvestment rate shift: {reinvestment_shift}%")
            a_reinvest_rates = [rate + reinvestment_shift for rate in structure.a_reinvest_rates]
            b_reinvest_rate = structure.b_reinvest_rate + reinvestment_shift
        
        # Calculate stress test results
        logger.info("Calculating stress test results")
        result = calculate_tranche_results(
            df_adjusted, structure.start_date,
            structure.a_maturities, structure.a_base_rates, structure.a_spreads, a_reinvest_rates,
            structure.a_nominals, structure.b_maturity, structure.b_base_rate, structure.b_spread,
            b_reinvest_rate, structure.b_nominal, structure.ops_expenses
        )
        
        # Create response
        response = {
            'baseline': {
                'class_b_coupon_rate': round(baseline_result['effective_coupon_rate'], 4),
                'min_buffer_actual': round(baseline_result.get('min_buffer_actual', 0), 4)
            },
            'stress_test': {
                'class_b_coupon_rate': round(result['effective_coupon_rate'], 4),
                'min_buffer_actual': round(result.get('min_buffer_actual', 0), 4),
                'npl_rate': npl_rate,
                'prepayment_rate': prepayment_rate,
                'reinvestment_shift': reinvestment_shift
            },
            'difference': {
                'class_b_coupon_rate': round(result['effective_coupon_rate'] - baseline_result['effective_coupon_rate'], 4),
                'min_buffer_actual': round(result.get('min_buffer_actual', 0) - baseline_result.get('min_buffer_actual', 0), 4)
            }
        }
        
        logger.info("Stress test completed successfully")
        logger.info(f"Baseline rate: {response['baseline']['class_b_coupon_rate']}%, Stress rate: {response['stress_test']['class_b_coupon_rate']}%")
        logger.info(f"Difference: {response['difference']['class_b_coupon_rate']}%")
        
        return response
        
    except Exception as e:
        logger.error(f"Error in perform_stress_test: {str(e)}")
        raise ValueError(f"Stress test calculation failed: {str(e)}")

======================================================================

DOSYA: backend\app\utils\cash_flow_utils.py
==================================================
"""
Utility functions for cash flow processing and tranche calculations.
"""
import pandas as pd
import numpy as np
from datetime import timedelta
from typing import List, Dict, Any, Tuple
from app.utils.finance_utils import (
    get_next_business_day,
    simple_to_compound_annual,
    calculate_reinvestment_date
)

def assign_cash_flows_to_tranches(
    df: pd.DataFrame, 
    start_date: pd.Timestamp, 
    all_maturity_dates: List[pd.Timestamp], 
    all_reinvest_rates: List[float]
) -> List[List[Dict[str, Any]]]:
    """
    Distribute cash flows into tranches, adjust for weekends,
    and calculate reinvestment returns.
    
    Args:
        df: DataFrame containing cash flow data
        start_date: Start date for calculations
        all_maturity_dates: List of maturity dates for each tranche
        all_reinvest_rates: List of reinvestment rates for each tranche
        
    Returns:
        List of cash flow lists for each tranche
    """
    num_tranches = len(all_maturity_dates)
    tranch_cash_flows = [[] for _ in range(num_tranches)]
    
    for idx, row in df.iterrows():
        inst_date = row['installment_date']
        cf = row['cash_flow']
        principal_amt = row.get('principal_amount', 0)
        interest_amt = row.get('interest_amount', 0)
        
        if pd.isnull(inst_date) or inst_date < start_date:
            continue
        
        reinvest_date = calculate_reinvestment_date(inst_date)
        assigned = False
        
        # First pass - assign to the first matching tranche
        for i in range(num_tranches):
            if inst_date < all_maturity_dates[i]:
                if reinvest_date < all_maturity_dates[i]:
                    days_diff = (all_maturity_dates[i] - reinvest_date).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        r_return = cf * factor
                    else:
                        r_return = 0.0
                    tranch_cash_flows[i].append({
                        'date': inst_date,
                        'cash_flow': cf,
                        'principal_amount': principal_amt,
                        'interest_amount': interest_amt,
                        'reinvest_date': reinvest_date,
                        'reinvestment_return': r_return,
                        'moved_from': None
                    })
                    assigned = True
                    break
        
        # If not assigned in first pass
        if not assigned and num_tranches > 0:
            # Second pass - assign based on reinvest date
            re_assign = False
            for i in range(num_tranches):
                if reinvest_date < all_maturity_dates[i]:
                    days_diff = (all_maturity_dates[i] - reinvest_date).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        r_return = cf * factor
                    else:
                        r_return = 0.0
                    tranch_cash_flows[i].append({
                        'date': inst_date,
                        'cash_flow': cf,
                        'principal_amount': principal_amt,
                        'interest_amount': interest_amt,
                        'reinvest_date': reinvest_date,
                        'reinvestment_return': r_return,
                        'moved_from': None
                    })
                    re_assign = True
                    break
            
            # If still not assigned, put in the last tranche
            if not re_assign:
                last_idx = num_tranches - 1
                days_diff = (all_maturity_dates[last_idx] - reinvest_date).days
                if days_diff > 0:
                    r_compound = simple_to_compound_annual(all_reinvest_rates[last_idx]) / 100.0
                    factor = (1 + r_compound)**(days_diff/365) - 1
                    r_return = cf * factor
                else:
                    r_return = 0.0
                tranch_cash_flows[last_idx].append({
                    'date': inst_date,
                    'cash_flow': cf,
                    'principal_amount': principal_amt,
                    'interest_amount': interest_amt,
                    'reinvest_date': reinvest_date,
                    'reinvestment_return': r_return,
                    'moved_from': None,
                    'note': 'Reinvestment date >= all'
                })
    
    # Third pass: if reinvest_date >= current tranche maturity, move the cash flow to a later tranche
    for i in range(num_tranches-1):
        final_cf = []
        for cf_info in tranch_cash_flows[i]:
            if cf_info['reinvest_date'] >= all_maturity_dates[i]:
                moved = False
                for j in range(i+1, num_tranches):
                    if cf_info['reinvest_date'] < all_maturity_dates[j]:
                        days_diff = (all_maturity_dates[j] - cf_info['reinvest_date']).days
                        if days_diff > 0:
                            r_compound = simple_to_compound_annual(all_reinvest_rates[j]) / 100.0
                            factor = (1 + r_compound)**(days_diff/365) - 1
                            new_ret = cf_info['cash_flow'] * factor
                        else:
                            new_ret = 0.0
                        new_cf = dict(cf_info)
                        new_cf['reinvestment_return'] = new_ret
                        new_cf['moved_from'] = i
                        tranch_cash_flows[j].append(new_cf)
                        moved = True
                        break
                
                if not moved and (i+1) < num_tranches:
                    last_i = num_tranches - 1
                    days_diff = (all_maturity_dates[last_i] - cf_info['reinvest_date']).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[last_i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        new_ret = cf_info['cash_flow'] * factor
                    else:
                        new_ret = 0.0
                    new_cf = dict(cf_info)
                    new_cf['reinvestment_return'] = new_ret
                    new_cf['moved_from'] = i
                    tranch_cash_flows[last_i].append(new_cf)
            else:
                final_cf.append(cf_info)
        
        tranch_cash_flows[i] = final_cf
    
    return tranch_cash_flows

def calculate_totals(
    cash_flows: List[Dict[str, Any]], 
    maturity_date: pd.Timestamp, 
    reinvest_rate: float
) -> Tuple[float, float, float, float]:
    """
    Calculate totals for a tranche.
    
    Args:
        cash_flows: List of cash flow information dictionaries
        maturity_date: Maturity date for the tranche
        reinvest_rate: Reinvestment rate for the tranche
        
    Returns:
        Tuple of (total_cash_flow, total_reinvest, total_principal, total_interest)
    """
    r_comp = simple_to_compound_annual(reinvest_rate)
    total_cash_flow = 0.0
    total_principal = 0.0
    total_interest = 0.0
    total_reinvest = 0.0
    
    for c in cash_flows:
        cf = c['cash_flow']
        principal = c.get('principal_amount', 0)
        interest = c.get('interest_amount', 0)
        
        total_cash_flow += cf
        total_principal += principal
        total_interest += interest
        
        rd = c['reinvest_date']
        days_diff = (maturity_date - rd).days
        
        if days_diff > 0:
            factor = (1 + r_comp/100)**(days_diff/365) - 1
            ret = cf * factor
            total_reinvest += ret
    
    return total_cash_flow, total_reinvest, total_principal, total_interest

======================================================================

DOSYA: backend\app\utils\finance_utils.py
==================================================
# backend/app/utils/finance_utils.py
import pandas as pd
from datetime import datetime, timedelta

def simple_to_compound_annual(simple_rate_percent):
    """Convert an annual simple rate (in %) to an annual compounded rate (in %)."""
    r_simple = simple_rate_percent / 100.0
    # daily rate under simple assumption:
    r_daily = r_simple / 365
    annual_compound = (1 + r_daily)**365 - 1
    return annual_compound * 100.0

def simple_to_maturity_compound(simple_rate_percent, days):
    """Convert a simple rate over 'days' to an equivalent annual compounded rate."""
    if days <= 0:
        return 0.0
    r_simple = simple_rate_percent / 100.0
    period_simple = r_simple * (days / 365)  # portion of the year
    period_compound = (1 + period_simple)**(365 / days) - 1
    return period_compound * 100.0

def overnight_to_annual_compound(simple_rate_percent):
    """Convert an annual simple rate to annual compound."""
    daily_rate = simple_rate_percent / 365 / 100
    annual_compound = (1 + daily_rate)**365 - 1
    return annual_compound * 100.0

def get_next_business_day(date):
    """If the date falls on a weekend, move it to the next business day."""
    while date.weekday() >= 5:  # 5=Saturday, 6=Sunday
        date += timedelta(days=1)
    return date

def calculate_reinvestment_date(installment_date):
    """Adjust the installment date for weekends and add 1 day."""
    if installment_date.weekday() >= 5:
        installment_date = get_next_business_day(installment_date)
    reinvest_date = installment_date + timedelta(days=1)
    reinvest_date = get_next_business_day(reinvest_date)
    return reinvest_date

def get_nearest_maturity(target_maturity, available_maturities):
    """Find the closest maturity day in the available maturities."""
    return min(available_maturities, key=lambda x: abs(x - target_maturity))

def get_last_cash_flow_day(df, start_date):
    """Find the last cash flow day and calculate as days from start date."""
    start_date = pd.Timestamp(start_date)
    last_cash_flow_date = df['installment_date'].max()
    
    if pd.notna(last_cash_flow_date):
        days = (last_cash_flow_date - start_date).days
        return max(0, days)  # Should not be negative
    else:
        return 365  # Default value

======================================================================

DOSYA: backend\app\utils\tranche_utils.py
==================================================
# backend/app/utils/tranche_utils.py
"""
Optimization ve Calculation servisleri arasÄ±nda ortak hesaplama
fonksiyonlarÄ±nÄ± iÃ§eren utility modÃ¼lÃ¼.
"""

import pandas as pd
import numpy as np
from typing import List, Dict, Any, Tuple, Optional
from app.utils.finance_utils import (
    simple_to_compound_annual,
    get_nearest_maturity
)
from app.utils.cash_flow_utils import (
    assign_cash_flows_to_tranches,
    calculate_totals
)

def calculate_tranche_results(
    df: pd.DataFrame,
    start_date: pd.Timestamp,
    a_maturities: List[int],
    a_base_rates: List[float],
    a_spreads: List[float],
    a_reinvest_rates: List[float],
    a_nominals: List[float],
    b_maturity: int,
    b_base_rate: float,
    b_spread: float,
    b_reinvest_rate: float,
    b_nominal: float,
    ops_expenses: float = 0.0
) -> Dict[str, Any]:
    """
    Hem optimization hem de calculation servislerinde kullanÄ±lacak
    ortak tranche hesaplama mantÄ±ÄŸÄ±nÄ± iÃ§erir.
    
    Args:
        df: Nakit akÄ±ÅŸÄ± verileri iÃ§eren DataFrame
        start_date: BaÅŸlangÄ±Ã§ tarihi
        a_maturities: Class A vadeleri (gÃ¼n)
        a_base_rates: Class A baz faiz oranlarÄ±
        a_spreads: Class A spread deÄŸerleri
        a_reinvest_rates: Class A yeniden yatÄ±rÄ±m oranlarÄ±
        a_nominals: Class A nominal deÄŸerleri
        b_maturity: Class B vadesi (gÃ¼n)
        b_base_rate: Class B baz faiz oranÄ±
        b_spread: Class B spread deÄŸeri
        b_reinvest_rate: Class B yeniden yatÄ±rÄ±m oranÄ±
        b_nominal: Class B nominal deÄŸeri
        ops_expenses: Operasyon giderleri
        
    Returns:
        HesaplanmÄ±ÅŸ sonuÃ§larÄ± iÃ§eren sÃ¶zlÃ¼k
    """
    # GeÃ§ici dataframe kopyasÄ±
    df_temp = df.copy()
    df_temp["cash_flow"] = df_temp["original_cash_flow"].copy()
    
    # Operasyonel giderleri dÃ¼ÅŸ (16 Åžubat 2025)
    if ops_expenses > 0:
        target_date = pd.Timestamp("2025-02-16")
        mask = df_temp["installment_date"].dt.date == target_date.date()
        if mask.any():
            idx = df_temp[mask].index[0]
            df_temp.at[idx, "cash_flow"] = max(0, df_temp.at[idx, "cash_flow"] - ops_expenses)
    
    # TÃ¼m parametreleri birleÅŸtir
    all_maturity_days = a_maturities + [b_maturity]
    all_base_rates = a_base_rates + [b_base_rate]
    all_spreads = a_spreads + [b_spread]
    all_reinvest_rates = a_reinvest_rates + [b_reinvest_rate]
    all_nominals = a_nominals + [b_nominal]
    all_maturity_dates = [start_date + pd.Timedelta(days=days) for days in all_maturity_days]
    
    # Nakit akÄ±ÅŸlarÄ±nÄ± tranchelere daÄŸÄ±t
    tranch_cash_flows = assign_cash_flows_to_tranches(
        df_temp, start_date, all_maturity_dates, all_reinvest_rates
    )
    
    # Tranche sonuÃ§larÄ±nÄ± hesapla
    results = []
    buffer = 0.0
    
    for i, days in enumerate(all_maturity_days):
        is_a = i < len(a_maturities)
        t_name = f"Class {'A' if is_a else 'B'}{i+1 if is_a else ''}".strip()
        
        # Nakit akÄ±ÅŸÄ±, reinvestment ve buffer hesapla
        c_flow, r_ret, total_principal, total_interest = calculate_totals(
            tranch_cash_flows[i], all_maturity_dates[i], all_reinvest_rates[i]
        )
        
        # Buffer faiz getirisi hesapla
        buf_reinv = 0.0
        if i > 0 and buffer > 0 and days > all_maturity_days[i-1]:
            factor = (1 + simple_to_compound_annual(all_reinvest_rates[i])/100)**(
                (days - all_maturity_days[i-1]) / 365
            ) - 1
            buf_reinv = buffer * factor
        
        # Toplam kullanÄ±labilir nakit
        available = c_flow + r_ret + buffer + buf_reinv
        nominal = all_nominals[i]
        
        # Faiz oranÄ± parametreleri
        base_rate = all_base_rates[i]
        spread = all_spreads[i]
        total_rate = base_rate + spread/100
        
        if is_a:
            # Class A iÃ§in hesaplama
            total_rate = base_rate + spread/100
            disc = 1 / (1 + total_rate/100 * days/365) if days else 1
            principal = nominal * disc
            interest = nominal - principal
            coupon = 0.0
            coupon_rate = 0.0
            eff_coupon = 0.0
            total_pay = nominal
        else:
            # Class B iÃ§in hesaplama
            principal = max(0.001, nominal)
            coupon = max(0, available - principal)
            interest = 0.0
            coupon_rate = coupon / principal * 100 if principal > 0.001 else 0.0
            eff_coupon = (coupon / principal * 365 / days * 100) if principal > 0.001 and days > 0 else 0.0
            total_pay = principal + coupon
        
        # Buffer hesapla
        new_buffer = max(0.0, available - total_pay)
        buf_ratio = new_buffer / nominal * 100 if nominal else 0.0
        
        # SonuÃ§larÄ± ekle
        results.append({
            "Tranche": t_name,
            "Start Date": start_date.strftime("%d/%m/%Y"),
            "Maturity Days": days,
            "Maturity Date": all_maturity_dates[i].strftime("%d/%m/%Y"),
            "Base Rate (%)": all_base_rates[i],
            "Spread (bps)": all_spreads[i],
            "Total Interest Rate (%)": total_rate,
            "Coupon Rate (%)": coupon_rate,
            "Effective Coupon (%)": eff_coupon,
            "Original Nominal": nominal,
            "Adjusted Nominal": nominal,
            "Buffer In": buffer,
            "Cash Flow Total": c_flow,
            "Reinvestment Return": r_ret,
            "Buffer Reinvestment": buf_reinv,
            "Total Available": available,
            "Principal": principal,
            "Interest": interest,
            "Coupon Payment": coupon,
            "Nominal Payment": nominal,
            "Total Payment": total_pay,
            "Buffer Out": new_buffer,
            "Buffer Cash Flow Ratio (%)": buf_ratio,
            "Discount Factor": 1.0,
            "Is Class A": is_a,
        })
        
        # Buffer gÃ¼ncelle
        buffer = new_buffer
    
    # SonuÃ§larÄ± Class A ve B olarak ayÄ±r
    a_results = [r for r in results if r["Is Class A"]]
    b_results = [r for r in results if not r["Is Class A"]]
    
    # ToplamalarÄ± hesapla
    class_a_principal = sum(r["Principal"] for r in a_results)
    class_b_principal = sum(r["Principal"] for r in b_results)
    class_a_interest = sum(r["Interest"] for r in a_results)
    class_b_coupon = sum(r["Coupon Payment"] for r in b_results)
    class_a_total = sum(r["Total Payment"] for r in a_results)
    class_b_total = sum(r["Total Payment"] for r in b_results)
    
    # En dÃ¼ÅŸÃ¼k buffer oranÄ±
    min_buffer_actual = min(r["Buffer Cash Flow Ratio (%)"] for r in a_results) if a_results else 0.0
    
    # Toplam Ã¶denen ve finans maliyeti
    total_principal_paid = class_a_principal + class_b_principal
    total_loan_principal = df_temp["principal_amount"].sum()
    financing_cost = total_principal_paid - total_loan_principal
    
    # Faiz oranÄ± dÃ¶nÃ¼ÅŸÃ¼m bilgileri
    rate_conversions = []
    for i, days in enumerate(all_maturity_days):
        is_a = i < len(a_maturities)
        t_name = f"Class {'A' if is_a else 'B'}{i+1 if is_a else ''}".strip()
        
        if is_a:
            # Class A tranches iÃ§in
            total_rate = all_base_rates[i] + all_spreads[i]/100
            simple_annual = total_rate
            compound_for_period = simple_to_maturity_compound(total_rate, days)
            reinvest_simple = all_reinvest_rates[i]
            reinvest_compound = overnight_to_annual_compound(all_reinvest_rates[i])
            coupon_rate = "-"
            eff_coupon_rate = "-"
        else:
            # Class B tranches iÃ§in
            coupon_rate = results[i]["Coupon Rate (%)"]
            eff_coupon_rate = results[i]["Effective Coupon (%)"]
            simple_annual = "-"
            compound_for_period = "-"
            reinvest_simple = all_reinvest_rates[i]
            reinvest_compound = overnight_to_annual_compound(all_reinvest_rates[i])
        
        rate_conversions.append({
            "Tranche": t_name,
            "Maturity Days": days,
            "Simple Annual Interest (%)": simple_annual,
            "Compound Interest for Period (%)": compound_for_period,
            "Reinvest Simple Annual (%)": reinvest_simple,
            "Reinvest O/N Compound (%)": reinvest_compound,
            "Coupon Rate (%)": coupon_rate,
            "Effective Coupon Rate (%)": eff_coupon_rate,
        })
    
    # DoÄŸrudan kupon oranÄ± ve efektif kupon oranÄ±
    direct_coupon_rate = results[-1]["Coupon Rate (%)"] if b_results else 0.0
    effective_coupon_rate = results[-1]["Effective Coupon (%)"] if b_results else 0.0
    
    # SonuÃ§larÄ± dÃ¶ndÃ¼r
    return {
        "tranche_results": results,
        "interest_rate_conversions": rate_conversions,
        "class_a_total": class_a_total,
        "class_b_total": class_b_total,
        "class_a_principal": class_a_principal,
        "class_b_principal": class_b_principal,
        "class_a_interest": class_a_interest,
        "class_b_coupon": class_b_coupon,
        "min_buffer_actual": min_buffer_actual,
        "total_principal_paid": total_principal_paid,
        "total_loan_principal": total_loan_principal,
        "financing_cost": financing_cost,
        "direct_coupon_rate": direct_coupon_rate,
        "effective_coupon_rate": effective_coupon_rate
    }

def simple_to_maturity_compound(simple_rate_percent, days):
    """Convert a simple rate over 'days' to an equivalent annual compounded rate."""
    if days <= 0:
        return 0.0
    r_simple = simple_rate_percent / 100.0
    period_simple = r_simple * (days / 365)  # portion of the year
    period_compound = (1 + period_simple)**(365 / days) - 1
    return period_compound * 100.0

def overnight_to_annual_compound(simple_rate_percent):
    """Convert an annual simple rate to annual compound."""
    daily_rate = simple_rate_percent / 365 / 100
    annual_compound = (1 + daily_rate)**365 - 1
    return annual_compound * 100.0

def adjust_class_a_nominals_for_target_coupon(
    df: pd.DataFrame,
    start_date: pd.Timestamp,
    a_maturities: List[int],
    a_nominals: List[float],
    a_base_rates: List[float],
    a_spreads: List[float],
    a_reinvest_rates: List[float],
    b_maturity: int,
    b_base_rate: float,
    b_spread: float,
    b_reinvest_rate: float,
    class_b_nominal: float,
    target_class_b_coupon_rate: float,
    target_class_b_percent: float,
    min_buffer: float,
    ops_expenses: float = 0.0,
    max_allowed_diff: float = 0.5,
    class_b_percent_deviation: float = 1.0,
    max_iterations: int = 30
) -> Tuple[List[float], bool, float]:
    """
    Class A nominal miktarlarÄ±nÄ± hedef Class B kupon oranÄ±na ulaÅŸacak ÅŸekilde
    ayarlar. Bu fonksiyon optimize ve hesaplama servisleri arasÄ±nda tutarlÄ±lÄ±k saÄŸlar.
    
    Args:
        df: Nakit akÄ±ÅŸÄ± verileri iÃ§eren DataFrame
        start_date: BaÅŸlangÄ±Ã§ tarihi
        a_maturities: Class A vadeleri (gÃ¼n)
        a_nominals: Class A nominal deÄŸerleri (baÅŸlangÄ±Ã§ deÄŸerleri)
        a_base_rates: Class A baz faiz oranlarÄ±
        a_spreads: Class A spread deÄŸerleri
        a_reinvest_rates: Class A yeniden yatÄ±rÄ±m oranlarÄ±
        b_maturity: Class B vadesi (gÃ¼n)
        b_base_rate: Class B baz faiz oranÄ±
        b_spread: Class B spread deÄŸeri
        b_reinvest_rate: Class B yeniden yatÄ±rÄ±m oranÄ±
        class_b_nominal: Class B nominal deÄŸeri
        target_class_b_coupon_rate: Hedef Class B kupon oranÄ±
        target_class_b_percent: Hedef Class B yÃ¼zdesi
        min_buffer: Minimum buffer gereksinimi
        ops_expenses: Operasyon giderleri
        max_allowed_diff: Ä°zin verilen maksimum fark
        class_b_percent_deviation: Ä°zin verilen Class B yÃ¼zde sapmasÄ±
        max_iterations: Maksimum iterasyon sayÄ±sÄ±
        
    Returns:
        (ayarlanmÄ±ÅŸ_nominal_listesi, baÅŸarÄ±_bayraÄŸÄ±, gerÃ§ek_class_b_yÃ¼zdesi)
    """
    # BaÅŸlangÄ±Ã§ parametreleri
    original_a_total = sum(a_nominals)
    original_proportions = [n / original_a_total for n in a_nominals]
    
    # Nominal kÄ±sÄ±tlamalarÄ±
    min_adjustment = 0.001  # Orijinalin %0.1'ine kadar dÃ¼ÅŸebilir
    max_adjustment = 3.0    # Orijinalin 3 katÄ±na kadar Ã§Ä±kabilir
    
    # SÄ±nÄ±rlarÄ± kontrol et
    b_maturity = max(1, min(365, b_maturity))
    
    # Class B yÃ¼zde hesapla
    total_nominal = original_a_total + class_b_nominal
    actual_class_b_percent = (class_b_nominal / total_nominal) * 100
    
    # Ä°lk deÄŸerlendirme
    result = calculate_tranche_results(
        df, start_date,
        a_maturities, a_base_rates, a_spreads, a_reinvest_rates, a_nominals,
        b_maturity, b_base_rate, b_spread, b_reinvest_rate, class_b_nominal,
        ops_expenses
    )
    
    baseline_coupon_rate = result['effective_coupon_rate']
    baseline_min_buffer = result['min_buffer_actual']
    baseline_direct_rate = result['direct_coupon_rate']
    
    # Ä°lk dÃ¼zeltme yaklaÅŸÄ±mÄ±
    if baseline_coupon_rate > 0:
        direct_adjustment = target_class_b_coupon_rate / baseline_coupon_rate
        direct_adjustment = max(min_adjustment, min(max_adjustment, direct_adjustment))
        
        test_nominals = [original_proportions[i] * original_a_total * direct_adjustment 
                       for i in range(len(a_nominals))]
        
        test_nominals = [max(1000, round(n / 1000) * 1000) for n in test_nominals]
        
        # DÃ¼zeltilmiÅŸ deÄŸerleri test et
        test_result = calculate_tranche_results(
            df, start_date,
            a_maturities, a_base_rates, a_spreads, a_reinvest_rates, test_nominals,
            b_maturity, b_base_rate, b_spread, b_reinvest_rate, class_b_nominal,
            ops_expenses
        )
        
        direct_coupon_rate = test_result['effective_coupon_rate']
        direct_min_buffer = test_result['min_buffer_actual']
        
        # Recalculate actual Class B percentage with adjusted Class A
        test_a_total = sum(test_nominals)
        test_total_nominal = test_a_total + class_b_nominal
        test_class_b_percent = (class_b_nominal / test_total_nominal) * 100
        
        # Check if Class B percentage is within allowed range
        min_class_b_percent = max(0.1, target_class_b_percent - class_b_percent_deviation)
        max_class_b_percent = min(50, target_class_b_percent + class_b_percent_deviation)
        is_class_b_percent_valid = min_class_b_percent <= test_class_b_percent <= max_class_b_percent
        
        # DoÄŸrudan yaklaÅŸÄ±m yeterince iyiyse kullan
        if direct_min_buffer >= min_buffer and abs(direct_coupon_rate - target_class_b_coupon_rate) <= max_allowed_diff and is_class_b_percent_valid:
            return test_nominals, True, test_class_b_percent
        
        # BaÅŸlangÄ±Ã§ â€‹â€‹deÄŸerini ayarla
        current_adjustment = direct_adjustment
        adjustment_direction = 1 if direct_coupon_rate < target_class_b_coupon_rate else -1
    else:
        current_adjustment = 1.0
        adjustment_direction = 0  # NÃ¶tr baÅŸla
    
    # BaÅŸlangÄ±Ã§ yÃ¶nÃ¼nÃ¼ belirle (direct_approach tarafÄ±ndan belirlenmemiÅŸse)
    if baseline_coupon_rate < target_class_b_coupon_rate and adjustment_direction == 0:
        adjustment_direction = 1  # ArttÄ±r
        current_adjustment = 1.2  # %20 artÄ±ÅŸla baÅŸla
    elif baseline_coupon_rate > target_class_b_coupon_rate and adjustment_direction == 0:
        adjustment_direction = -1  # Azalt
        
        # Hedeften uzaklÄ±ÄŸa gÃ¶re agresif ayarlama
        coupon_ratio = baseline_coupon_rate / target_class_b_coupon_rate
        if coupon_ratio > 10:
            current_adjustment = 0.01  # Orijinal boyutun %1'i
        elif coupon_ratio > 5:
            current_adjustment = 0.05  # Orijinal boyutun %5'i
        elif coupon_ratio > 2:
            current_adjustment = 0.1   # Orijinal boyutun %10'u
        else:
            current_adjustment = 0.5   # Orijinal boyutun %50'si
    
    best_diff = float('inf')
    best_nominals = a_nominals.copy()
    best_class_b_percent = actual_class_b_percent
    success = False
    
    # Ã–nceki sonuÃ§lar (enterpolasyon iÃ§in)
    last_adjustment = current_adjustment
    last_coupon_rate = baseline_coupon_rate
    
    # Ä°yileÅŸtirilmiÅŸ adaptif arama dÃ¶ngÃ¼sÃ¼
    for iteration in range(max_iterations):
        # Mevcut ayarlama faktÃ¶rÃ¼nÃ¼ uygula
        current_nominals = [original_proportions[i] * original_a_total * current_adjustment 
                           for i in range(len(a_nominals))]
        
        # 1000'e yuvarla ve sÄ±fÄ±r olmamasÄ±nÄ± saÄŸla
        current_nominals = [max(1000, round(n / 1000) * 1000) for n in current_nominals]
        
        # Mevcut ayarlamayÄ± deÄŸerlendir
        result = calculate_tranche_results(
            df, start_date,
            a_maturities, a_base_rates, a_spreads, a_reinvest_rates, current_nominals,
            b_maturity, b_base_rate, b_spread, b_reinvest_rate, class_b_nominal,
            ops_expenses
        )
        
        coupon_rate = result['effective_coupon_rate']
        min_buffer_actual = result['min_buffer_actual']
        
        # Calculate difference from target
        rate_diff = abs(coupon_rate - target_class_b_coupon_rate)
        
        # Calculate actual Class B percentage
        current_a_total = sum(current_nominals)
        current_total_nominal = current_a_total + class_b_nominal
        current_class_b_percent = (class_b_nominal / current_total_nominal) * 100
        percent_diff = abs(current_class_b_percent - target_class_b_percent)
        
        # Check if Class B percentage is within allowed range
        is_class_b_percent_valid = min_class_b_percent <= current_class_b_percent <= max_class_b_percent
        
        # Bu sonuÃ§ daha iyiyse ve buffer gereksinimini karÅŸÄ±lÄ±yorsa kaydet
        if min_buffer_actual >= min_buffer and is_class_b_percent_valid and rate_diff < best_diff:
            best_diff = rate_diff
            best_nominals = current_nominals.copy()
            best_class_b_percent = current_class_b_percent
            
            # Hedefe yakÄ±nsak, baÅŸarÄ± olarak kabul et
            if rate_diff <= max_allowed_diff:
                success = True
                
                # Hedefe Ã§ok yakÄ±nsa, erken Ã§Ä±k
                if rate_diff < 0.1:
                    break
        
        # Linear enterpolasyon ile daha iyi tahmin
        if iteration > 0 and last_coupon_rate != coupon_rate:
            if abs(current_adjustment - last_adjustment) > 0.000001:
                # Oran deÄŸiÅŸimi eÄŸimini hesapla
                rate_slope = (coupon_rate - last_coupon_rate) / (current_adjustment - last_adjustment)
                
                if abs(rate_slope) > 0.001:  # SÄ±fÄ±ra bÃ¶lÃ¼nmeyi Ã¶nle
                    # Hedefi vurmak iÃ§in gereken tahmini ayarlama
                    estimated_adjustment = last_adjustment + (target_class_b_coupon_rate - last_coupon_rate) / rate_slope
                    
                    # Makul sÄ±nÄ±rlar iÃ§inde tut
                    next_adjustment = max(min_adjustment, min(max_adjustment, estimated_adjustment))
                    
                    # Sadece Ã§ok uÃ§ deÄŸilse enterpolasyonu kullan
                    if 0.5 * current_adjustment <= next_adjustment <= 2.0 * current_adjustment:
                        # Mevcut deÄŸerleri kaydet
                        last_adjustment = current_adjustment
                        last_coupon_rate = coupon_rate
                        
                        # Enterpolasyon sonucu ayarla
                        current_adjustment = next_adjustment
                        continue
        
        # Sonraki enterpolasyon iÃ§in mevcut deÄŸerleri kaydet
        last_adjustment = current_adjustment
        last_coupon_rate = coupon_rate
        
        # SonuÃ§lara gÃ¶re adaptif ayarlama
        if coupon_rate < target_class_b_coupon_rate:
            if adjustment_direction == 1:
                # DoÄŸru yÃ¶ndeyiz (arttÄ±rÄ±yoruz), daha agresif ol
                coupon_ratio = target_class_b_coupon_rate / coupon_rate
                current_adjustment *= min(1.5, coupon_ratio)
            else:
                # Ã‡ok ileri gittik, yÃ¶n deÄŸiÅŸtir ve daha kÃ¼Ã§Ã¼k adÄ±m
                adjustment_direction = 1
                current_adjustment = 1.0 + (1.0 - current_adjustment) * 0.3
        else:  # coupon_rate > target_class_b_coupon_rate
            if adjustment_direction == -1:
                # DoÄŸru yÃ¶ndeyiz (azaltÄ±yoruz), daha agresif ol
                coupon_ratio = coupon_rate / target_class_b_coupon_rate
                current_adjustment *= max(0.5, 1/coupon_ratio)
            else:
                # Ã‡ok ileri gittik, yÃ¶n deÄŸiÅŸtir ve daha kÃ¼Ã§Ã¼k adÄ±m
                adjustment_direction = -1
                current_adjustment = 1.0 - (current_adjustment - 1.0) * 0.3
        
        # AyarlamanÄ±n sÄ±nÄ±rlar iÃ§inde olduÄŸundan emin ol
        current_adjustment = max(min_adjustment, min(max_adjustment, current_adjustment))
        
        # Ã‡ok kÃ¼Ã§Ã¼k deÄŸiÅŸiklikler yapÄ±yorsak ve takÄ±lÄ± kaldÄ±ysak erken Ã§Ä±k
        if abs(current_adjustment - last_adjustment) < 0.001 and iteration > 10:
            break
    
    return best_nominals, success, best_class_b_percent

======================================================================

