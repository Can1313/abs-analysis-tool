FRONTEND KLASÃ–R YAPISI:
======================

ðŸ“¦src
  â”£ ðŸ“œApp.js
  â”£ ðŸ“œindex.css
  â”£ ðŸ“œindex.js
  â”£ ðŸ“‚components
    â”£ ðŸ“œFileUploader.js
    â”£ ðŸ“œFooter.js
    â”£ ðŸ“œTopBar.js
    â”£ ðŸ“‚calculation
      â”£ ðŸ“œCalculationResults.js
      â”£ ðŸ“œGeneralSettingsForm.js
      â”£ ðŸ“œInterestRatesTable.js
      â”£ ðŸ“œTrancheAForm.js
      â”£ ðŸ“œTrancheBForm.js
    â”£ ðŸ“‚optimization
      â”£ ðŸ“œOptimizationProgress.js
      â”£ ðŸ“œOptimizationResults.js
      â”£ ðŸ“œOptimizationSettingsForm.js
  â”£ ðŸ“‚contexts
    â”£ ðŸ“œDataContext.js
  â”£ ðŸ“‚pages
    â”£ ðŸ“œCalculationPage.js
    â”£ ðŸ“œCalculationResults.js
    â”£ ðŸ“œComparisonPage.js
    â”£ ðŸ“œHomePage.js
    â”£ ðŸ“œOptimizationPage.js
  â”£ ðŸ“‚services
    â”£ ðŸ“œapiService.js


BACKEND KLASÃ–R YAPISI:
=====================

ðŸ“¦backend
  â”£ ðŸ“œDockerfile
  â”£ ðŸ“œrequirements.txt
  â”£ ðŸ“‚app
    â”£ ðŸ“œmain.py
    â”£ ðŸ“œ__init__.py
    â”£ ðŸ“‚models
      â”£ ðŸ“œinput_models.py
      â”£ ðŸ“œoutput_models.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚routers
      â”£ ðŸ“œcalculation.py
      â”£ ðŸ“œoptimization.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚services
      â”£ ðŸ“œcalculation_service.py
      â”£ ðŸ“œoptimization_service.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚utils
      â”£ ðŸ“œcash_flow_utils.py
      â”£ ðŸ“œfinance_utils.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚__pycache__


FRONTEND DOSYALARI VE Ä°Ã‡ERÄ°KLERÄ°:
===============================

DOSYA: src\App.js
==================================================
// src/App.js
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";

import TopBar from "./components/TopBar";
import Footer from "./components/Footer";
import HomePage from "./pages/HomePage";
import CalculationPage from "./pages/CalculationPage";
import OptimizationPage from "./pages/OptimizationPage";
import { DataProvider } from "./contexts/DataContext";
import ComparisonPage from "./pages/ComparisonPage";



const theme = createTheme({
  palette: {
    primary: {
      main: '#1976d2', // More professional blue
      light: '#4791db',
      dark: '#115293',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#26a69a', // Teal - more business-like than green
      light: '#51b7ae',
      dark: '#00766c',
      contrastText: '#ffffff',
    },
    error: {
      main: '#d32f2f',
      light: '#ef5350',
      dark: '#c62828',
    },
    warning: {
      main: '#ed6c02',
      light: '#ff9800',
      dark: '#e65100',
    },
    info: {
      main: '#0288d1',
      light: '#03a9f4',
      dark: '#01579b',
    },
    success: {
      main: '#2e7d32',
      light: '#4caf50',
      dark: '#1b5e20',
    },
    background: {
      default: '#f5f7fa',
      paper: '#ffffff',
    },
    text: {
      primary: '#2c3e50',
      secondary: '#546e7a',
    },
    divider: 'rgba(0, 0, 0, 0.12)',
  },
  typography: {
    fontFamily: '"Roboto", "Segoe UI", "Helvetica Neue", sans-serif',
    h4: {
      fontWeight: 500,
    },
    h5: {
      fontWeight: 500,
    },
    h6: {
      fontWeight: 500,
    },
    subtitle1: {
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiPaper: {
      styleOverrides: {
        root: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.04)',
          borderRadius: 8,
        },
        elevation1: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.04)',
        },
        elevation2: {
          boxShadow: '0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12)',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          fontWeight: 500,
          borderRadius: 6,
        },
        contained: {
          boxShadow: '0 1px 2px rgba(0,0,0,0.15)',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        head: {
          fontWeight: 600,
          backgroundColor: 'rgba(0, 0, 0, 0.03)',
        },
      },
    },
    MuiTableRow: {
      styleOverrides: {
        root: {
          '&:last-child td': {
            borderBottom: 0,
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.04)',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 6,
        },
      },
    },
  },
});

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <DataProvider>
        <Router>
          <TopBar />
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/calculation" element={<CalculationPage />} />
            <Route path="/optimization" element={<OptimizationPage />} />
            <Route path="/comparison" element={<ComparisonPage />} />
          </Routes>
          <Footer />
        </Router>
      </DataProvider>
    </ThemeProvider>
  );
}

export default App;

======================================================================

DOSYA: src\index.css
==================================================
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

======================================================================

DOSYA: src\index.js
==================================================
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

======================================================================

DOSYA: src\components\FileUploader.js
==================================================
// src/components/FileUploader.js
import React, { useState } from "react";
import { 
  Box, 
  Button, 
  Typography, 
  Alert, 
  Paper, 
  CircularProgress,
  alpha
} from "@mui/material";
import UploadFileIcon from "@mui/icons-material/UploadFile";
import FileUploadOutlinedIcon from "@mui/icons-material/FileUploadOutlined";
import DescriptionOutlinedIcon from "@mui/icons-material/DescriptionOutlined";
import { uploadFile } from "../services/apiService";
import { useData } from "../contexts/DataContext";

const FileUploader = () => {
  const { setCashFlowData, setIsLoading, setError, isLoading, error, cashFlowData } = useData();

  const [file, setFile] = useState(null);
  const [dragActive, setDragActive] = useState(false);

  const handleDrag = (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      setFile(e.dataTransfer.files[0]);
    }
  };

  const handleChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setFile(e.target.files[0]);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!file) return;
    
    try {
      setIsLoading(true);
      setError(null);
      
      const data = await uploadFile(file);
      setCashFlowData(data);
    } catch (error) {
      setError('Failed to upload file. Please check the file format and try again.');
      console.error('Upload error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Box sx={{ width: '100%', maxWidth: 700, mx: 'auto', my: 3 }}>
      {error && (
        <Alert 
          severity="error" 
          sx={{ 
            mb: 3, 
            borderRadius: 2,
            '& .MuiAlert-icon': {
              alignItems: 'center'
            }
          }}
        >
          {error}
        </Alert>
      )}
      
      <form onSubmit={handleSubmit}>
        <Box
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
          sx={{
            border: '2px dashed',
            borderColor: dragActive ? 'primary.main' : (theme) => theme.palette.grey[300],
            borderRadius: 2,
            p: 4,
            mb: 3,
            textAlign: 'center',
            cursor: 'pointer',
            transition: 'all 0.2s ease-in-out',
            backgroundColor: dragActive 
              ? (theme) => alpha(theme.palette.primary.main, 0.08)
              : (theme) => alpha(theme.palette.background.paper, 0.5),
            '&:hover': {
              borderColor: 'primary.main',
              backgroundColor: (theme) => alpha(theme.palette.primary.main, 0.04)
            }
          }}
          onClick={() => document.getElementById('file-upload').click()}
        >
          <input
            type="file"
            id="file-upload"
            accept=".xlsx,.xls"
            onChange={handleChange}
            style={{ display: 'none' }}
          />
          {!file ? (
            <>
              <FileUploadOutlinedIcon sx={{ fontSize: 60, color: 'primary.main', mb: 2, opacity: 0.8 }} />
              <Typography variant="h6" gutterBottom fontWeight="medium" color="primary.main">
                Drag and drop your Excel file here
              </Typography>
              <Typography variant="body1" color="text.secondary">
                or click to browse files
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 2, opacity: 0.7 }}>
                Supported formats: .xlsx, .xls
              </Typography>
            </>
          ) : (
            <>
              <DescriptionOutlinedIcon sx={{ fontSize: 50, color: 'primary.main', mb: 2 }} />
              <Typography variant="h6" gutterBottom color="primary.main">
                File selected
              </Typography>
              <Typography variant="body1" fontWeight="medium">
                {file.name}
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Size: {(file.size / 1024).toFixed(1)} KB
              </Typography>
              <Typography variant="body2" color="primary.main" sx={{ mt: 2 }}>
                Click to select a different file
              </Typography>
            </>
          )}
        </Box>
        
        <Button
          type="submit"
          variant="contained"
          color="primary"
          fullWidth
          disabled={!file || isLoading}
          size="large"
          sx={{
            py: 1.5,
            fontWeight: 500,
            boxShadow: 2,
            '&:hover': {
              boxShadow: 3
            }
          }}
          startIcon={isLoading ? <CircularProgress size={24} color="inherit" /> : <UploadFileIcon />}
        >
          {isLoading ? 'Processing...' : 'Upload and Process'}
        </Button>
      </form>
      
      {/* Display data summary after upload */}
      {cashFlowData && !isLoading && !error && (
        <Paper 
          elevation={0} 
          sx={{ 
            mt: 4, 
            p: 3, 
            borderRadius: 2,
            border: (theme) => `1px solid ${alpha(theme.palette.success.main, 0.3)}`,
            backgroundColor: (theme) => alpha(theme.palette.success.main, 0.05)
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <DescriptionOutlinedIcon sx={{ color: 'success.main', mr: 1 }} />
            <Typography variant="h6" color="success.main" fontWeight="medium">
              File Uploaded Successfully
            </Typography>
          </Box>
          
          <Box sx={{ 
            mt: 2,
            p: 2,
            backgroundColor: 'background.paper',
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle2" gutterBottom color="text.secondary">
              Summary
            </Typography>
            
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 3, mt: 1 }}>
              <Box>
                <Typography variant="body2" color="text.secondary">Total Records</Typography>
                <Typography variant="h6">{cashFlowData.total_records}</Typography>
              </Box>
              
              <Box>
                <Typography variant="body2" color="text.secondary">Total Principal</Typography>
                <Typography variant="h6">{new Intl.NumberFormat('tr-TR', { style: 'currency', currency: 'TRY' }).format(cashFlowData.total_principal)}</Typography>
              </Box>
              
              <Box>
                <Typography variant="body2" color="text.secondary">Total Interest</Typography>
                <Typography variant="h6">{new Intl.NumberFormat('tr-TR', { style: 'currency', currency: 'TRY' }).format(cashFlowData.total_interest)}</Typography>
              </Box>
              
              <Box>
                <Typography variant="body2" color="text.secondary">Total Cash Flow</Typography>
                <Typography variant="h6">{new Intl.NumberFormat('tr-TR', { style: 'currency', currency: 'TRY' }).format(cashFlowData.total_cash_flow)}</Typography>
              </Box>
            </Box>
            
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              <b>Date Range:</b> {cashFlowData.date_range[0]} - {cashFlowData.date_range[1]}
            </Typography>
          </Box>
        </Paper>
      )}
    </Box>
  );
};

export default FileUploader;

======================================================================

DOSYA: src\components\Footer.js
==================================================
// frontend/src/components/Footer.js
import React from 'react';
import { Box, Typography, Container, Link } from '@mui/material';

const Footer = () => {
  return (
    <Box
      component="footer"
      sx={{
        py: 3,
        px: 2,
        mt: 'auto',
        backgroundColor: (theme) => theme.palette.grey[200],
      }}
    >
      <Container maxWidth="lg">
        <Typography variant="body2" color="text.secondary" align="center">
          Â© {new Date().getFullYear()} ABS Analysis Tool
        </Typography>
      </Container>
    </Box>
  );
};

export default Footer;

======================================================================

DOSYA: src\components\TopBar.js
==================================================
// frontend/src/components/TopBar.js
import React from 'react';
import { Link as RouterLink, useLocation } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button, Box, Container } from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import OptimizeIcon from '@mui/icons-material/Speed';
import HomeIcon from '@mui/icons-material/Home';
import CompareIcon from '@mui/icons-material/Compare';
import { alpha } from '@mui/material/styles';


const TopBar = () => {
  const location = useLocation();
  
  return (
    <AppBar position="static" color="primary" elevation={0}>
      <Container maxWidth="lg">
        <Toolbar disableGutters>
          <Typography
            variant="h6"
            component={RouterLink}
            to="/"
            sx={{
              flexGrow: 1,
              textDecoration: 'none',
              color: 'inherit',
              display: 'flex',
              alignItems: 'center',
              fontWeight: 600,
            }}
          >
            ABS Analysis Tool
          </Typography>
          
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button 
              color="inherit" 
              component={RouterLink} 
              to="/"
              startIcon={<HomeIcon />}
              sx={{
                px: 2,
                py: 1,
                borderRadius: 1,
                backgroundColor: location.pathname === '/' ? alpha('#fff', 0.15) : 'transparent',
                '&:hover': {
                  backgroundColor: location.pathname === '/' ? alpha('#fff', 0.25) : alpha('#fff', 0.1),
                }
              }}
            >
              Home
            </Button>
            
            <Button 
              color="inherit" 
              component={RouterLink} 
              to="/calculation"
              startIcon={<CalculateIcon />}
              sx={{
                px: 2,
                py: 1,
                borderRadius: 1,
                backgroundColor: location.pathname === '/calculation' ? alpha('#fff', 0.15) : 'transparent',
                '&:hover': {
                  backgroundColor: location.pathname === '/calculation' ? alpha('#fff', 0.25) : alpha('#fff', 0.1),
                }
              }}
            >
              Calculate
            </Button>
            
            <Button 
              color="inherit" 
              component={RouterLink} 
              to="/optimization"
              startIcon={<OptimizeIcon />}
              sx={{
                px: 2,
                py: 1,
                borderRadius: 1,
                backgroundColor: location.pathname === '/optimization' ? alpha('#fff', 0.15) : 'transparent',
                '&:hover': {
                  backgroundColor: location.pathname === '/optimization' ? alpha('#fff', 0.25) : alpha('#fff', 0.1),
                }
              }}
            >
              Optimize
            </Button>
            <Button 
              color="inherit" 
              component={RouterLink} 
              to="/comparison"
              startIcon={<CompareIcon />}
              sx={{
                px: 2,
                py: 1,
                borderRadius: 1,
                backgroundColor: location.pathname === '/comparison' ? alpha('#fff', 0.15) : 'transparent',
                '&:hover': {
                  backgroundColor: location.pathname === '/comparison' ? alpha('#fff', 0.25) : alpha('#fff', 0.1),
                }
              }}
            >
              Compare
            </Button>
          </Box>
        </Toolbar>
      </Container>
    </AppBar>
  );
};

export default TopBar;

======================================================================

DOSYA: src\components\calculation\CalculationResults.js
==================================================
// src/components/calculation/CalculationResults.js
import React from "react";
import { 
  Box, 
  Typography, 
  Paper,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Divider,
  Chip,
  alpha
} from "@mui/material";
import { useTheme } from "@mui/material/styles";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts";
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';

const CalculationResults = ({ results }) => {
  const theme = useTheme();
  
  if (!results) {
    return (
      <Paper sx={{ 
        p: 4, 
        textAlign: "center", 
        borderRadius: 2,
        backgroundColor: alpha(theme.palette.info.light, 0.08),
        border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`
      }}>
        <Typography variant="h6" color="text.secondary" gutterBottom>
          Results Not Available
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Please start the calculation process to view results
        </Typography>
      </Paper>
    );
  }
  
  // Format currency values
  const formatCurrency = (value) => {
    if (value === undefined || value === null) return "â‚º0.00";
    return new Intl.NumberFormat("tr-TR", { style: "currency", currency: "TRY" }).format(value);
  };
  
  // Format percentage values with null check
  const formatPercent = (value) => {
    if (value === undefined || value === null) return "0.00%";
    return `${value.toFixed(2)}%`;
  };

  // Extract color values from theme
  const classAColor = theme.palette.primary.main;
  const classBColor = theme.palette.secondary.main;
  
  // Prepare data for tranche comparison chart
  const chartData = [
    {
      name: "Class A",
      principal: results.class_a_principal || 0,
      interest: results.class_a_interest || 0,
      total: results.class_a_total || 0,
    },
    {
      name: "Class B",
      principal: results.class_b_principal || 0,
      coupon: results.class_b_coupon || 0,
      total: results.class_b_total || 0,
    },
  ];

  // Calculate totals with null checks
  const totalClassA = results.class_a_total || 0;
  const totalClassB = results.class_b_total || 0;
  const totalAll = totalClassA + totalClassB;
  
  // Check if minimum buffer requirement is met
  const minBufferTarget = 5.0;
  const isBufferMet = (results.min_buffer_actual || 0) >= minBufferTarget;

  return (
    <Box>
      {/* Summary Section */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.primary.main, 0.03)
        }}
      >
        <Typography variant="h6" color="primary.main" gutterBottom fontWeight="medium">
          Calculation Results Summary
        </Typography>
        
        <Box sx={{ display: "flex", flexWrap: "wrap", gap: 3, mt: 2 }}>
          <Box sx={{ 
            flex: "1 0 300px", 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle1" gutterBottom color="text.secondary">
              Payment Totals
            </Typography>
            <TableContainer sx={{ mt: 1 }}>
              <Table size="small">
                <TableBody>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Class A Total</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(totalClassA)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Chip 
                        size="small" 
                        label={formatPercent(totalAll > 0 ? (totalClassA / totalAll * 100) : 0)}
                        sx={{ 
                          bgcolor: alpha(theme.palette.primary.main, 0.1),
                          color: theme.palette.primary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Class B Total</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(totalClassB)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Chip 
                        size="small" 
                        label={formatPercent(totalAll > 0 ? (totalClassB / totalAll * 100) : 0)}
                        sx={{ 
                          bgcolor: alpha(theme.palette.secondary.main, 0.1),
                          color: theme.palette.secondary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                  <TableRow sx={{ "& td": { fontWeight: 600 } }}>
                    <TableCell sx={{ pl: 0 }}>Grand Total</TableCell>
                    <TableCell align="right">{formatCurrency(totalAll)}</TableCell>
                    <TableCell align="right">
                      <Chip 
                        size="small" 
                        label="100.00%"
                        sx={{ 
                          bgcolor: alpha(theme.palette.info.main, 0.1),
                          color: theme.palette.info.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
          
          <Box sx={{ 
            flex: "1 0 300px", 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle1" gutterBottom color="text.secondary">
              Principal and Interest
            </Typography>
            <TableContainer sx={{ mt: 1 }}>
              <Table size="small">
                <TableBody>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: classAColor,
                            mr: 1 
                          }} 
                        />
                        Class A
                      </Box>
                    </TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_a_principal)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_a_interest)}</TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: classBColor,
                            mr: 1 
                          }} 
                        />
                        Class B
                      </Box>
                    </TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_b_principal)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_b_coupon)}</TableCell>
                  </TableRow>
                  <TableRow sx={{ "& td": { fontWeight: 600 } }}>
                    <TableCell sx={{ pl: 0 }}>Total</TableCell>
                    <TableCell align="right">
                      {formatCurrency((results.class_a_principal || 0) + (results.class_b_principal || 0))}
                    </TableCell>
                    <TableCell align="right">
                      {formatCurrency((results.class_a_interest || 0) + (results.class_b_coupon || 0))}
                    </TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
        </Box>
        
        <Divider sx={{ my: 3, opacity: 0.6 }} />
        
        <Box sx={{ 
          display: 'flex', 
          gap: 4, 
          flexWrap: 'wrap',
          backgroundColor: isBufferMet ? alpha(theme.palette.success.main, 0.08) : alpha(theme.palette.error.main, 0.08),
          p: 2,
          borderRadius: 1
        }}>
          <Box>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Minimum Buffer Requirement
            </Typography>
            <Typography variant="h6" sx={{ mt: 0.5 }}>
              {formatPercent(minBufferTarget)}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Actual Minimum Buffer (Class A)
            </Typography>
            <Typography variant="h6" color={isBufferMet ? "success.main" : "error.main"} sx={{ mt: 0.5 }}>
              {formatPercent(results.min_buffer_actual)}
            </Typography>
          </Box>
          
          <Box sx={{ ml: 'auto' }}>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Status
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
              {isBufferMet ? (
                <CheckCircleOutlineIcon color="success" sx={{ mr: 1 }} />
              ) : (
                <ErrorOutlineIcon color="error" sx={{ mr: 1 }} />
              )}
              <Typography 
                variant="h6" 
                color={isBufferMet ? "success.main" : "error.main"}
              >
                {isBufferMet ? "Requirement Met" : "Requirement Not Met"}
              </Typography>
            </Box>
          </Box>
        </Box>
      </Paper>
      
      {/* Financing Cost Analysis */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.info.main, 0.03)
        }}
      >
        <Typography variant="h6" color="info.main" gutterBottom fontWeight="medium">
          Financing Cost Analysis
        </Typography>
        
        <TableContainer sx={{ 
          mt: 2,
          bgcolor: 'background.paper', 
          borderRadius: 1,
          boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
        }}>
          <Table>
            <TableBody>
              <TableRow>
                <TableCell sx={{ pl: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Total Principal Paid to Bank:</TableCell>
                <TableCell align="right" sx={{ fontWeight: 600, pr: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                  {formatCurrency(results.total_principal_paid)}
                </TableCell>
              </TableRow>
              <TableRow>
                <TableCell sx={{ pl: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Total Loan Principal:</TableCell>
                <TableCell align="right" sx={{ pr: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                  {formatCurrency(results.total_loan_principal)}
                </TableCell>
              </TableRow>
              <TableRow>
                <TableCell sx={{ pl: 2, fontWeight: 600 }}>
                  Financing {(results.financing_cost || 0) > 0 ? "Profit" : "Loss"}:
                </TableCell>
                <TableCell 
                  align="right" 
                  sx={{ 
                    fontWeight: 600,
                    pr: 2,
                    color: (results.financing_cost || 0) > 0 ? "success.main" : "error.main"
                  }}
                >
                  {formatCurrency(Math.abs(results.financing_cost || 0))}
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
      
      {/* Tranche Results Chart */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
          backgroundColor: 'background.paper'
        }}
      >
        <Typography variant="h6" gutterBottom fontWeight="medium">
          Tranche Comparison
        </Typography>
        
        <Box sx={{ height: 400, mt: 3 }}>
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip 
                formatter={(value) => formatCurrency(value)}
                contentStyle={{
                  borderRadius: 8,
                  border: 'none',
                  boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                }}
              />
              <Legend />
              <Bar 
                dataKey="principal" 
                name="Principal" 
                stackId="a" 
                fill={theme.palette.primary.main}
                radius={[4, 4, 0, 0]}
              />
              <Bar 
                dataKey="interest" 
                name="Interest" 
                stackId="a" 
                fill={theme.palette.primary.light}
                radius={[4, 4, 0, 0]}
              />
              <Bar 
                dataKey="coupon" 
                name="Coupon" 
                stackId="a" 
                fill={theme.palette.secondary.main}
                radius={[4, 4, 0, 0]}
              />
            </BarChart>
          </ResponsiveContainer>
        </Box>
      </Paper>
      
      {/* Detailed Results Table */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
          backgroundColor: 'background.paper'
        }}
      >
        <Typography variant="h6" gutterBottom fontWeight="medium">
          Detailed Tranche Results
        </Typography>
        
        {results.tranche_results && results.tranche_results.length > 0 ? (
          <TableContainer sx={{ 
            maxHeight: 440,
            mt: 2,
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Table stickyHeader>
              <TableHead>
                <TableRow>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Tranche</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Days</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Date</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Principal</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Interest / Coupon</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Total Payment</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Buffer Ratio (%)</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {results.tranche_results.map((tranche, index) => (
                  <TableRow 
                    key={index}
                    sx={{ 
                      backgroundColor: tranche["Is Class A"] 
                        ? alpha(theme.palette.primary.main, 0.03)
                        : alpha(theme.palette.secondary.main, 0.03),
                      '&:hover': {
                        backgroundColor: tranche["Is Class A"] 
                          ? alpha(theme.palette.primary.main, 0.07)
                          : alpha(theme.palette.secondary.main, 0.07),
                      }
                    }}
                  >
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: tranche["Is Class A"] ? classAColor : classBColor,
                            mr: 1 
                          }} 
                        />
                        {tranche["Tranche"]}
                      </Box>
                    </TableCell>
                    <TableCell>{tranche["Maturity Days"]}</TableCell>
                    <TableCell>{tranche["Maturity Date"]}</TableCell>
                    <TableCell>{formatCurrency(tranche["Principal"])}</TableCell>
                    <TableCell>
                      {formatCurrency(
                        tranche["Is Class A"] ? tranche["Interest"] : tranche["Coupon Payment"]
                      )}
                    </TableCell>
                    <TableCell>{formatCurrency(tranche["Total Payment"])}</TableCell>
                    <TableCell>
                      <Chip 
                        size="small" 
                        label={formatPercent(tranche["Buffer Cash Flow Ratio (%)"])}
                        sx={{ 
                          bgcolor: 
                            tranche["Buffer Cash Flow Ratio (%)"] >= minBufferTarget
                              ? alpha(theme.palette.success.main, 0.1)
                              : alpha(theme.palette.warning.main, 0.1),
                          color: 
                            tranche["Buffer Cash Flow Ratio (%)"] >= minBufferTarget
                              ? theme.palette.success.main
                              : theme.palette.warning.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        ) : (
          <Typography variant="body2" color="text.secondary" sx={{ py: 3, textAlign: "center" }}>
            Detailed results are not available yet
          </Typography>
        )}
      </Paper>
    </Box>
  );
};

export default CalculationResults;

======================================================================

DOSYA: src\components\calculation\GeneralSettingsForm.js
==================================================
// frontend/src/components/calculation/GeneralSettingsForm.js
import React from 'react';
import { Box, Typography, TextField, Paper, Button } from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { useData } from '../../contexts/DataContext';

const GeneralSettingsForm = () => {
  const { generalSettings, setGeneralSettings } = useData();

  const handleChange = (field, value) => {
    setGeneralSettings({
      ...generalSettings,
      [field]: value,
    });
  };

  return (
    <Paper sx={{ p: 3, mb: 3 }}>
      <Typography variant="h6" gutterBottom>
        General Settings
      </Typography>
      
      <Box sx={{ mt: 2 }}>
        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <DatePicker
            label="Start Date"
            value={generalSettings.start_date}
            onChange={(newValue) => handleChange('start_date', newValue)}
            renderInput={(params) => <TextField {...params} fullWidth margin="normal" />}
          />
        </LocalizationProvider>
        
        <TextField
          fullWidth
          margin="normal"
          id="operational_expenses"
          label="Operational Expenses (â‚º)"
          type="number"
          value={generalSettings.operational_expenses}
          onChange={(e) => handleChange('operational_expenses', parseFloat(e.target.value))}
          InputProps={{
            inputProps: { min: 0, step: 1000 }
          }}
        />
        
        <TextField
          fullWidth
          margin="normal"
          id="min_buffer"
          label="Minimum Buffer (%)"
          type="number"
          value={generalSettings.min_buffer}
          onChange={(e) => handleChange('min_buffer', parseFloat(e.target.value))}
          InputProps={{
            inputProps: { min: 0, step: 0.5 }
          }}
        />
      </Box>
    </Paper>
  );
};

export default GeneralSettingsForm;

======================================================================

DOSYA: src\components\calculation\InterestRatesTable.js
==================================================
// frontend/src/components/calculation/InterestRatesTable.js
import React from 'react';
import { 
  Box, 
  Typography, 
  Paper,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  alpha,
  Chip
} from '@mui/material';
import { useTheme } from '@mui/material/styles';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

const InterestRatesTable = ({ results }) => {
  const theme = useTheme();
  
  // Format value function (handles '-' or number)
  const formatValue = (value) => {
    if (value === '-') return value;
    return `${parseFloat(value).toFixed(2)}%`;
  };

  // Prepare data for rates chart
  const chartData = results.interest_rate_conversions
    .filter(rate => rate.Tranche.includes('Class A'))
    .map(rate => ({
      name: rate.Tranche,
      rate: rate['Simple Annual Interest (%)'] === '-' ? 0 : rate['Simple Annual Interest (%)'],
    }))
    .concat(
      results.interest_rate_conversions
        .filter(rate => rate.Tranche.includes('Class B'))
        .map(rate => ({
          name: rate.Tranche,
          rate: rate['Effective Coupon Rate (%)'] === '-' ? 0 : rate['Effective Coupon Rate (%)'],
        }))
    );

  return (
    <Box>
      {/* Class B Coupon Information */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.secondary.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.secondary.main, 0.05),
          borderRadius: 2
        }}
      >
        <Typography variant="h6" gutterBottom color="secondary.main" fontWeight="medium">
          Class B Coupon Information
        </Typography>
        
        <TableContainer sx={{ 
          backgroundColor: 'background.paper', 
          borderRadius: 1,
          boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
        }}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.secondary.main, 0.04) }}>Tranche</TableCell>
                <TableCell align="center" sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.secondary.main, 0.04) }}>Coupon Rate (%)</TableCell>
                <TableCell align="center" sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.secondary.main, 0.04) }}>Effective Coupon Rate (%)</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {results.interest_rate_conversions
                .filter(rate => rate.Tranche.includes('Class B'))
                .map((rate, index) => (
                  <TableRow key={index}>
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: theme.palette.secondary.main,
                            mr: 1 
                          }} 
                        />
                        {rate.Tranche}
                      </Box>
                    </TableCell>
                    <TableCell align="center">
                      <Chip 
                        size="small" 
                        label={formatValue(rate['Coupon Rate (%)'])}
                        sx={{ 
                          bgcolor: alpha(theme.palette.secondary.main, 0.1),
                          color: theme.palette.secondary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                    <TableCell align="center">
                      <Chip 
                        size="small" 
                        label={formatValue(rate['Effective Coupon Rate (%)'])}
                        sx={{ 
                          bgcolor: alpha(theme.palette.info.main, 0.1),
                          color: theme.palette.info.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                ))
              }
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
      
      {/* Interest Rates Chart */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3,
          border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
          borderRadius: 2
        }}
      >
        <Typography variant="h6" gutterBottom fontWeight="medium">
          Interest Rates by Tranche
        </Typography>
        
        <Box sx={{ height: 400, mt: 3 }}>
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
              <XAxis dataKey="name" />
              <YAxis unit="%" />
              <Tooltip 
                formatter={(value) => `${value.toFixed(2)}%`}
                contentStyle={{
                  borderRadius: 8,
                  border: 'none',
                  boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                }}
              />
              <Legend />
              <Bar 
                dataKey="rate" 
                name="Rate" 
                fill={theme.palette.primary.main}
                radius={[4, 4, 0, 0]}
              />
            </BarChart>
          </ResponsiveContainer>
        </Box>
      </Paper>
      
      {/* Interest Rate Conversions Table */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3,
          border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
          borderRadius: 2
        }}
      >
        <Typography variant="h6" gutterBottom fontWeight="medium">
          Interest Rate Conversions
        </Typography>
        
        <TableContainer sx={{ 
          maxHeight: 440, 
          mt: 2,
          borderRadius: 1,
          boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
        }}>
          <Table stickyHeader>
            <TableHead>
              <TableRow>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Tranche</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Days</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Simple Annual Interest (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Compound Interest for Period (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Reinvest Simple Annual (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Reinvest O/N Compound (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Coupon Rate (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Effective Coupon Rate (%)</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {results.interest_rate_conversions.map((rate, index) => (
                <TableRow 
                  key={index}
                  sx={{ 
                    backgroundColor: rate.Tranche.includes('Class A') 
                      ? alpha(theme.palette.primary.main, 0.03)
                      : alpha(theme.palette.secondary.main, 0.03),
                    '&:hover': {
                      backgroundColor: rate.Tranche.includes('Class A') 
                        ? alpha(theme.palette.primary.main, 0.07)
                        : alpha(theme.palette.secondary.main, 0.07),
                    }
                  }}
                >
                  <TableCell>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Box 
                        component="span" 
                        sx={{ 
                          display: 'inline-block', 
                          width: 10, 
                          height: 10, 
                          borderRadius: '50%', 
                          bgcolor: rate.Tranche.includes('Class A') 
                            ? theme.palette.primary.main 
                            : theme.palette.secondary.main,
                          mr: 1 
                        }} 
                      />
                      {rate.Tranche}
                    </Box>
                  </TableCell>
                  <TableCell>{rate['Maturity Days']}</TableCell>
                  <TableCell>{formatValue(rate['Simple Annual Interest (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Compound Interest for Period (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Reinvest Simple Annual (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Reinvest O/N Compound (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Coupon Rate (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Effective Coupon Rate (%)'])}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    </Box>
  );
};

export default InterestRatesTable;

======================================================================

DOSYA: src\components\calculation\TrancheAForm.js
==================================================
// frontend/src/components/calculation/TrancheAForm.js
import React from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  TextField,
  IconButton
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import { useData } from '../../contexts/DataContext';

const TrancheAForm = () => {
  const { tranchesA, setTranchesA } = useData();

  const handleChange = (index, field, value) => {
    const newTranches = [...tranchesA];
    newTranches[index][field] = value;
    setTranchesA(newTranches);
  };

  const handleAddTranche = () => {
    const newTranche = {
      maturity_days: 0,
      base_rate: 0.0,
      spread: 0.0,
      reinvest_rate: 0.0,
      nominal: 0
    };
    
    setTranchesA([...tranchesA, newTranche]);
  };

  const handleDeleteTranche = (index) => {
    const newTranches = tranchesA.filter((_, i) => i !== index);
    setTranchesA(newTranches);
  };

  return (
    <Paper sx={{ p: 3, mb: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6">
          Class A Tranches
        </Typography>
        <IconButton 
          color="primary" 
          onClick={handleAddTranche}
          disabled={tranchesA.length >= 10}
        >
          <AddIcon />
        </IconButton>
      </Box>
      
      <TableContainer>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Tranche</TableCell>
              <TableCell>Maturity Days</TableCell>
              <TableCell>Base Rate (%)</TableCell>
              <TableCell>Spread (bps)</TableCell>
              <TableCell>Reinvest Rate (%)</TableCell>
              <TableCell>Nominal (â‚º)</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {tranchesA.map((tranche, index) => (
              <TableRow key={index}>
                <TableCell>{`A${index + 1}`}</TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.maturity_days}
                    onChange={(e) => handleChange(index, 'maturity_days', parseInt(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.base_rate}
                    onChange={(e) => handleChange(index, 'base_rate', parseFloat(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0, step: 0.1 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.spread}
                    onChange={(e) => handleChange(index, 'spread', parseFloat(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0, step: 0.1 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.reinvest_rate}
                    onChange={(e) => handleChange(index, 'reinvest_rate', parseFloat(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0, step: 0.1 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.nominal}
                    onChange={(e) => handleChange(index, 'nominal', parseInt(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0, step: 1000000 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <IconButton 
                    color="error" 
                    onClick={() => handleDeleteTranche(index)}
                    disabled={tranchesA.length <= 1}
                  >
                    <DeleteIcon />
                  </IconButton>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Paper>
  );
};

export default TrancheAForm;

======================================================================

DOSYA: src\components\calculation\TrancheBForm.js
==================================================
// frontend/src/components/calculation/TrancheBForm.js
import React from 'react';
import { Box, Typography, TextField, Paper } from '@mui/material';
import { useData } from '../../contexts/DataContext';

const TrancheBForm = () => {
  const { trancheB, setTrancheB } = useData();

  const handleChange = (field, value) => {
    setTrancheB({
      ...trancheB,
      [field]: value,
    });
  };

  return (
    <Paper sx={{ p: 3, mb: 3 }}>
      <Typography variant="h6" gutterBottom>
        Class B Tranche
      </Typography>
      
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2, mt: 2 }}>
        <TextField
          label="Maturity Days"
          type="number"
          value={trancheB.maturity_days}
          onChange={(e) => handleChange('maturity_days', parseInt(e.target.value) || 0)}
          sx={{ flex: '1 0 200px' }}
          InputProps={{
            inputProps: { min: 0 }
          }}
        />
        
        <TextField
          label="Base Rate (%)"
          type="number"
          value={trancheB.base_rate}
          onChange={(e) => handleChange('base_rate', parseFloat(e.target.value) || 0)}
          sx={{ flex: '1 0 200px' }}
          InputProps={{
            inputProps: { min: 0, step: 0.1 }
          }}
        />
        
        <TextField
          label="Spread (bps)"
          type="number"
          value={trancheB.spread}
          onChange={(e) => handleChange('spread', parseFloat(e.target.value) || 0)}
          sx={{ flex: '1 0 200px' }}
          InputProps={{
            inputProps: { min: 0, step: 0.1 }
          }}
        />
        
        <TextField
          label="Reinvest Rate (%)"
          type="number"
          value={trancheB.reinvest_rate}
          onChange={(e) => handleChange('reinvest_rate', parseFloat(e.target.value) || 0)}
          sx={{ flex: '1 0 200px' }}
          InputProps={{
            inputProps: { min: 0, step: 0.1 }
          }}
        />
      </Box>
      
      <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
        Class B nominal amount will be automatically calculated as 10.17811704% of total.
      </Typography>
    </Paper>
  );
};

export default TrancheBForm;

======================================================================

DOSYA: src\components\optimization\OptimizationProgress.js
==================================================
// src/components/optimization/OptimizationProgress.js
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  LinearProgress, 
  Paper, 
  Divider,
  Chip,
  Button,
  alpha,
  useTheme
} from '@mui/material';
import RefreshIcon from '@mui/icons-material/Refresh';
import SpeedIcon from '@mui/icons-material/Speed';
import PendingIcon from '@mui/icons-material/Pending';
import SyncIcon from '@mui/icons-material/Sync';
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

const OptimizationProgress = ({ isOptimizing, onComplete }) => {
  const theme = useTheme();
  const [progress, setProgress] = useState(0);
  const [phase, setPhase] = useState('Initializing');
  const [message, setMessage] = useState('Starting optimization...');
  const [pollingActive, setPollingActive] = useState(false);
  const [pollCount, setPollCount] = useState(0);
  const [stuckDetected, setStuckDetected] = useState(false);
  const [lastProgressUpdate, setLastProgressUpdate] = useState(Date.now());
  const [lastProgressValue, setLastProgressValue] = useState(0);
  const [errorOccurred, setErrorOccurred] = useState(false);
  
  // Start polling when optimization starts
  useEffect(() => {
    if (isOptimizing && !pollingActive) {
      console.log("Starting optimization progress polling");
      setPollingActive(true);
      setProgress(0);
      setPhase('Initializing');
      setMessage('Starting optimization...');
      setPollCount(0);
      setStuckDetected(false);
      setLastProgressUpdate(Date.now());
      setLastProgressValue(0);
      setErrorOccurred(false);
    } else if (!isOptimizing && pollingActive) {
      console.log("Stopping optimization progress polling");
      setPollingActive(false);
    }
  }, [isOptimizing, pollingActive]);
  
  // Handle refresh button click
  const handleRefresh = () => {
    console.log("Refreshing optimization progress");
    if (stuckDetected) {
      setStuckDetected(false);
      setPollCount(0);
      setLastProgressUpdate(Date.now());
    }
  };
  
  // Polling effect
  useEffect(() => {
    let intervalId;
    
    if (pollingActive) {
      // Poll every second
      intervalId = setInterval(async () => {
        try {
          console.log("Polling optimization progress...");
          const response = await axios.get(`${API_URL}/optimize/progress/`);
          const data = response.data;
          
          console.log("Progress data:", data);
          
          // Check for error flag from backend
          if (data.error) {
            console.error("Error in optimization progress:", data.message);
            setErrorOccurred(true);
            setMessage(data.message || "Error in optimization process");
            setPhase("Error");
            // Don't update progress to indicate the error visually
            return;
          }
          
          // Check if progress has changed or message has changed
          const hasProgressChanged = data.progress !== progress;
          const hasMessageChanged = data.message !== message;
          
          if (hasProgressChanged || hasMessageChanged) {
            setProgress(data.progress);
            setPhase(data.phase);
            setMessage(data.message);
            setLastProgressUpdate(Date.now());
            
            if (hasProgressChanged) {
              setLastProgressValue(data.progress);
            }
          } else {
            // If no progress update, increment counter
            setPollCount(prev => prev + 1);
          }
          
          // Check for stuck progress - if no change for 30 seconds
          const timeSinceUpdate = Date.now() - lastProgressUpdate;
          if (pollCount > 30 && timeSinceUpdate > 30000) {
            console.log("Progress appears to be stuck");
            setStuckDetected(true);
          }
          
          // If progress is 100%, notify parent component
          if (data.progress >= 100) {
            console.log("Optimization completed (progress 100%)");
            setPollingActive(false);
            if (onComplete) {
              onComplete();
            }
          }
        } catch (error) {
          console.error('Error fetching optimization progress:', error);
          setPollCount(prev => prev + 1);
          
          // If we've had many errors, consider it stuck
          if (pollCount > 15) {
            console.log("Multiple polling errors, considering progress stuck");
            setStuckDetected(true);
          }
        }
      }, 1000);
    }
    
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [pollingActive, onComplete, progress, message, pollCount, lastProgressUpdate, lastProgressValue]);
  
  // Auto-complete if we've been at 100% for a while
  useEffect(() => {
    if (progress >= 100 && pollingActive) {
      console.log("Progress is 100%, auto-completing after delay");
      const timeoutId = setTimeout(() => {
        setPollingActive(false);
        if (onComplete) {
          onComplete();
        }
      }, 2000);
      
      return () => clearTimeout(timeoutId);
    }
  }, [progress, pollingActive, onComplete]);
  
  if (!isOptimizing && progress === 0) {
    return null;
  }
  
  // Calculate progress color
  const getProgressColor = () => {
    if (errorOccurred) return theme.palette.error.main;
    if (stuckDetected) return theme.palette.warning.main;
    if (progress < 30) return theme.palette.info.main;
    if (progress < 70) return theme.palette.primary.main;
    return theme.palette.success.main;
  };
  
  // Progress icon
  const getProgressIcon = () => {
    if (errorOccurred) return <SyncIcon color="error" />;
    if (stuckDetected) return <SyncIcon color="warning" />;
    if (progress < 50) return <PendingIcon color="primary" />;
    return <SpeedIcon color="success" />;
  };
  
  return (
    <Paper 
      elevation={0} 
      sx={{ 
        p: 3, 
        mb: 3, 
        borderRadius: 2,
        border: errorOccurred 
          ? `1px solid ${alpha(theme.palette.error.main, 0.3)}`
          : stuckDetected 
            ? `1px solid ${alpha(theme.palette.warning.main, 0.3)}`
            : `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
        backgroundColor: errorOccurred
          ? alpha(theme.palette.error.main, 0.05)
          : stuckDetected
            ? alpha(theme.palette.warning.main, 0.05)
            : alpha(theme.palette.primary.main, 0.03)
      }}
    >
      <Box sx={{ mb: 2 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            {getProgressIcon()}
            <Typography variant="h6" sx={{ ml: 1 }}>
              {errorOccurred 
                ? 'Optimization Error' 
                : stuckDetected 
                  ? 'Optimization Progress (Stuck)' 
                  : 'Optimization Progress'}
            </Typography>
          </Box>
          <Chip 
            label={phase} 
            color={errorOccurred ? "error" : stuckDetected ? "warning" : "primary"} 
            variant="outlined"
            size="small"
          />
        </Box>
        <LinearProgress 
          variant="determinate" 
          value={progress} 
          sx={{ 
            height: 10, 
            borderRadius: 5,
            '& .MuiLinearProgress-bar': {
              borderRadius: 5,
              backgroundColor: getProgressColor()
            }
          }} 
        />
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
          <Typography variant="body2" color="text.secondary">
            {message}
          </Typography>
          <Typography variant="body2" fontWeight="medium">
            {progress}%
          </Typography>
        </Box>
      </Box>
      
      <Divider sx={{ my: 1 }} />
      
      <Box sx={{ mt: 1, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="body2" color="text.secondary">
          {errorOccurred 
            ? "An error occurred during optimization. Please try again with different parameters."
            : stuckDetected 
              ? "Optimization might be stuck. The server is still processing, but progress updates have stopped." 
              : progress === 100 
                ? "Optimization completed successfully." 
                : "Please wait while the optimization is in progress..."}
        </Typography>
        
        {(stuckDetected || errorOccurred) && (
          <Button 
            variant="outlined" 
            color={errorOccurred ? "error" : "warning"} 
            size="small" 
            startIcon={<RefreshIcon />}
            onClick={handleRefresh}
            sx={{ ml: 2 }}
          >
            Refresh
          </Button>
        )}
      </Box>
    </Paper>
  );
};

export default OptimizationProgress;

======================================================================

DOSYA: src\components\optimization\OptimizationResults.js
==================================================
// frontend/src/components/optimization/OptimizationResults.js
import React from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Button,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Divider,
  Chip
} from '@mui/material';
import { useTheme } from '@mui/material/styles';
import { 
  BarChart, Bar, 
  PieChart, Pie, Cell, 
  XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
  Scatter, ScatterChart, ZAxis
} from 'recharts';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import { useData } from '../../contexts/DataContext';
import { useNavigate } from 'react-router-dom';

// Strategy name mapping
const strategyNames = {
  equal: "Equal Distribution",
  increasing: "Increasing by Maturity",
  decreasing: "Decreasing by Maturity",
  middle_weighted: "Middle Tranches Weighted"
};

const OptimizationResults = ({ results }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const { setTranchesA, setTrancheB, calculationResults, setPreviousCalculationResults } = useData();
  
  // Format currency values
  const formatCurrency = (value) => {
    return new Intl.NumberFormat('tr-TR', { style: 'currency', currency: 'TRY' }).format(value);
  };
  
  // Format percentage values
  const formatPercent = (value) => {
    return `${value.toFixed(2)}%`;
  };
  
  // Prepare data for pie chart
  const pieData = [
    ...results.class_a_nominals.map((nominal, index) => ({
      name: `Class A${index + 1}`,
      value: nominal,
      color: theme.palette.primary.main
    })),
    { 
      name: 'Class B1', 
      value: results.class_b_nominal,
      color: theme.palette.secondary.main
    }
  ];
  
  // Prepare data for maturity distribution chart
  const maturityData = [
    ...results.class_a_maturities.map((maturity, index) => ({
      name: `Class A${index + 1}`,
      maturity,
      nominal: results.class_a_nominals[index],
      type: 'Class A'
    })),
    {
      name: 'Class B1',
      maturity: results.class_b_maturity,
      nominal: results.class_b_nominal,
      type: 'Class B'
    },
    {
      name: 'Last Cash Flow',
      maturity: results.last_cash_flow_day,
      nominal: Math.max(...results.class_a_nominals, results.class_b_nominal) / 20,
      type: 'Marker'
    }
  ];
  
  // Strategy comparison data
  const strategyResultsData = Object.entries(results.results_by_strategy).map(([strategy, data]) => ({
    name: strategyNames[strategy],
    totalPrincipal: data.total_principal,
    classBCouponRate: data.class_b_coupon_rate,
    minBufferActual: data.min_buffer_actual,
    isBest: strategy === results.best_strategy
  }));
  
  // Apply the best strategy configuration to the forms
  const applyConfiguration = () => {
    // Store the current calculation results for comparison before we change the configuration
    if (calculationResults) {
      setPreviousCalculationResults(calculationResults);
    }
    
    const a_tranches = results.class_a_maturities.map((maturity, index) => ({
      maturity_days: maturity,
      base_rate: results.class_a_rates[index],
      spread: 0.0, // Default value
      reinvest_rate: results.class_a_reinvest[index],
      nominal: results.class_a_nominals[index]
    }));
    
    const b_tranche = {
      maturity_days: results.class_b_maturity,
      base_rate: results.class_b_rate,
      spread: 0.0, // Default value
      reinvest_rate: results.class_b_reinvest
    };
    
    setTranchesA(a_tranches);
    setTrancheB(b_tranche);
    
    // Show a success message with option to compare
    const goToCompare = window.confirm('Configuration applied! Would you like to go to Comparison page to compare with previous results?');
    if (goToCompare) {
      navigate('/comparison');  // window.location.href yerine navigate kullanÄ±yoruz
    } else {
      navigate('/calculation');  // window.location.href yerine navigate kullanÄ±yoruz
    }
  };

  return (
    <Box>
      {/* Summary Banner */}
      <Paper 
        sx={{ 
          p: 3, 
          mb: 3, 
          borderLeft: `4px solid ${theme.palette.secondary.main}`,
          backgroundColor: 'rgba(46, 204, 113, 0.1)'
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
          <Typography variant="h5" color="secondary">
            Optimal Structure Found
          </Typography>
          <Chip 
            icon={<CheckCircleIcon />} 
            label={strategyNames[results.best_strategy]} 
            color="secondary" 
          />
        </Box>
        
        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 4, mb: 3 }}>
          <Box>
            <Typography variant="body2" color="text.secondary">
              Class A Tranches
            </Typography>
            <Typography variant="h6">
              {results.class_a_maturities.length}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary">
              Class B Coupon Rate
            </Typography>
            <Typography variant="h6" color="secondary">
              {formatPercent(results.class_b_coupon_rate)}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary">
              Minimum Buffer
            </Typography>
            <Typography variant="h6" color={results.min_buffer_actual >= 5.0 ? 'success.main' : 'error.main'}>
              {formatPercent(results.min_buffer_actual)}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary">
              Class B Maturity
            </Typography>
            <Typography variant="h6">
              {results.class_b_maturity} days
            </Typography>
          </Box>
        </Box>
        
        <Button 
          variant="contained" 
          color="secondary"
          size="large"
          onClick={applyConfiguration}
        >
          Apply This Configuration
        </Button>
      </Paper>
      
      {/* Class B Maturity Calculation */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Class B Maturity Calculation
        </Typography>
        
        <Box sx={{ 
          display: 'flex', 
          flexWrap: 'wrap', 
          alignItems: 'center', 
          justifyContent: 'center',
          gap: 2, 
          my: 3 
        }}>
          <Paper sx={{ p: 2, bgcolor: 'grey.100', textAlign: 'center', minWidth: 180 }}>
            <Typography variant="body2" color="text.secondary">
              Last Cash Flow
            </Typography>
            <Typography variant="h5">
              {results.last_cash_flow_day} days
            </Typography>
          </Paper>
          
          <Typography variant="h4" color="text.secondary">+</Typography>
          
          <Paper sx={{ p: 2, bgcolor: 'grey.100', textAlign: 'center', minWidth: 180 }}>
            <Typography variant="body2" color="text.secondary">
              Additional Days
            </Typography>
            <Typography variant="h5">
              {results.additional_days} days
            </Typography>
          </Paper>
          
          <Typography variant="h4" color="text.secondary">=</Typography>
          
          <Paper sx={{ 
            p: 2, 
            bgcolor: theme.palette.secondary.main, 
            color: 'white',
            textAlign: 'center', 
            minWidth: 180 
          }}>
            <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
              Class B Maturity
            </Typography>
            <Typography variant="h5">
              {results.class_b_maturity} days
            </Typography>
          </Paper>
        </Box>
        
        <Typography variant="body2" color="text.secondary" fontStyle="italic">
          Note: Class B maturity is calculated as Last Cash Flow Day + Additional Days.
          Maximum maturity is capped at 365 days.
        </Typography>
      </Paper>
      
      {/* Strategy Comparison */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Strategy Comparison
        </Typography>
        
        <TableContainer sx={{ mb: 3 }}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Strategy</TableCell>
                <TableCell align="right">Total Principal</TableCell>
                <TableCell align="right">Class B Coupon Rate</TableCell>
                <TableCell align="right">Min Buffer</TableCell>
                <TableCell align="right">Class A Tranches</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {strategyResultsData.map((row, index) => (
                <TableRow 
                  key={index}
                  sx={{ 
                    bgcolor: row.isBest ? 'rgba(46, 204, 113, 0.1)' : 'transparent',
                    fontWeight: row.isBest ? 'bold' : 'normal'
                  }}
                >
                  <TableCell>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      {row.isBest && <CheckCircleIcon color="secondary" fontSize="small" />}
                      {row.name}
                    </Box>
                  </TableCell>
                  <TableCell align="right">{formatCurrency(row.totalPrincipal)}</TableCell>
                  <TableCell align="right">{formatPercent(row.classBCouponRate)}</TableCell>
                  <TableCell align="right">{formatPercent(row.minBufferActual)}</TableCell>
                  <TableCell align="right">
                    {results.results_by_strategy[Object.keys(strategyNames).find(key => strategyNames[key] === row.name)]?.num_a_tranches || '-'}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
        
        {/* Strategy comparison charts */}
        <Box sx={{ height: 400, mb: 3 }}>
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={strategyResultsData}
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip formatter={(value) => formatCurrency(value)} />
              <Legend />
              <Bar 
                dataKey="totalPrincipal" 
                name="Total Principal" 
                fill={theme.palette.primary.main} 
              />
            </BarChart>
          </ResponsiveContainer>
        </Box>
        
        <Box sx={{ height: 400 }}>
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={strategyResultsData}
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis unit="%" />
              <Tooltip formatter={(value) => `${value.toFixed(2)}%`} />
              <Legend />
              <Bar 
                dataKey="classBCouponRate" 
                name="Class B Coupon Rate" 
                fill={theme.palette.secondary.main} 
              />
              <Bar 
                dataKey="minBufferActual" 
                name="Min Buffer" 
                fill={theme.palette.info.main} 
              />
            </BarChart>
          </ResponsiveContainer>
        </Box>
      </Paper>
      
      {/* Tranche Details */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Tranche Details
        </Typography>
        
        <Typography variant="subtitle1" gutterBottom sx={{ color: theme.palette.primary.main, mt: 3 }}>
          Class A Tranches
        </Typography>
        
        <TableContainer sx={{ mb: 3 }}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Tranche</TableCell>
                <TableCell align="right">Maturity (days)</TableCell>
                <TableCell align="right">Base Rate (%)</TableCell>
                <TableCell align="right">Reinvest Rate (%)</TableCell>
                <TableCell align="right">Nominal</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {results.class_a_maturities.map((maturity, index) => (
                <TableRow key={index}>
                  <TableCell>Class A{index + 1}</TableCell>
                  <TableCell align="right">{maturity}</TableCell>
                  <TableCell align="right">{results.class_a_rates[index].toFixed(2)}</TableCell>
                  <TableCell align="right">{results.class_a_reinvest[index].toFixed(2)}</TableCell>
                  <TableCell align="right">{formatCurrency(results.class_a_nominals[index])}</TableCell>
                </TableRow>
              ))}
              <TableRow sx={{ bgcolor: 'grey.100' }}>
                <TableCell sx={{ fontWeight: 'bold' }}>Total</TableCell>
                <TableCell></TableCell>
                <TableCell></TableCell>
                <TableCell></TableCell>
                <TableCell align="right" sx={{ fontWeight: 'bold' }}>
                  {formatCurrency(results.class_a_nominals.reduce((sum, nominal) => sum + nominal, 0))}
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </TableContainer>
        
        <Typography variant="subtitle1" gutterBottom sx={{ color: theme.palette.secondary.main, mt: 3 }}>
          Class B Tranche
        </Typography>
        
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Tranche</TableCell>
                <TableCell align="right">Maturity (days)</TableCell>
                <TableCell align="right">Base Rate (%)</TableCell>
                <TableCell align="right">Reinvest Rate (%)</TableCell>
                <TableCell align="right">Nominal</TableCell>
                <TableCell align="right">Coupon Rate (%)</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              <TableRow>
                <TableCell>Class B1</TableCell>
                <TableCell align="right">{results.class_b_maturity}</TableCell>
                <TableCell align="right">{results.class_b_rate.toFixed(2)}</TableCell>
                <TableCell align="right">{results.class_b_reinvest.toFixed(2)}</TableCell>
                <TableCell align="right">{formatCurrency(results.class_b_nominal)}</TableCell>
                <TableCell align="right" sx={{ fontWeight: 'bold', color: theme.palette.secondary.main }}>
                  {formatPercent(results.class_b_coupon_rate)}
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
      
      {/* Visualizations */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Visualizations
        </Typography>
        
        <Typography variant="subtitle1" gutterBottom sx={{ mt: 3 }}>
          Nominal Amount Distribution
        </Typography>
        
        <Box sx={{ height: 400, mb: 4 }}>
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={120}
                innerRadius={60}
                label={({ name, percent }) => `${name} (${(percent * 100).toFixed(1)}%)`}
              >
                {pieData.map((entry, index) => (
                  <Cell 
                    key={`cell-${index}`} 
                    fill={entry.name.includes('Class A') 
                      ? theme.palette.primary[index % 5 === 0 ? 'main' : `${Math.min(900, 300 + index * 100)}`]
                      : theme.palette.secondary.main
                    } 
                  />
                ))}
              </Pie>
              <Tooltip formatter={(value) => formatCurrency(value)} />
              <Legend />
            </PieChart>
          </ResponsiveContainer>
        </Box>
        
        <Typography variant="subtitle1" gutterBottom sx={{ mt: 3 }}>
          Maturity Distribution
        </Typography>
        
        <Box sx={{ height: 400 }}>
          <ResponsiveContainer width="100%" height="100%">
            <ScatterChart
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis 
                type="number" 
                dataKey="maturity" 
                name="Maturity" 
                unit=" days" 
                domain={[0, 'dataMax + 30']}
              />
              <YAxis 
                type="number" 
                dataKey="nominal" 
                name="Nominal" 
                tickFormatter={(value) => `${(value / 1000000).toFixed(0)}M`}
              />
              <ZAxis range={[100, 600]} />
              <Tooltip 
                formatter={(value, name, props) => {
                  if (name === 'Nominal') return formatCurrency(value);
                  return `${value} days`;
                }}
                content={({ active, payload }) => {
                  if (active && payload && payload.length) {
                    const data = payload[0].payload;
                    return (
                      <Box sx={{ bgcolor: 'background.paper', p: 1, border: '1px solid #ccc' }}>
                        <Typography variant="body2" fontWeight="bold">
                          {data.name}
                        </Typography>
                        <Typography variant="body2">
                          Maturity: {data.maturity} days
                        </Typography>
                        {data.type !== 'Marker' && (
                          <Typography variant="body2">
                            Nominal: {formatCurrency(data.nominal)}
                          </Typography>
                        )}
                      </Box>
                    );
                  }
                  return null;
                }}
              />
              <Legend />
              <Scatter 
                name="Class A" 
                data={maturityData.filter(d => d.type === 'Class A')}
                fill={theme.palette.primary.main}
              />
              <Scatter 
                name="Class B" 
                data={maturityData.filter(d => d.type === 'Class B')}
                fill={theme.palette.secondary.main}
              />
              <Scatter 
                name="Last Cash Flow" 
                data={maturityData.filter(d => d.type === 'Marker')}
                fill={theme.palette.error.main}
                shape="star"
              />
            </ScatterChart>
          </ResponsiveContainer>
        </Box>
      </Paper>
    </Box>
  );
};

export default OptimizationResults;

======================================================================

DOSYA: src\components\optimization\OptimizationSettingsForm.js
==================================================
// src/components/optimization/OptimizationSettingsForm.js
import React, { useState } from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Slider, 
  TextField, 
  InputAdornment,
  FormControl,
  FormLabel,
  RadioGroup,
  Radio,
  FormControlLabel,
  Tooltip,
  IconButton,
  Divider,
  Grid,
  Card,
  CardContent,
  alpha,
  useTheme
} from '@mui/material';
import InfoIcon from '@mui/icons-material/Info';
import SpeedIcon from '@mui/icons-material/Speed';
import TuneIcon from '@mui/icons-material/Tune';
import TimelineIcon from '@mui/icons-material/Timeline';
import ShowChartIcon from '@mui/icons-material/ShowChart';
import AccountTreeIcon from '@mui/icons-material/AccountTree';

const OptimizationSettingsForm = ({ values, onChange }) => {
  const theme = useTheme();
  const [optimizationMethod, setOptimizationMethod] = useState(values.optimization_method || 'classic');

  const handleOptimizationMethodChange = (event) => {
    setOptimizationMethod(event.target.value);
    onChange({ ...values, optimization_method: event.target.value });
  };

  const handleSliderChange = (field) => (event, newValue) => {
    onChange({ ...values, [field]: newValue });
  };

  const handleInputChange = (field) => (event) => {
    const value = event.target.type === 'number' 
      ? parseFloat(event.target.value) 
      : event.target.value;
    onChange({ ...values, [field]: value });
  };

  // Method info details
  const methodInfo = {
    classic: {
      title: "Classic Strategies",
      icon: <TuneIcon sx={{ fontSize: 36, color: theme.palette.primary.main }} />,
      description: "Compares Equal, Increasing, Decreasing, and Middle-Weighted distribution strategies",
      color: theme.palette.primary.main
    },
    gradient: {
      title: "Gradient Descent",
      icon: <ShowChartIcon sx={{ fontSize: 36, color: theme.palette.secondary.main }} />,
      description: "Uses gradient-based optimization for faster convergence",
      color: theme.palette.secondary.main
    },
    bayesian: {
      title: "Bayesian Optimization",
      icon: <TimelineIcon sx={{ fontSize: 36, color: theme.palette.info.main }} />,
      description: "Global optimization method requiring fewer computations",
      color: theme.palette.info.main
    },
    genetic: {
      title: "Genetic Algorithm",
      icon: <AccountTreeIcon sx={{ fontSize: 36, color: theme.palette.warning.main }} />,
      description: "Effective in large solution spaces with evolutionary search",
      color: theme.palette.warning.main
    }
  };

  return (
    <Box>
      <Typography variant="subtitle1" gutterBottom fontWeight="medium" sx={{ mb: 3 }}>
        Select an optimization method and configure parameters to find the optimal tranche structure
      </Typography>
      
      <Grid container spacing={3} sx={{ mb: 4 }}>
        {Object.keys(methodInfo).map((method) => (
          <Grid item xs={12} sm={6} md={3} key={method}>
            <Card 
              elevation={0}
              sx={{ 
                borderRadius: 2,
                border: `1px solid ${optimizationMethod === method 
                  ? alpha(methodInfo[method].color, 0.5) 
                  : alpha(theme.palette.text.primary, 0.08)}`,
                backgroundColor: optimizationMethod === method 
                  ? alpha(methodInfo[method].color, 0.05)
                  : 'background.paper',
                transition: 'all 0.2s ease-in-out',
                cursor: 'pointer',
                height: '100%',
                '&:hover': {
                  borderColor: alpha(methodInfo[method].color, 0.5),
                  backgroundColor: alpha(methodInfo[method].color, 0.03)
                }
              }}
              onClick={() => {
                setOptimizationMethod(method);
                onChange({ ...values, optimization_method: method });
              }}
            >
              <CardContent sx={{ p: 2.5 }}>
                <FormControlLabel
                  value={method}
                  control={
                    <Radio 
                      checked={optimizationMethod === method}
                      onChange={() => {}}
                      color={optimizationMethod === method ? undefined : "default"}
                    />
                  }
                  label={
                    <Box sx={{ ml: 0.5 }}>
                      {methodInfo[method].icon}
                      <Typography variant="subtitle1" sx={{ mt: 1.5, fontWeight: 500 }}>
                        {methodInfo[method].title}
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5, minHeight: 60 }}>
                        {methodInfo[method].description}
                      </Typography>
                    </Box>
                  }
                  sx={{ mx: 0, alignItems: 'flex-start', '& .MuiFormControlLabel-label': { width: '100%' } }}
                />
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      <Divider sx={{ my: 4 }} />
      
      <Box sx={{ backgroundColor: alpha(theme.palette.background.paper, 0.7), p: 3, borderRadius: 2 }}>
        <Typography variant="h6" gutterBottom color={methodInfo[optimizationMethod].color}>
          {methodInfo[optimizationMethod].title} Configuration
        </Typography>
        
        {/* Method-specific settings */}
        {optimizationMethod === 'classic' && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="subtitle2" gutterBottom fontWeight="medium">
              Classic Optimization Settings
            </Typography>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Class A Tranches Range</FormLabel>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                <Typography>{values.a_tranches_range[0]}</Typography>
                <Slider
                  value={values.a_tranches_range}
                  onChange={handleSliderChange('a_tranches_range')}
                  min={1}
                  max={10}
                  step={1}
                  valueLabelDisplay="auto"
                  aria-labelledby="a-tranches-range-slider"
                  sx={{ mx: 2 }}
                />
                <Typography>{values.a_tranches_range[1]}</Typography>
              </Box>
              <Typography variant="body2" color="text.secondary">
                Number of Class A tranches to consider in optimization
              </Typography>
            </FormControl>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Maturity Range (days)</FormLabel>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                <Typography>{values.maturity_range[0]}</Typography>
                <Slider
                  value={values.maturity_range}
                  onChange={handleSliderChange('maturity_range')}
                  min={30}
                  max={365}
                  step={5}
                  valueLabelDisplay="auto"
                  aria-labelledby="maturity-range-slider"
                  sx={{ mx: 2 }}
                />
                <Typography>{values.maturity_range[1]}</Typography>
              </Box>
              <Typography variant="body2" color="text.secondary">
                Range of maturity periods to consider in days
              </Typography>
            </FormControl>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Maturity Step</FormLabel>
              <Slider
                value={values.maturity_step}
                onChange={handleSliderChange('maturity_step')}
                min={5}
                max={30}
                step={5}
                valueLabelDisplay="auto"
                aria-labelledby="maturity-step-slider"
                marks={[
                  { value: 5, label: '5' },
                  { value: 10, label: '10' },
                  { value: 15, label: '15' },
                  { value: 20, label: '20' },
                  { value: 25, label: '25' },
                  { value: 30, label: '30' },
                ]}
              />
              <Typography variant="body2" color="text.secondary">
                Step size between maturity values
              </Typography>
            </FormControl>
          </Box>
        )}
        
        {optimizationMethod === 'gradient' && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="subtitle2" gutterBottom fontWeight="medium">
              Gradient Descent Settings
            </Typography>
            <FormControl fullWidth sx={{ mb: 2 }}>
              <FormLabel>Learning Rate</FormLabel>
              <Slider
                value={values.learning_rate || 0.01}
                onChange={(e, newValue) => onChange({ ...values, learning_rate: newValue })}
                min={0.001}
                max={0.1}
                step={0.001}
                valueLabelDisplay="auto"
                marks={[
                  { value: 0.001, label: '0.001' },
                  { value: 0.01, label: '0.01' },
                  { value: 0.1, label: '0.1' },
                ]}
              />
              <Typography variant="body2" color="text.secondary">
                Controls the step size in parameter updates (smaller values: slower but more precise)
              </Typography>
            </FormControl>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Number of Iterations</FormLabel>
              <Slider
                value={values.max_iterations || 100}
                onChange={(e, newValue) => onChange({ ...values, max_iterations: newValue })}
                min={10}
                max={500}
                step={10}
                valueLabelDisplay="auto"
              />
              <Typography variant="body2" color="text.secondary">
                Maximum number of iterations for gradient descent algorithm
              </Typography>
            </FormControl>
          </Box>
        )}
        
        {optimizationMethod === 'bayesian' && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="subtitle2" gutterBottom fontWeight="medium">
              Bayesian Optimization Settings
            </Typography>
            <FormControl fullWidth sx={{ mb: 2 }}>
              <FormLabel>Number of Calls</FormLabel>
              <Slider
                value={values.n_calls || 50}
                onChange={(e, newValue) => onChange({ ...values, n_calls: newValue })}
                min={10}
                max={100}
                step={5}
                valueLabelDisplay="auto"
              />
              <Typography variant="body2" color="text.secondary">
                Higher values give better results but take longer to compute
              </Typography>
            </FormControl>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Initial Points</FormLabel>
              <Slider
                value={values.n_initial_points || 10}
                onChange={(e, newValue) => onChange({ ...values, n_initial_points: newValue })}
                min={5}
                max={30}
                step={1}
                valueLabelDisplay="auto"
              />
              <Typography variant="body2" color="text.secondary">
                Number of initial points to evaluate before optimization starts
              </Typography>
            </FormControl>
          </Box>
        )}
        
        {optimizationMethod === 'genetic' && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="subtitle2" gutterBottom fontWeight="medium">
              Genetic Algorithm Settings
            </Typography>
            <FormControl fullWidth sx={{ mb: 2 }}>
              <FormLabel>Population Size</FormLabel>
              <Slider
                value={values.population_size || 50}
                onChange={(e, newValue) => onChange({ ...values, population_size: newValue })}
                min={10}
                max={100}
                step={5}
                valueLabelDisplay="auto"
              />
              <Typography variant="body2" color="text.secondary">
                Number of individuals in each generation
              </Typography>
            </FormControl>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Number of Generations</FormLabel>
              <Slider
                value={values.num_generations || 40}
                onChange={(e, newValue) => onChange({ ...values, num_generations: newValue })}
                min={10}
                max={100}
                step={5}
                valueLabelDisplay="auto"
              />
              <Typography variant="body2" color="text.secondary">
                Number of evolutionary cycles to run
              </Typography>
            </FormControl>
          </Box>
        )}
        
        <Divider sx={{ my: 3 }} />
        
        {/* Common settings for all optimization methods */}
        <Typography variant="subtitle2" gutterBottom fontWeight="medium">
          Common Optimization Parameters
        </Typography>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Minimum Class B Percentage</FormLabel>
              <TextField
                value={values.min_class_b_percent}
                onChange={handleInputChange('min_class_b_percent')}
                type="number"
                InputProps={{
                  endAdornment: <InputAdornment position="end">%</InputAdornment>,
                  inputProps: { min: 5, max: 30, step: 0.5 }
                }}
                margin="normal"
              />
              <Typography variant="body2" color="text.secondary">
                Minimum percentage of total nominal to allocate to Class B
              </Typography>
            </FormControl>
          </Grid>
          
          <Grid item xs={12} md={4}>
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Target Class B Coupon Rate</FormLabel>
              <TextField
                value={values.target_class_b_coupon_rate}
                onChange={handleInputChange('target_class_b_coupon_rate')}
                type="number"
                InputProps={{
                  endAdornment: <InputAdornment position="end">%</InputAdornment>,
                  inputProps: { min: 10, max: 100, step: 0.5 }
                }}
                margin="normal"
              />
              <Typography variant="body2" color="text.secondary">
                Target annual coupon rate for Class B tranche
              </Typography>
            </FormControl>
          </Grid>
          
          <Grid item xs={12} md={4}>
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Additional Days for Class B</FormLabel>
              <TextField
                value={values.additional_days_for_class_b}
                onChange={handleInputChange('additional_days_for_class_b')}
                type="number"
                InputProps={{
                  endAdornment: <InputAdornment position="end">days</InputAdornment>,
                  inputProps: { min: 1, max: 180, step: 1 }
                }}
                margin="normal"
              />
              <Typography variant="body2" color="text.secondary">
                Additional days to add to the last cash flow date for Class B maturity
              </Typography>
            </FormControl>
          </Grid>
        </Grid>
      </Box>
    </Box>
  );
};

export default OptimizationSettingsForm;

======================================================================

DOSYA: src\contexts\DataContext.js
==================================================
// frontend/src/contexts/DataContext.js
import React, { createContext, useState, useContext, useEffect } from 'react';

const DataContext = createContext();

export const useData = () => useContext(DataContext);

export const DataProvider = ({ children }) => {
  // File upload and data state
  const [cashFlowData, setCashFlowData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Calculation form state
  const [generalSettings, setGeneralSettings] = useState({
    start_date: new Date(2025, 1, 13),
    operational_expenses: 7928640,
    min_buffer: 5.0
  });
  
  const [tranchesA, setTranchesA] = useState([
    { maturity_days: 61, base_rate: 45.6, spread: 0.0, reinvest_rate: 40.0, nominal: 480000000 },
    { maturity_days: 120, base_rate: 44.5, spread: 0.0, reinvest_rate: 37.25, nominal: 460000000 },
    { maturity_days: 182, base_rate: 43.3, spread: 0.0, reinvest_rate: 32.5, nominal: 425000000 },
    { maturity_days: 274, base_rate: 42.5, spread: 0.0, reinvest_rate: 30.0, nominal: 400000000 },
  ]);
  
  const [trancheB, setTrancheB] = useState({
    maturity_days: 300,
    base_rate: 0.0,
    spread: 0.0,
    reinvest_rate: 25.5
  });
  
  const [npvSettings, setNpvSettings] = useState({
    method: 'weighted_avg_rate',
    custom_rate: 40.0
  });
  
  // Results state with localStorage initialization
  const [calculationResults, setCalculationResults] = useState(() => {
    const saved = localStorage.getItem('calculationResults');
    return saved ? JSON.parse(saved) : null;
  });
  
  const [optimizationResults, setOptimizationResults] = useState(() => {
    const saved = localStorage.getItem('optimizationResults');
    return saved ? JSON.parse(saved) : null;
  });
  
  const [previousCalculationResults, setPreviousCalculationResults] = useState(() => {
    const saved = localStorage.getItem('previousCalculationResults');
    return saved ? JSON.parse(saved) : null;
  });
  
  // Wrap setState functions to also update localStorage
  const setCalculationResultsWithStorage = (results) => {
    setCalculationResults(results);
    localStorage.setItem('calculationResults', JSON.stringify(results));
  };
  
  const setOptimizationResultsWithStorage = (results) => {
    setOptimizationResults(results);
    localStorage.setItem('optimizationResults', JSON.stringify(results));
  };
  
  const setPreviousCalculationResultsWithStorage = (results) => {
    setPreviousCalculationResults(results);
    localStorage.setItem('previousCalculationResults', JSON.stringify(results));
  };
  
  // Update localStorage when state changes
  useEffect(() => {
    if (calculationResults) {
      localStorage.setItem('calculationResults', JSON.stringify(calculationResults));
    }
  }, [calculationResults]);
  
  useEffect(() => {
    if (optimizationResults) {
      localStorage.setItem('optimizationResults', JSON.stringify(optimizationResults));
    }
  }, [optimizationResults]);
  
  useEffect(() => {
    if (previousCalculationResults) {
      localStorage.setItem('previousCalculationResults', JSON.stringify(previousCalculationResults));
    }
  }, [previousCalculationResults]);
  
  // Optimization settings - Updated with new method options
  const [optimizationSettings, setOptimizationSettings] = useState({
    optimization_method: 'classic', // Yeni alan
    a_tranches_range: [2, 6],
    maturity_range: [32, 365],
    maturity_step: 10,
    min_class_b_percent: 10.0,
    target_class_b_coupon_rate: 30.0,
    additional_days_for_class_b: 10,
    // Gradient descent iÃ§in
    learning_rate: 0.01,
    max_iterations: 100,
    // Genetik algoritma iÃ§in
    population_size: 50,
    num_generations: 40,
    // Bayesian iÃ§in
    n_calls: 50,
    n_initial_points: 10
  });

  // Helper function to clear data
  const clearData = () => {
    setCashFlowData(null);
    setCalculationResultsWithStorage(null); // Use wrapper
    setOptimizationResultsWithStorage(null); // Use wrapper
    setError(null);
    
    // Also clear from localStorage
    localStorage.removeItem('calculationResults');
    localStorage.removeItem('optimizationResults');
  };

  // Create calculation request payload
  const createCalculationRequest = () => {
    return {
      general_settings: {
        start_date: generalSettings.start_date.toISOString().split('T')[0],
        operational_expenses: generalSettings.operational_expenses,
        min_buffer: generalSettings.min_buffer
      },
      tranches_a: tranchesA,
      tranche_b: trancheB,
      npv_settings: npvSettings
    };
  };

  // Create optimization request payload
  const createOptimizationRequest = () => {
    return {
      optimization_settings: optimizationSettings,
      general_settings: {
        start_date: generalSettings.start_date.toISOString().split('T')[0],
        operational_expenses: generalSettings.operational_expenses,
        min_buffer: generalSettings.min_buffer
      }
    };
  };

  const value = {
    // Data state
    cashFlowData,
    setCashFlowData,
    isLoading,
    setIsLoading,
    error,
    setError,
    
    // Form state
    generalSettings,
    setGeneralSettings,
    tranchesA,
    setTranchesA,
    trancheB,
    setTrancheB,
    npvSettings,
    setNpvSettings,
    
    // Results state - use wrapper functions instead of direct setState
    calculationResults,
    setCalculationResults: setCalculationResultsWithStorage,
    optimizationResults,
    setOptimizationResults: setOptimizationResultsWithStorage,
    previousCalculationResults,
    setPreviousCalculationResults: setPreviousCalculationResultsWithStorage,
    
    // Optimization settings
    optimizationSettings,
    setOptimizationSettings,
    
    // Helper functions
    clearData,
    createCalculationRequest,
    createOptimizationRequest
  };

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
};

======================================================================

DOSYA: src\pages\CalculationPage.js
==================================================
// frontend/src/pages/CalculationPage.js
import React, { useState } from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper, 
  Tabs, 
  Tab, 
  Button, 
  Alert,
  CircularProgress
} from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import { useData } from '../contexts/DataContext';
import { calculateResults } from '../services/apiService';
import GeneralSettingsForm from '../components/calculation/GeneralSettingsForm';
import TrancheAForm from '../components/calculation/TrancheAForm';
import TrancheBForm from '../components/calculation/TrancheBForm';
import CalculationResults from './CalculationResults';
import InterestRatesTable from '../components/calculation/InterestRatesTable';

const CalculationPage = () => {
  const { 
    cashFlowData,
    calculationResults, 
    setCalculationResults,
    isLoading,
    setIsLoading,
    error,
    setError,
    createCalculationRequest,
    previousCalculationResults
  } = useData();
  
  const [tabValue, setTabValue] = useState(0);

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  const handleCalculate = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      const request = createCalculationRequest();
      const results = await calculateResults(request);
      
      setCalculationResults(results);
      setTabValue(1); // Switch to results tab
      
      // Logging to ensure we have data for comparison
      console.log("Calculation results saved:", results);
      console.log("Previous results available:", previousCalculationResults ? "Yes" : "No");
    } catch (err) {
      setError('Calculation failed. Please check your parameters and try again.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  if (!cashFlowData) {
    return (
      <Container>
        <Box sx={{ mt: 4, textAlign: 'center' }}>
          <Typography variant="h5" color="error">
            Please upload cash flow data first
          </Typography>
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Typography variant="h4" gutterBottom>
        ABS Calculation
      </Typography>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>{error}</Alert>
      )}
      
      <Paper sx={{ mb: 4 }}>
        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tabs value={tabValue} onChange={handleTabChange}>
            <Tab label="Input Parameters" />
            <Tab label="Results" disabled={!calculationResults} />
            <Tab label="Interest Rates" disabled={!calculationResults} />
          </Tabs>
        </Box>
        
        <Box sx={{ p: 3 }}>
          {tabValue === 0 && (
            <>
              <GeneralSettingsForm />
              <TrancheAForm />
              <TrancheBForm />
              
              <Box sx={{ mt: 3, textAlign: 'center' }}>
                <Button
                  variant="contained"
                  color="primary"
                  size="large"
                  onClick={handleCalculate}
                  disabled={isLoading}
                  startIcon={isLoading ? <CircularProgress size={24} /> : <CalculateIcon />}
                >
                  {isLoading ? 'Calculating...' : 'Calculate Results'}
                </Button>
              </Box>
            </>
          )}
          
          {tabValue === 1 && calculationResults && (
            <CalculationResults results={calculationResults} />
          )}
          
          {tabValue === 2 && calculationResults && (
            <InterestRatesTable results={calculationResults} />
          )}
        </Box>
      </Paper>
    </Container>
  );
};

export default CalculationPage;

======================================================================

DOSYA: src\pages\CalculationResults.js
==================================================
// src/components/calculation/CalculationResults.js
import React, { useState } from "react";
import { 
  Box, 
  Typography, 
  Paper,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Divider,
  Chip,
  alpha,
  Tabs,
  Tab,
  Grid,
  Card,
  CardContent,
  useTheme,
} from "@mui/material";
import { BarChart, Bar, PieChart, Pie, Cell, LineChart, Line, ScatterChart, Scatter, ZAxis,
  XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, AreaChart, Area, ReferenceLine } from "recharts";
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';
import TimelineIcon from '@mui/icons-material/Timeline';
import PieChartIcon from '@mui/icons-material/PieChart';
import BarChartIcon from '@mui/icons-material/BarChart';
import AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';
import TableChartIcon from '@mui/icons-material/TableChart';
import ShowChartIcon from '@mui/icons-material/ShowChart';

// Custom tooltip component for charts
const CustomTooltip = ({ active, payload, label, formatter }) => {
  const theme = useTheme();
  if (active && payload && payload.length) {
    return (
      <Paper
        sx={{
          p: 1.5,
          boxShadow: "0 2px 12px rgba(0,0,0,0.15)",
          borderRadius: 1,
          border: "none",
          minWidth: 180,
        }}
      >
        <Typography variant="subtitle2" sx={{ mb: 0.5 }}>{label}</Typography>
        {payload.map((entry, index) => (
          <Box key={`item-${index}`} sx={{ color: entry.color, display: 'flex', justifyContent: 'space-between', my: 0.5 }}>
            <Typography variant="body2" sx={{ mr: 2 }}>
              {entry.name}:
            </Typography>
            <Typography variant="body2" fontWeight="medium">
              {formatter ? formatter(entry.value) : entry.value}
            </Typography>
          </Box>
        ))}
      </Paper>
    );
  }
  return null;
};

const CalculationResults = ({ results }) => {
  const theme = useTheme();
  const [tabValue, setTabValue] = useState(0);
  
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  if (!results) {
    return (
      <Paper sx={{ 
        p: 4, 
        textAlign: "center", 
        borderRadius: 2,
        backgroundColor: alpha(theme.palette.info.light, 0.08),
        border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`
      }}>
        <Typography variant="h6" color="text.secondary" gutterBottom>
          Results Not Available
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Please start the calculation process to view results
        </Typography>
      </Paper>
    );
  }
  
  // Format currency values
  const formatCurrency = (value) => {
    if (value === undefined || value === null) return "â‚º0.00";
    return new Intl.NumberFormat("tr-TR", { style: "currency", currency: "TRY" }).format(value);
  };
  
  // Format percentage values with null check
  const formatPercent = (value) => {
    if (value === undefined || value === null) return "0.00%";
    return `${value.toFixed(2)}%`;
  };

  // Extract color values from theme
  const classAColor = theme.palette.primary.main;
  const classBColor = theme.palette.secondary.main;
  
  // Calculate totals with null checks
  const totalClassA = results.class_a_total || 0;
  const totalClassB = results.class_b_total || 0;
  const totalAll = totalClassA + totalClassB;
  
  // Check if minimum buffer requirement is met
  const minBufferTarget = 5.0;
  const isBufferMet = (results.min_buffer_actual || 0) >= minBufferTarget;
  
  // Prepare data for tranche comparison chart
  const classComparisonData = [
    {
      name: "Class A",
      principal: results.class_a_principal || 0,
      interest: results.class_a_interest || 0,
      total: results.class_a_total || 0,
      color: classAColor
    },
    {
      name: "Class B",
      principal: results.class_b_principal || 0,
      coupon: results.class_b_coupon || 0,
      total: results.class_b_total || 0,
      color: classBColor
    },
  ];
  
  // Prepare data for pie chart
  const pieData = [
    { name: 'Class A', value: totalClassA, color: classAColor },
    { name: 'Class B', value: totalClassB, color: classBColor }
  ];
  
  // Prepare data for tranche-level charts
  const trancheDetails = results.tranche_results ? results.tranche_results.map(t => ({
    name: t["Tranche"],
    principal: t["Principal"],
    interest: t["Is Class A"] ? t["Interest"] : t["Coupon Payment"],
    total: t["Total Payment"],
    buffer: t["Buffer Cash Flow Ratio (%)"],
    maturity: t["Maturity Days"],
    isClassA: t["Is Class A"],
    bufferIn: t["Buffer In"],
    cashFlow: t["Cash Flow Total"],
    reinvestment: t["Reinvestment Return"],
    bufferReinvestment: t["Buffer Reinvestment"],
    totalAvailable: t["Total Available"],
  })) : [];
  
  // Prepare data for timeline/maturity chart
  const maturityData = trancheDetails.map(t => ({
    ...t,
    x: t.maturity,
    y: t.total,
    z: t.isClassA ? 30 : 60, // Size for scatter plot
  }));
  
  // Prepare buffer ratio chart data
  const bufferData = trancheDetails
    .filter(t => t.isClassA)
    .map(t => ({
      name: t.name,
      buffer: t.buffer,
      minimum: minBufferTarget
    }));
    
  // Cash flow components data
  const cashFlowComponentsData = trancheDetails.map(t => ({
    name: t.name,
    cashFlow: t.cashFlow,
    reinvestment: t.reinvestment,
    bufferIn: t.bufferIn,
    bufferReinvestment: t.bufferReinvestment,
  }));
  
  // Financing cost analysis data for visualization
  const financingData = [
    { name: 'Total Loan Principal', value: results.total_loan_principal },
    { name: 'Total Principal Paid', value: results.total_principal_paid },
  ];
  
  // Color palette for multiple tranches
  const getTrancheColor = (index, isClassA) => {
    if (isClassA) {
      const colors = [
        theme.palette.primary.main,
        theme.palette.primary.light,
        alpha(theme.palette.primary.main, 0.8),
        alpha(theme.palette.primary.main, 0.6),
        alpha(theme.palette.primary.main, 0.4),
      ];
      return colors[index % colors.length];
    } else {
      const colors = [
        theme.palette.secondary.main,
        theme.palette.secondary.light,
        alpha(theme.palette.secondary.main, 0.8),
        alpha(theme.palette.secondary.main, 0.6),
        alpha(theme.palette.secondary.main, 0.4),
      ];
      return colors[index % colors.length];
    }
  };
  
  // Chart configuration
  const chartConfig = {
    height: 350,
    margin: { top: 20, right: 30, left: 20, bottom: 20 },
  };

  return (
    <Box>
      {/* Summary Section */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.primary.main, 0.03),
          borderRadius: 2
        }}
      >
        <Typography variant="h6" color="primary.main" fontWeight="medium" gutterBottom>
          Calculation Results Summary
        </Typography>
        
        <Box sx={{ display: "flex", flexWrap: "wrap", gap: 3, mt: 2 }}>
          <Box sx={{ 
            flex: "1 0 300px", 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle1" gutterBottom color="text.secondary" fontWeight="medium">
              Payment Totals
            </Typography>
            <TableContainer sx={{ mt: 1 }}>
              <Table size="small">
                <TableBody>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Class A Total</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(totalClassA)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Chip 
                        size="small" 
                        label={formatPercent(totalAll > 0 ? (totalClassA / totalAll * 100) : 0)}
                        sx={{ 
                          bgcolor: alpha(theme.palette.primary.main, 0.1),
                          color: theme.palette.primary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Class B Total</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(totalClassB)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Chip 
                        size="small" 
                        label={formatPercent(totalAll > 0 ? (totalClassB / totalAll * 100) : 0)}
                        sx={{ 
                          bgcolor: alpha(theme.palette.secondary.main, 0.1),
                          color: theme.palette.secondary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                  <TableRow sx={{ "& td": { fontWeight: 600 } }}>
                    <TableCell sx={{ pl: 0 }}>Grand Total</TableCell>
                    <TableCell align="right">{formatCurrency(totalAll)}</TableCell>
                    <TableCell align="right">
                      <Chip 
                        size="small" 
                        label="100.00%"
                        sx={{ 
                          bgcolor: alpha(theme.palette.info.main, 0.1),
                          color: theme.palette.info.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
          
          <Box sx={{ 
            flex: "1 0 300px", 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle1" gutterBottom color="text.secondary" fontWeight="medium">
              Principal and Interest
            </Typography>
            <TableContainer sx={{ mt: 1 }}>
              <Table size="small">
                <TableBody>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: classAColor,
                            mr: 1 
                          }} 
                        />
                        Class A
                      </Box>
                    </TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_a_principal)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_a_interest)}</TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: classBColor,
                            mr: 1 
                          }} 
                        />
                        Class B
                      </Box>
                    </TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_b_principal)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_b_coupon)}</TableCell>
                  </TableRow>
                  <TableRow sx={{ "& td": { fontWeight: 600 } }}>
                    <TableCell sx={{ pl: 0 }}>Total</TableCell>
                    <TableCell align="right">
                      {formatCurrency((results.class_a_principal || 0) + (results.class_b_principal || 0))}
                    </TableCell>
                    <TableCell align="right">
                      {formatCurrency((results.class_a_interest || 0) + (results.class_b_coupon || 0))}
                    </TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
        </Box>
        
        <Divider sx={{ my: 3, opacity: 0.6 }} />
        
        <Box sx={{ 
          display: 'flex', 
          gap: 4, 
          flexWrap: 'wrap',
          backgroundColor: isBufferMet ? alpha(theme.palette.success.main, 0.08) : alpha(theme.palette.error.main, 0.08),
          p: 2,
          borderRadius: 1
        }}>
          <Box>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Minimum Buffer Requirement
            </Typography>
            <Typography variant="h6" sx={{ mt: 0.5 }}>
              {formatPercent(minBufferTarget)}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Actual Minimum Buffer (Class A)
            </Typography>
            <Typography variant="h6" color={isBufferMet ? "success.main" : "error.main"} sx={{ mt: 0.5 }}>
              {formatPercent(results.min_buffer_actual)}
            </Typography>
          </Box>
          
          <Box sx={{ ml: 'auto' }}>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Status
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
              {isBufferMet ? (
                <CheckCircleOutlineIcon color="success" sx={{ mr: 1 }} />
              ) : (
                <ErrorOutlineIcon color="error" sx={{ mr: 1 }} />
              )}
              <Typography 
                variant="h6" 
                color={isBufferMet ? "success.main" : "error.main"}
              >
                {isBufferMet ? "Requirement Met" : "Requirement Not Met"}
              </Typography>
            </Box>
          </Box>
        </Box>
      </Paper>
      
      {/* Chart and Table Tabs */}
      <Box sx={{ mb: 4 }}>
        <Tabs 
          value={tabValue} 
          onChange={handleTabChange}
          variant="scrollable"
          scrollButtons="auto"
          sx={{
            mb: 2,
            '& .MuiTab-root': {
              minWidth: 'auto',
              px: 3
            }
          }}
        >
          <Tab icon={<PieChartIcon />} label="Overview" iconPosition="start" />
          <Tab icon={<BarChartIcon />} label="Tranche Details" iconPosition="start" />
          <Tab icon={<TimelineIcon />} label="Maturity Analysis" iconPosition="start" />
          <Tab icon={<ShowChartIcon />} label="Cash Flow Analysis" iconPosition="start" />
          <Tab icon={<AccountBalanceWalletIcon />} label="Financing" iconPosition="start" />
          <Tab icon={<TableChartIcon />} label="Detailed Table" iconPosition="start" />
        </Tabs>
        
        {/* Tab 1: Overview Charts */}
        {tabValue === 0 && (
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  height: '100%',
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Distribution by Class
                </Typography>
                <Box sx={{ height: chartConfig.height, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <PieChart margin={chartConfig.margin}>
                      <Pie
                        data={pieData}
                        dataKey="value"
                        nameKey="name"
                        cx="50%"
                        cy="50%"
                        outerRadius={100}
                        innerRadius={60}
                        labelLine={false}
                        label={({ name, percent }) => `${name} (${(percent * 100).toFixed(1)}%)`}
                      >
                        {pieData.map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={entry.color} />
                        ))}
                      </Pie>
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                    </PieChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  height: '100%',
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Principal vs Interest/Coupon
                </Typography>
                <Box sx={{ height: chartConfig.height, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={classComparisonData}
                      margin={chartConfig.margin}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis dataKey="name" />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="principal" 
                        name="Principal" 
                        stackId="a" 
                        fill={theme.palette.primary.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="interest" 
                        name="Interest" 
                        stackId="a" 
                        fill={theme.palette.info.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="coupon" 
                        name="Coupon" 
                        stackId="a" 
                        fill={theme.palette.secondary.main}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 3, 
                  mb: 3, 
                  border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`,
                  backgroundColor: alpha(theme.palette.info.main, 0.03),
                  borderRadius: 2
                }}
              >
                <Typography variant="h6" color="info.main" gutterBottom fontWeight="medium">
                  Financing Cost Analysis
                </Typography>
                
                <Grid container spacing={3}>
                  <Grid item xs={12} md={6}>
                    <Box sx={{ 
                      mt: 2,
                      p: 2,
                      bgcolor: 'background.paper', 
                      borderRadius: 1,
                      boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
                    }}>
                      <TableContainer>
                        <Table>
                          <TableBody>
                            <TableRow>
                              <TableCell sx={{ pl: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Total Principal Paid to Bank:</TableCell>
                              <TableCell align="right" sx={{ fontWeight: 600, pr: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                                {formatCurrency(results.total_principal_paid)}
                              </TableCell>
                            </TableRow>
                            <TableRow>
                              <TableCell sx={{ pl: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Total Loan Principal:</TableCell>
                              <TableCell align="right" sx={{ pr: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                                {formatCurrency(results.total_loan_principal)}
                              </TableCell>
                            </TableRow>
                            <TableRow>
                              <TableCell sx={{ pl: 2, fontWeight: 600 }}>
                                Financing {(results.financing_cost || 0) > 0 ? "Profit" : "Loss"}:
                              </TableCell>
                              <TableCell 
                                align="right" 
                                sx={{ 
                                  fontWeight: 600,
                                  pr: 2,
                                  color: (results.financing_cost || 0) > 0 ? "success.main" : "error.main"
                                }}
                              >
                                {formatCurrency(Math.abs(results.financing_cost || 0))}
                              </TableCell>
                            </TableRow>
                          </TableBody>
                        </Table>
                      </TableContainer>
                    </Box>
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <Box sx={{ height: 250 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <BarChart
                          data={financingData}
                          margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
                          layout="vertical"
                        >
                          <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                          <XAxis type="number" tickFormatter={(value) => `â‚º${value/1000000}M`} />
                          <YAxis type="category" dataKey="name" />
                          <Tooltip 
                            content={<CustomTooltip formatter={(value) => formatCurrency(value)} />} 
                          />
                          <Bar 
                            dataKey="value" 
                            fill={(results.financing_cost || 0) > 0 ? theme.palette.success.light : theme.palette.error.light}
                            radius={4}
                            barSize={30}
                          />
                        </BarChart>
                      </ResponsiveContainer>
                    </Box>
                  </Grid>
                </Grid>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 2: Tranche Details */}
        {tabValue === 1 && (
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Tranche Payments Breakdown
                </Typography>
                <Box sx={{ height: 400, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={trancheDetails}
                      margin={{ top: 20, right: 30, left: 20, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name" 
                        angle={-45}
                        textAnchor="end"
                        height={60}
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="principal" 
                        name="Principal" 
                        fill={theme.palette.primary.dark}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="interest" 
                        name="Interest/Coupon" 
                        fill={theme.palette.secondary.light}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Individual Tranche Amounts
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={trancheDetails}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name"
                        angle={-45}
                        textAnchor="end"
                        height={60}  
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Bar 
                        dataKey="total" 
                        name="Total Payment" 
                        radius={[4, 4, 0, 0]}
                      >
                        {trancheDetails.map((entry, index) => (
                          <Cell 
                            key={`cell-${index}`} 
                            fill={getTrancheColor(index, entry.isClassA)} 
                          />
                        ))}
                      </Bar>
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Buffer Analysis (Class A)
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={bufferData}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name"
                        angle={-45}
                        textAnchor="end"
                        height={60}  
                      />
                      <YAxis tickFormatter={(value) => `${value}%`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => `${value.toFixed(2)}%`} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="buffer" 
                        name="Buffer Ratio" 
                        fill={theme.palette.success.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="minimum" 
                        name="Minimum Requirement" 
                        fill={theme.palette.error.light}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 3: Maturity Analysis */}
        {tabValue === 2 && (
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Maturity Distribution
                </Typography>
                <Box sx={{ height: 400, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <ScatterChart
                      margin={{ top: 20, right: 30, left: 20, bottom: 10 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        type="number" 
                        dataKey="maturity" 
                        name="Maturity" 
                        unit=" days" 
                        domain={[0, 'dataMax + 30']}
                      />
                      <YAxis 
                        type="number" 
                        dataKey="total" 
                        name="Total Payment" 
                        tickFormatter={(value) => `â‚º${value/1000000}M`}
                      />
                      <ZAxis range={[60, 200]} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value, name) => 
                          name === "Maturity" ? `${value} days` : formatCurrency(value)
                        } />}
                        cursor={{ strokeDasharray: '3 3' }}
                      />
                      <Legend />
                      <Scatter 
                        name="Tranche Payments" 
                        data={maturityData}
                        fill={theme.palette.primary.main}
                      >
                        {maturityData.map((entry, index) => (
                          <Cell 
                            key={`cell-${index}`} 
                            fill={getTrancheColor(index, entry.isClassA)} 
                          />
                        ))}
                      </Scatter>
                    </ScatterChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Payment Timeline
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <LineChart
                      data={trancheDetails}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="maturity"
                        type="number"
                        domain={['dataMin', 'dataMax']}
                        label={{ 
                          value: 'Maturity (days)', 
                          position: 'insideBottomRight', 
                          offset: -10 
                        }}
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value, name) => 
                          name === "maturity" ? `${value} days` : formatCurrency(value)
                        } />}
                      />
                      <Legend />
                      <Line 
                        type="monotone" 
                        dataKey="total" 
                        name="Total Payment" 
                        stroke={theme.palette.primary.main}
                        strokeWidth={2}
                        dot={{ r: 6 }}
                        activeDot={{ r: 8 }}
                      />
                    </LineChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Maturity vs. Buffer Ratio
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <ScatterChart
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        type="number"
                        dataKey="maturity"
                        name="Maturity"
                        unit=" days"
                        label={{ 
                          value: 'Maturity (days)', 
                          position: 'insideBottomRight', 
                          offset: -10 
                        }}
                      />
                      <YAxis 
                        type="number"
                        dataKey="buffer"
                        name="Buffer Ratio"
                        unit="%"
                      />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value, name) => 
                          name === "Maturity" ? `${value} days` : `${value.toFixed(2)}%`
                        } />}
                      />
                      <ReferenceLine 
                        y={minBufferTarget}
                        stroke={theme.palette.error.main}
                        strokeDasharray="3 3"
                        label={{ 
                          value: 'Minimum Requirement', 
                          position: 'insideTopRight',
                          fill: theme.palette.error.main,
                          fontSize: 12
                        }}
                      />
                      <Scatter 
                        name="Class A Tranches" 
                        data={trancheDetails.filter(t => t.isClassA)}
                        fill={theme.palette.primary.main}
                      >
                        {trancheDetails
                          .filter(t => t.isClassA)
                          .map((entry, index) => (
                            <Cell 
                              key={`cell-${index}`} 
                              fill={entry.buffer >= minBufferTarget 
                                ? theme.palette.success.main
                                : theme.palette.error.main
                              } 
                            />
                        ))}
                      </Scatter>
                    </ScatterChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 4: Cash Flow Analysis */}
        {tabValue === 3 && (
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Cash Flow Components by Tranche
                </Typography>
                <Box sx={{ height: 400, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={cashFlowComponentsData}
                      margin={{ top: 20, right: 30, left: 20, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name" 
                        angle={-45}
                        textAnchor="end"
                        height={60}
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="cashFlow" 
                        name="Cash Flow" 
                        fill={theme.palette.primary.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="reinvestment" 
                        name="Reinvestment Return" 
                        fill={theme.palette.secondary.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="bufferIn" 
                        name="Buffer In" 
                        fill={theme.palette.info.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="bufferReinvestment" 
                        name="Buffer Reinvestment" 
                        fill={theme.palette.warning.main}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Available vs Payment
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={trancheDetails}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name"
                        angle={-45}
                        textAnchor="end"
                        height={60}  
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="totalAvailable" 
                        name="Total Available" 
                        fill={theme.palette.success.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="total" 
                        name="Total Payment" 
                        fill={theme.palette.primary.main}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Cash Flow Components
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <AreaChart
                      data={cashFlowComponentsData}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name"
                        angle={-45}
                        textAnchor="end"
                        height={60}  
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Area 
                        type="monotone" 
                        dataKey="cashFlow" 
                        name="Cash Flow" 
                        stackId="1"
                        stroke={theme.palette.primary.main}
                        fill={alpha(theme.palette.primary.main, 0.6)}
                      />
                      <Area 
                        type="monotone" 
                        dataKey="reinvestment" 
                        name="Reinvestment" 
                        stackId="1"
                        stroke={theme.palette.secondary.main}
                        fill={alpha(theme.palette.secondary.main, 0.6)}
                      />
                      <Area 
                        type="monotone" 
                        dataKey="bufferIn" 
                        name="Buffer In" 
                        stackId="1"
                        stroke={theme.palette.info.main}
                        fill={alpha(theme.palette.info.main, 0.6)}
                      />
                    </AreaChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 5: Financing Analysis */}
        {tabValue === 4 && (
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 3, 
                  border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`,
                  backgroundColor: alpha(theme.palette.info.main, 0.03),
                  borderRadius: 2
                }}
              >
                <Typography variant="h6" color="info.main" gutterBottom fontWeight="medium">
                  Financing Cost Analysis
                </Typography>
                
                <Grid container spacing={4}>
                  <Grid item xs={12} md={6}>
                    <Box sx={{ 
                      p: 3,
                      bgcolor: 'background.paper', 
                      borderRadius: 2,
                      boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
                    }}>
                      <Typography variant="subtitle1" gutterBottom color="text.secondary" fontWeight="medium">
                        Key Metrics
                      </Typography>
                      
                      <Box sx={{ mt: 2 }}>
                        <Grid container spacing={2}>
                          <Grid item xs={6}>
                            <Typography variant="body2" color="text.secondary">Total Loan Principal</Typography>
                            <Typography variant="h6" fontWeight="medium">{formatCurrency(results.total_loan_principal)}</Typography>
                          </Grid>
                          <Grid item xs={6}>
                            <Typography variant="body2" color="text.secondary">Principal Paid to Bank</Typography>
                            <Typography variant="h6" fontWeight="medium">{formatCurrency(results.total_principal_paid)}</Typography>
                          </Grid>
                          <Grid item xs={12}>
                            <Divider sx={{ my: 2 }} />
                          </Grid>
                          <Grid item xs={6}>
                            <Typography variant="body2" color="text.secondary">Financing Result</Typography>
                            <Typography 
                              variant="h5" 
                              fontWeight="medium"
                              color={(results.financing_cost || 0) > 0 ? "success.main" : "error.main"}
                            >
                              {(results.financing_cost || 0) > 0 ? "PROFIT" : "LOSS"}
                            </Typography>
                          </Grid>
                          <Grid item xs={6}>
                            <Typography variant="body2" color="text.secondary">Amount</Typography>
                            <Typography 
                              variant="h5" 
                              fontWeight="medium"
                              color={(results.financing_cost || 0) > 0 ? "success.main" : "error.main"}
                            >
                              {formatCurrency(Math.abs(results.financing_cost || 0))}
                            </Typography>
                          </Grid>
                        </Grid>
                      </Box>
                    </Box>
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <Box sx={{ height: 300 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <BarChart
                          data={financingData}
                          margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                        >
                          <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                          <XAxis dataKey="name" />
                          <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                          <Tooltip 
                            content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                          />
                          <Legend />
                          <Bar 
                            dataKey="value" 
                            name="Amount" 
                            radius={[4, 4, 0, 0]}
                          >
                            {financingData.map((entry, index) => (
                              <Cell 
                                key={`cell-${index}`} 
                                fill={index === 0 
                                  ? theme.palette.info.main 
                                  : theme.palette.primary.main
                                } 
                              />
                            ))}
                          </Bar>
                        </BarChart>
                      </ResponsiveContainer>
                    </Box>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <Box sx={{ 
                      p: 3,
                      bgcolor: 'background.paper', 
                      borderRadius: 2,
                      boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
                    }}>
                      <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                        Financing Analysis
                      </Typography>
                      
                      <Typography variant="body1" paragraph>
                        The total principal paid to the bank is {formatCurrency(results.total_principal_paid)}, while the total loan principal is {formatCurrency(results.total_loan_principal)}.
                      </Typography>
                      
                      {(results.financing_cost || 0) > 0 ? (
                        <Typography variant="body1" paragraph>
                          This results in a <strong>financing profit of {formatCurrency(Math.abs(results.financing_cost || 0))}</strong>, representing a positive return on the securitization structure.
                        </Typography>
                      ) : (
                        <Typography variant="body1" paragraph>
                          This results in a <strong>financing loss of {formatCurrency(Math.abs(results.financing_cost || 0))}</strong>, indicating a cost of the securitization structure.
                        </Typography>
                      )}
                      
                      <Typography variant="body1">
                        The total principal of the ABS structure (Class A + Class B) is {formatCurrency((results.class_a_principal || 0) + (results.class_b_principal || 0))}, with total interest and coupon payments of {formatCurrency((results.class_a_interest || 0) + (results.class_b_coupon || 0))}.
                      </Typography>
                    </Box>
                  </Grid>
                </Grid>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 6: Detailed Table */}
        {tabValue === 5 && (
          <Box>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
                backgroundColor: 'background.paper',
                borderRadius: 2
              }}
            >
              <Typography variant="h6" gutterBottom fontWeight="medium">
                Detailed Tranche Results
              </Typography>
              
              {results.tranche_results && results.tranche_results.length > 0 ? (
                <TableContainer sx={{ 
                  maxHeight: 440,
                  mt: 2,
                  borderRadius: 1,
                  boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
                }}>
                  <Table stickyHeader>
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Tranche</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Days</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Date</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Principal</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Interest / Coupon</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Total Payment</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Buffer Ratio (%)</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {results.tranche_results.map((tranche, index) => (
                        <TableRow 
                          key={index}
                          sx={{ 
                            backgroundColor: tranche["Is Class A"] 
                              ? alpha(theme.palette.primary.main, 0.03)
                              : alpha(theme.palette.secondary.main, 0.03),
                            '&:hover': {
                              backgroundColor: tranche["Is Class A"] 
                                ? alpha(theme.palette.primary.main, 0.07)
                                : alpha(theme.palette.secondary.main, 0.07),
                            }
                          }}
                        >
                          <TableCell>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                              <Box 
                                component="span" 
                                sx={{ 
                                  display: 'inline-block', 
                                  width: 10, 
                                  height: 10, 
                                  borderRadius: '50%', 
                                  bgcolor: tranche["Is Class A"] ? classAColor : classBColor,
                                  mr: 1 
                                }} 
                              />
                              {tranche["Tranche"]}
                            </Box>
                          </TableCell>
                          <TableCell>{tranche["Maturity Days"]}</TableCell>
                          <TableCell>{tranche["Maturity Date"]}</TableCell>
                          <TableCell>{formatCurrency(tranche["Principal"])}</TableCell>
                          <TableCell>
                            {formatCurrency(
                              tranche["Is Class A"] ? tranche["Interest"] : tranche["Coupon Payment"]
                            )}
                          </TableCell>
                          <TableCell>{formatCurrency(tranche["Total Payment"])}</TableCell>
                          <TableCell>
                            <Chip 
                              size="small" 
                              label={formatPercent(tranche["Buffer Cash Flow Ratio (%)"])}
                              sx={{ 
                                bgcolor: 
                                  tranche["Buffer Cash Flow Ratio (%)"] >= minBufferTarget
                                    ? alpha(theme.palette.success.main, 0.1)
                                    : alpha(theme.palette.warning.main, 0.1),
                                color: 
                                  tranche["Buffer Cash Flow Ratio (%)"] >= minBufferTarget
                                    ? theme.palette.success.main
                                    : theme.palette.warning.main,
                                fontWeight: 500,
                                fontSize: '0.75rem'
                              }}
                            />
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              ) : (
                <Typography variant="body2" color="text.secondary" sx={{ py: 3, textAlign: "center" }}>
                  Detailed results are not available yet
                </Typography>
              )}
            </Paper>
          </Box>
        )}
      </Box>
    </Box>
  );
};

export default CalculationResults;

======================================================================

DOSYA: src\pages\ComparisonPage.js
==================================================
// src/pages/ComparisonPage.js
import React, { useState } from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper, 
  Tabs, 
  Tab, 
  Grid, 
  Card, 
  CardContent, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Chip,
  Divider,
  alpha,
  useTheme
} from '@mui/material';
import { useData } from '../contexts/DataContext';
import CompareIcon from '@mui/icons-material/Compare';
import AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';
import BarChartIcon from '@mui/icons-material/BarChart';
import PieChartIcon from '@mui/icons-material/PieChart';
import TimelineIcon from '@mui/icons-material/Timeline';
import { 
  BarChart, Bar, PieChart, Pie, Cell, LineChart, Line, 
  XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, 
  Area, AreaChart, ScatterChart, Scatter, ZAxis
} from "recharts";

const ComparisonPage = () => {
  const theme = useTheme();
  const { calculationResults, previousCalculationResults } = useData();
  const [tabValue, setTabValue] = useState(0);

  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };

  // Format currency values
  const formatCurrency = (value) => {
    if (value === undefined || value === null) return "â‚º0.00";
    return new Intl.NumberFormat("tr-TR", { style: "currency", currency: "TRY" }).format(value);
  };
  
  // Format percentage values
  const formatPercent = (value) => {
    if (value === undefined || value === null) return "0.00%";
    return `${value.toFixed(2)}%`;
  };

  // Calculate percentage difference
  const calculateDifference = (current, previous) => {
    if (!current || !previous || previous === 0) return null;
    return ((current - previous) / previous) * 100;
  };

  // Format difference with color and sign
  const formatDifference = (diff) => {
    if (diff === null) return "-";
    const isPositive = diff > 0;
    return (
      <Typography 
        variant="body2" 
        sx={{ 
          color: isPositive ? 'success.main' : 'error.main',
          fontWeight: 'medium',
          display: 'flex',
          alignItems: 'center'
        }}
      >
        {isPositive ? '+' : ''}{diff.toFixed(2)}%
      </Typography>
    );
  };

  // Check if we have data to compare
  if (!calculationResults || !previousCalculationResults) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
        <Paper 
          elevation={0}
          sx={{ 
            p: 4, 
            textAlign: 'center',
            borderRadius: 2,
            backgroundColor: alpha(theme.palette.info.main, 0.05),
            border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`
          }}
        >
          <CompareIcon sx={{ fontSize: 60, color: theme.palette.info.main, opacity: 0.7, mb: 2 }} />
          <Typography variant="h5" gutterBottom>
            Comparison Data Not Available
          </Typography>
          <Typography variant="body1" color="text.secondary">
            To compare results, first calculate your initial structure, then apply an optimization result and calculate again.
          </Typography>
        </Paper>
      </Container>
    );
  }

  // Extract relevant data for comparison
  const current = {
    classATotal: calculationResults.class_a_total || 0,
    classBTotal: calculationResults.class_b_total || 0,
    classAPrincipal: calculationResults.class_a_principal || 0,
    classBPrincipal: calculationResults.class_b_principal || 0,
    classAInterest: calculationResults.class_a_interest || 0,
    classBCoupon: calculationResults.class_b_coupon || 0,
    minBufferActual: calculationResults.min_buffer_actual || 0,
    totalPrincipalPaid: calculationResults.total_principal_paid || 0,
    totalLoanPrincipal: calculationResults.total_loan_principal || 0,
    financingCost: calculationResults.financing_cost || 0,
    trancheResults: calculationResults.tranche_results || []
  };

  const previous = {
    classATotal: previousCalculationResults.class_a_total || 0,
    classBTotal: previousCalculationResults.class_b_total || 0,
    classAPrincipal: previousCalculationResults.class_a_principal || 0,
    classBPrincipal: previousCalculationResults.class_b_principal || 0,
    classAInterest: previousCalculationResults.class_a_interest || 0,
    classBCoupon: previousCalculationResults.class_b_coupon || 0,
    minBufferActual: previousCalculationResults.min_buffer_actual || 0,
    totalPrincipalPaid: previousCalculationResults.total_principal_paid || 0,
    totalLoanPrincipal: previousCalculationResults.total_loan_principal || 0,
    financingCost: previousCalculationResults.financing_cost || 0,
    trancheResults: previousCalculationResults.tranche_results || []
  };

  // Calculate differences
  const diff = {
    classATotal: calculateDifference(current.classATotal, previous.classATotal),
    classBTotal: calculateDifference(current.classBTotal, previous.classBTotal),
    classAPrincipal: calculateDifference(current.classAPrincipal, previous.classAPrincipal),
    classBPrincipal: calculateDifference(current.classBPrincipal, previous.classBPrincipal),
    classAInterest: calculateDifference(current.classAInterest, previous.classAInterest),
    classBCoupon: calculateDifference(current.classBCoupon, previous.classBCoupon),
    minBufferActual: calculateDifference(current.minBufferActual, previous.minBufferActual),
    totalPrincipalPaid: calculateDifference(current.totalPrincipalPaid, previous.totalPrincipalPaid),
    financingCost: calculateDifference(
      Math.abs(current.financingCost), 
      Math.abs(previous.financingCost)
    ),
  };

  // Prepare data for tranche comparison charts
  const trancheComparisonData = [
    {
      name: "Class A",
      current: current.classATotal,
      previous: previous.classATotal,
      diff: diff.classATotal
    },
    {
      name: "Class B",
      current: current.classBTotal,
      previous: previous.classBTotal,
      diff: diff.classBTotal
    }
  ];

  // Prepare data for principal-interest breakdown
  const breakdownData = [
    {
      name: "Class A Principal",
      current: current.classAPrincipal,
      previous: previous.classAPrincipal,
      diff: diff.classAPrincipal
    },
    {
      name: "Class A Interest",
      current: current.classAInterest,
      previous: previous.classAInterest,
      diff: diff.classAInterest
    },
    {
      name: "Class B Principal",
      current: current.classBPrincipal,
      previous: previous.classBPrincipal,
      diff: diff.classBPrincipal
    },
    {
      name: "Class B Coupon",
      current: current.classBCoupon,
      previous: previous.classBCoupon,
      diff: diff.classBCoupon
    }
  ];

  // Financing comparison data
  const financingData = [
    {
      name: "Total Principal Paid",
      current: current.totalPrincipalPaid,
      previous: previous.totalPrincipalPaid,
      diff: diff.totalPrincipalPaid
    },
    {
      name: "Total Loan Principal",
      current: current.totalLoanPrincipal,
      previous: previous.totalLoanPrincipal,
      diff: 0  // Usually this doesn't change
    },
    {
      name: "Financing Result",
      current: Math.abs(current.financingCost),
      previous: Math.abs(previous.financingCost),
      diff: diff.financingCost,
      isProfit: current.financingCost > 0
    }
  ];

  // Chart colors
  const previousColor = theme.palette.grey[500];
  const currentColor = theme.palette.primary.main;
  const diffColor = theme.palette.secondary.main;
  
  // Helper function for custom tooltip
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <Paper sx={{ p: 1.5, borderRadius: 1, boxShadow: 2 }}>
          <Typography variant="body2" fontWeight="medium">{label}</Typography>
          {payload.map((entry, index) => (
            <Box key={`tooltip-${index}`} sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
              <Typography variant="body2" sx={{ mr: 2, color: entry.color }}>
                {entry.name}:
              </Typography>
              <Typography variant="body2" fontWeight="medium">
                {entry.name.includes('diff') 
                  ? `${entry.value > 0 ? '+' : ''}${entry.value.toFixed(2)}%` 
                  : formatCurrency(entry.value)}
              </Typography>
            </Box>
          ))}
        </Paper>
      );
    }
    return null;
  };

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
        <CompareIcon sx={{ fontSize: 28, color: theme.palette.primary.main, mr: 2 }} />
        <Typography variant="h4" component="h1" gutterBottom>
          Results Comparison
        </Typography>
      </Box>
      
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 4, 
          borderRadius: 2,
          border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.primary.main, 0.03)
        }}
      >
        <Typography variant="h6" color="primary.main" gutterBottom fontWeight="medium">
          Comparison Summary
        </Typography>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <Card elevation={0} sx={{ height: '100%', backgroundColor: 'transparent', border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}` }}>
              <CardContent>
                <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                  Total Structure Size
                </Typography>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body2">Previous:</Typography>
                  <Typography variant="h6">
                    {formatCurrency(previous.classATotal + previous.classBTotal)}
                  </Typography>
                </Box>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body2">Current:</Typography>
                  <Typography variant="h6" color="primary.main">
                    {formatCurrency(current.classATotal + current.classBTotal)}
                  </Typography>
                </Box>
                <Divider sx={{ my: 1 }} />
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <Typography variant="body2" fontWeight="medium">Difference:</Typography>
                  {formatDifference(calculateDifference(
                    current.classATotal + current.classBTotal,
                    previous.classATotal + previous.classBTotal
                  ))}
                </Box>
              </CardContent>
            </Card>
          </Grid>
          
          <Grid item xs={12} md={4}>
            <Card elevation={0} sx={{ height: '100%', backgroundColor: 'transparent', border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}` }}>
              <CardContent>
                <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                  Minimum Buffer (Class A)
                </Typography>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body2">Previous:</Typography>
                  <Typography variant="h6">
                    {formatPercent(previous.minBufferActual)}
                  </Typography>
                </Box>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body2">Current:</Typography>
                  <Typography variant="h6" color="primary.main">
                    {formatPercent(current.minBufferActual)}
                  </Typography>
                </Box>
                <Divider sx={{ my: 1 }} />
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <Typography variant="body2" fontWeight="medium">Difference:</Typography>
                  {formatDifference(diff.minBufferActual)}
                </Box>
              </CardContent>
            </Card>
          </Grid>
          
          <Grid item xs={12} md={4}>
            <Card elevation={0} sx={{ height: '100%', backgroundColor: 'transparent', border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}` }}>
              <CardContent>
                <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                  Financing Result
                </Typography>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body2">Previous:</Typography>
                  <Typography variant="h6" color={previous.financingCost > 0 ? "success.main" : "error.main"}>
                    {previous.financingCost > 0 ? "Profit" : "Loss"}: {formatCurrency(Math.abs(previous.financingCost))}
                  </Typography>
                </Box>
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                  <Typography variant="body2">Current:</Typography>
                  <Typography variant="h6" color={current.financingCost > 0 ? "success.main" : "error.main"}>
                    {current.financingCost > 0 ? "Profit" : "Loss"}: {formatCurrency(Math.abs(current.financingCost))}
                  </Typography>
                </Box>
                <Divider sx={{ my: 1 }} />
                <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <Typography variant="body2" fontWeight="medium">Difference:</Typography>
                  {formatDifference(diff.financingCost)}
                </Box>
              </CardContent>
            </Card>
          </Grid>
        </Grid>
      </Paper>
      
      {/* Tabs for different comparison views */}
      <Box sx={{ mb: 3 }}>
        <Tabs 
          value={tabValue} 
          onChange={handleTabChange}
          variant="scrollable"
          scrollButtons="auto"
          sx={{
            mb: 2,
            '& .MuiTab-root': {
              minWidth: 'auto',
              px: 3
            }
          }}
        >
          <Tab icon={<PieChartIcon />} label="Structure Comparison" iconPosition="start" />
          <Tab icon={<BarChartIcon />} label="Tranches Breakdown" iconPosition="start" />
          <Tab icon={<AccountBalanceWalletIcon />} label="Financing Comparison" iconPosition="start" />
          <Tab icon={<TimelineIcon />} label="Tranche Details" iconPosition="start" />
        </Tabs>
      </Box>
      
      {/* Tab 1: Structure Comparison */}
      {tabValue === 0 && (
        <Grid container spacing={4}>
          <Grid item xs={12}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`
              }}
            >
              <Typography variant="h6" gutterBottom fontWeight="medium">
                Class Structure Comparison
              </Typography>
              
              <Box sx={{ height: 400, mt: 2 }}>
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart
                    data={trancheComparisonData}
                    margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                    <XAxis dataKey="name" />
                    <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                    <Tooltip content={<CustomTooltip />} />
                    <Legend />
                    <Bar dataKey="previous" name="Previous" fill={previousColor} />
                    <Bar dataKey="current" name="Current" fill={currentColor} />
                  </BarChart>
                </ResponsiveContainer>
              </Box>
              
              <Divider sx={{ my: 3 }} />
              
              <Typography variant="subtitle1" gutterBottom>
                Distribution Comparison
              </Typography>
              
              <Grid container spacing={4}>
                {/* Previous Distribution */}
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" align="center" gutterBottom>
                    Previous Distribution
                  </Typography>
                  <Box sx={{ height: 300 }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <PieChart>
                        <Pie
                          data={[
                            { name: 'Class A', value: previous.classATotal },
                            { name: 'Class B', value: previous.classBTotal }
                          ]}
                          cx="50%"
                          cy="50%"
                          outerRadius={100}
                          fill={previousColor}
                          dataKey="value"
                          label={({ name, percent }) => `${name} (${(percent * 100).toFixed(1)}%)`}
                        >
                          <Cell fill={alpha(previousColor, 0.8)} />
                          <Cell fill={alpha(previousColor, 0.5)} />
                        </Pie>
                        <Tooltip formatter={(value) => formatCurrency(value)} />
                      </PieChart>
                    </ResponsiveContainer>
                  </Box>
                </Grid>
                
                {/* Current Distribution */}
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle2" align="center" gutterBottom>
                    Current Distribution
                  </Typography>
                  <Box sx={{ height: 300 }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <PieChart>
                        <Pie
                          data={[
                            { name: 'Class A', value: current.classATotal },
                            { name: 'Class B', value: current.classBTotal }
                          ]}
                          cx="50%"
                          cy="50%"
                          outerRadius={100}
                          fill={currentColor}
                          dataKey="value"
                          label={({ name, percent }) => `${name} (${(percent * 100).toFixed(1)}%)`}
                        >
                          <Cell fill={theme.palette.primary.main} />
                          <Cell fill={theme.palette.secondary.main} />
                        </Pie>
                        <Tooltip formatter={(value) => formatCurrency(value)} />
                      </PieChart>
                    </ResponsiveContainer>
                  </Box>
                </Grid>
              </Grid>
            </Paper>
          </Grid>
        </Grid>
      )}
      
      {/* Tab 2: Tranches Breakdown */}
      {tabValue === 1 && (
        <Grid container spacing={4}>
          <Grid item xs={12}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`
              }}
            >
              <Typography variant="h6" gutterBottom fontWeight="medium">
                Principal & Interest Breakdown
              </Typography>
              
              <Box sx={{ height: 400, mt: 2 }}>
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart
                    data={breakdownData}
                    margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                    <XAxis dataKey="name" />
                    <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                    <Tooltip content={<CustomTooltip />} />
                    <Legend />
                    <Bar dataKey="previous" name="Previous" fill={previousColor} />
                    <Bar dataKey="current" name="Current" fill={currentColor} />
                  </BarChart>
                </ResponsiveContainer>
              </Box>
              
              <Divider sx={{ my: 3 }} />
              
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Metric</TableCell>
                      <TableCell align="right">Previous</TableCell>
                      <TableCell align="right">Current</TableCell>
                      <TableCell align="right">Difference</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {breakdownData.map((item, index) => (
                      <TableRow key={index}>
                        <TableCell>{item.name}</TableCell>
                        <TableCell align="right">{formatCurrency(item.previous)}</TableCell>
                        <TableCell align="right">{formatCurrency(item.current)}</TableCell>
                        <TableCell align="right">{formatDifference(item.diff)}</TableCell>
                      </TableRow>
                    ))}
                    <TableRow sx={{ "& td": { fontWeight: 'medium', backgroundColor: alpha(theme.palette.primary.main, 0.05) } }}>
                      <TableCell>Total</TableCell>
                      <TableCell align="right">
                        {formatCurrency(previous.classATotal + previous.classBTotal)}
                      </TableCell>
                      <TableCell align="right">
                        {formatCurrency(current.classATotal + current.classBTotal)}
                      </TableCell>
                      <TableCell align="right">
                        {formatDifference(calculateDifference(
                          current.classATotal + current.classBTotal,
                          previous.classATotal + previous.classBTotal
                        ))}
                      </TableCell>
                    </TableRow>
                  </TableBody>
                </Table>
              </TableContainer>
            </Paper>
          </Grid>
        </Grid>
      )}
      
      {/* Tab 3: Financing Comparison */}
      {tabValue === 2 && (
        <Grid container spacing={4}>
          <Grid item xs={12}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`,
                backgroundColor: alpha(theme.palette.info.main, 0.03)
              }}
            >
              <Typography variant="h6" color="info.main" gutterBottom fontWeight="medium">
                Financing Comparison
              </Typography>
              
              <Grid container spacing={4}>
                <Grid item xs={12} md={6}>
                  <Box sx={{ height: 350 }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart
                        data={financingData}
                        margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                        layout="vertical"
                      >
                        <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                        <XAxis type="number" tickFormatter={(value) => `â‚º${value/1000000}M`} />
                        <YAxis type="category" dataKey="name" />
                        <Tooltip content={<CustomTooltip />} />
                        <Legend />
                        <Bar dataKey="previous" name="Previous" fill={previousColor} />
                        <Bar dataKey="current" name="Current" fill={currentColor} />
                      </BarChart>
                    </ResponsiveContainer>
                  </Box>
                </Grid>
                
                <Grid item xs={12} md={6}>
                  <Box sx={{ p: 3, backgroundColor: 'background.paper', borderRadius: 2, height: '100%' }}>
                    <Typography variant="subtitle1" gutterBottom>
                      Financing Result Summary
                    </Typography>
                    
                    <Typography variant="body1" paragraph>
                      The financing result has changed from 
                      <strong> {previous.financingCost > 0 ? "profit" : "loss"} of {formatCurrency(Math.abs(previous.financingCost))} </strong> 
                      to 
                      <strong> {current.financingCost > 0 ? "profit" : "loss"} of {formatCurrency(Math.abs(current.financingCost))}</strong>.
                    </Typography>
                    
                    <Typography variant="body1">
                      This represents a <strong>{formatDifference(diff.financingCost)}</strong> change in the financing result.
                    </Typography>
                    
                    <Divider sx={{ my: 2 }} />
                    
                    <TableContainer>
                      <Table size="small">
                        <TableHead>
                          <TableRow>
                            <TableCell>Metric</TableCell>
                            <TableCell align="right">Previous</TableCell>
                            <TableCell align="right">Current</TableCell>
                            <TableCell align="right">Difference</TableCell>
                          </TableRow>
                        </TableHead>
                        <TableBody>
                          {financingData.map((item, index) => (
                            <TableRow key={index}>
                              <TableCell>{item.name}</TableCell>
                              <TableCell align="right">{formatCurrency(item.previous)}</TableCell>
                              <TableCell align="right">{formatCurrency(item.current)}</TableCell>
                              <TableCell align="right">{formatDifference(item.diff)}</TableCell>
                            </TableRow>
                          ))}
                        </TableBody>
                      </Table>
                    </TableContainer>
                  </Box>
                </Grid>
              </Grid>
            </Paper>
          </Grid>
        </Grid>
      )}
      
      {/* Tab 4: Tranche Details */}
      {tabValue === 3 && (
        <Box>
          <Paper 
            elevation={0}
            sx={{ 
              p: 3, 
              mb: 3, 
              borderRadius: 2,
              border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`
            }}
          >
            <Typography variant="h6" gutterBottom fontWeight="medium">
              Tranche Details Comparison
            </Typography>
            
            <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>
              Previous Structure
            </Typography>
            
            <TableContainer sx={{ mb: 4 }}>
              <Table size="small">
                <TableHead>
                  <TableRow>
                    <TableCell>Tranche</TableCell>
                    <TableCell align="right">Maturity Days</TableCell>
                    <TableCell align="right">Principal</TableCell>
                    <TableCell align="right">Interest/Coupon</TableCell>
                    <TableCell align="right">Total Payment</TableCell>
                    <TableCell align="right">Buffer Ratio (%)</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {previous.trancheResults.map((tranche, index) => (
                    <TableRow key={index}>
                      <TableCell>{tranche["Tranche"]}</TableCell>
                      <TableCell align="right">{tranche["Maturity Days"]}</TableCell>
                      <TableCell align="right">{formatCurrency(tranche["Principal"])}</TableCell>
                      <TableCell align="right">
                        {formatCurrency(tranche["Is Class A"] ? tranche["Interest"] : tranche["Coupon Payment"])}
                      </TableCell>
                      <TableCell align="right">{formatCurrency(tranche["Total Payment"])}</TableCell>
                      <TableCell align="right">{formatPercent(tranche["Buffer Cash Flow Ratio (%)"])}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
            
            <Typography variant="subtitle2" gutterBottom sx={{ mt: 3 }}>
              Current Structure
            </Typography>
            
            <TableContainer>
              <Table size="small">
                <TableHead>
                  <TableRow>
                    <TableCell>Tranche</TableCell>
                    <TableCell align="right">Maturity Days</TableCell>
                    <TableCell align="right">Principal</TableCell>
                    <TableCell align="right">Interest/Coupon</TableCell>
                    <TableCell align="right">Total Payment</TableCell>
                    <TableCell align="right">Buffer Ratio (%)</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {current.trancheResults.map((tranche, index) => (
                    <TableRow key={index}>
                      <TableCell>{tranche["Tranche"]}</TableCell>
                      <TableCell align="right">{tranche["Maturity Days"]}</TableCell>
                      <TableCell align="right">{formatCurrency(tranche["Principal"])}</TableCell>
                      <TableCell align="right">
                        {formatCurrency(tranche["Is Class A"] ? tranche["Interest"] : tranche["Coupon Payment"])}
                      </TableCell>
                      <TableCell align="right">{formatCurrency(tranche["Total Payment"])}</TableCell>
                      <TableCell align="right">{formatPercent(tranche["Buffer Cash Flow Ratio (%)"])}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </Paper>
        </Box>
      )}
    </Container>
  );
};

export default ComparisonPage;

======================================================================

DOSYA: src\pages\HomePage.js
==================================================
// frontend/src/pages/HomePage.js
import React from 'react';
import { Link } from 'react-router-dom';
import { 
  Container, 
  Typography, 
  Box, 
  Button, 
  Grid, 
  Paper, 
  alpha,
  Divider 
} from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import OptimizeIcon from '@mui/icons-material/Speed';
import UploadFileIcon from '@mui/icons-material/UploadFile';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import { useTheme } from '@mui/material/styles';
import { useData } from '../contexts/DataContext';
import FileUploader from '../components/FileUploader';

const HomePage = () => {
  const { cashFlowData } = useData();
  const theme = useTheme();

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Box
        sx={{
          py: 6,
          px: { xs: 3, md: 6 },
          mb: 5,
          textAlign: 'center',
          background: `linear-gradient(135deg, ${theme.palette.primary.main}, ${theme.palette.primary.dark})`,
          borderRadius: 3,
          color: 'white',
          boxShadow: `0 4px 20px ${alpha(theme.palette.primary.main, 0.3)}`,
        }}
      >
        <Typography variant="h3" component="h1" gutterBottom fontWeight="500">
          ABS Analysis Tool
        </Typography>
        <Typography variant="h6" sx={{ mb: 3, fontWeight: 400, opacity: 0.9 }}>
          Comprehensive cash flow analysis and optimization for asset-backed securities
        </Typography>
        <Divider sx={{ 
          width: '80px', 
          mx: 'auto', 
          mb: 3, 
          borderColor: 'rgba(255,255,255,0.3)' 
        }} />
        <Typography variant="body1" sx={{ maxWidth: '800px', mx: 'auto', opacity: 0.8 }}>
          Upload your Excel data file to begin analyzing your cash flows, 
          calculate securitization structures, and optimize your tranches for maximum returns.
        </Typography>
      </Box>

      <Grid container spacing={4}>
        <Grid item xs={12}>
          <Paper
            elevation={0}
            sx={{
              p: 4,
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              borderRadius: 2,
              border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
              backgroundColor: alpha(theme.palette.primary.main, 0.02),
            }}
          >
            <Typography variant="h5" gutterBottom fontWeight="medium" sx={{ mb: 3 }}>
              Upload Your Cash Flow Data
            </Typography>
            <FileUploader />
          </Paper>
        </Grid>

        {cashFlowData && (
          <>
            <Grid item xs={12} md={6}>
              <Paper
                elevation={0}
                sx={{
                  p: 4,
                  display: 'flex',
                  flexDirection: 'column',
                  height: '100%',
                  borderRadius: 2,
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  transition: 'all 0.3s',
                  '&:hover': {
                    transform: 'translateY(-4px)',
                    boxShadow: `0 6px 20px ${alpha(theme.palette.primary.main, 0.15)}`,
                    borderColor: alpha(theme.palette.primary.main, 0.3),
                  },
                }}
              >
                <Box sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2.5
                }}>
                  <Box sx={{ 
                    backgroundColor: alpha(theme.palette.primary.main, 0.1), 
                    borderRadius: '50%', 
                    p: 1.5, 
                    mr: 2 
                  }}>
                    <CalculateIcon sx={{ fontSize: 30, color: theme.palette.primary.main }} />
                  </Box>
                  <Typography variant="h5" fontWeight="medium" color="primary.main">
                    Calculate Results
                  </Typography>
                </Box>
                
                <Typography paragraph sx={{ color: 'text.secondary', mb: 3 }}>
                  Configure tranche parameters and calculate detailed results for your
                  ABS structure. Analyze cash flows, interest rates, and buffer ratios to
                  ensure your securitization meets all requirements.
                </Typography>
                
                <Box sx={{ mt: 'auto', textAlign: 'center' }}>
                  <Button
                    variant="contained"
                    color="primary"
                    component={Link}
                    to="/calculation"
                    size="large"
                    endIcon={<ArrowForwardIcon />}
                    sx={{ 
                      mt: 2, 
                      py: 1, 
                      px: 3,
                      fontWeight: 500,
                      borderRadius: 2,
                    }}
                  >
                    Start Calculation
                  </Button>
                </Box>
              </Paper>
            </Grid>

            <Grid item xs={12} md={6}>
              <Paper
                elevation={0}
                sx={{
                  p: 4,
                  display: 'flex',
                  flexDirection: 'column',
                  height: '100%',
                  borderRadius: 2,
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  transition: 'all 0.3s',
                  '&:hover': {
                    transform: 'translateY(-4px)',
                    boxShadow: `0 6px 20px ${alpha(theme.palette.secondary.main, 0.15)}`,
                    borderColor: alpha(theme.palette.secondary.main, 0.3),
                  },
                }}
              >
                <Box sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2.5
                }}>
                  <Box sx={{ 
                    backgroundColor: alpha(theme.palette.secondary.main, 0.1), 
                    borderRadius: '50%', 
                    p: 1.5, 
                    mr: 2 
                  }}>
                    <OptimizeIcon sx={{ fontSize: 30, color: theme.palette.secondary.main }} />
                  </Box>
                  <Typography variant="h5" fontWeight="medium" color="secondary.main">
                    Optimize Structure
                  </Typography>
                </Box>
                
                <Typography paragraph sx={{ color: 'text.secondary', mb: 3 }}>
                  Find the optimal ABS structure to maximize total principal
                  while maintaining minimum buffer requirements. Our advanced optimization
                  algorithms explore multiple strategies to find the best tranche configuration.
                </Typography>
                
                <Box sx={{ mt: 'auto', textAlign: 'center' }}>
                  <Button
                    variant="contained"
                    color="secondary"
                    component={Link}
                    to="/optimization"
                    size="large"
                    endIcon={<ArrowForwardIcon />}
                    sx={{ 
                      mt: 2, 
                      py: 1, 
                      px: 3,
                      fontWeight: 500,
                      borderRadius: 2
                    }}
                  >
                    Run Optimization
                  </Button>
                </Box>
              </Paper>
            </Grid>
          </>
        )}
      </Grid>
    </Container>
  );
};

export default HomePage;

======================================================================

DOSYA: src\pages\OptimizationPage.js
==================================================
// frontend/src/pages/OptimizationPage.js
import React, { useState, useEffect } from 'react';
import { 
  Container, Typography, Box, Paper, Button, Alert, CircularProgress,
  Grid, Divider, alpha, Chip, Stepper, Step, StepLabel, useTheme
} from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import SettingsIcon from '@mui/icons-material/Settings';
import SpeedIcon from '@mui/icons-material/Speed';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import TrendingUpIcon from '@mui/icons-material/TrendingUp';
import RestartAltIcon from '@mui/icons-material/RestartAlt';
import OptimizationSettingsForm from '../components/optimization/OptimizationSettingsForm';
import OptimizationResults from '../components/optimization/OptimizationResults';
import OptimizationProgress from '../components/optimization/OptimizationProgress';
import { useData } from '../contexts/DataContext';
import { optimizeStructure } from '../services/apiService';

const OptimizationPage = () => {
  const theme = useTheme();
  const { 
    cashFlowData, 
    optimizationResults, 
    setOptimizationResults, 
    isLoading, 
    setIsLoading, 
    error, 
    setError,
    optimizationSettings,
    setOptimizationSettings,
    generalSettings
  } = useData();
  
  // Additional state to control progress component
  const [isOptimizing, setIsOptimizing] = useState(false);
  const [activeStep, setActiveStep] = useState(0);

  // Method translation mapping
  const getOptimizationMethodName = (method) => {
    const methods = {
      'classic': 'Classic Strategies',
      'gradient': 'Gradient Descent',
      'bayesian': 'Bayesian Optimization',
      'genetic': 'Genetic Algorithm'
    };
    return methods[method] || method;
  };
  
  const handleFormChange = (values) => {
    setOptimizationSettings(values);
  };

  const handleOptimize = async () => {
    if (!cashFlowData) return;
    
    try {
      setIsLoading(true);
      setError(null);
      setIsOptimizing(true); // Start progress tracking
      setOptimizationResults(null); // Clear previous results
      setActiveStep(1); // Move to progress step
      
      // Selected optimization method
      const method = optimizationSettings.optimization_method;
      console.log(`Starting ${method} optimization...`);
      
      // Prepare request parameters
      const params = {
        optimization_settings: optimizationSettings,
        general_settings: {
          start_date: generalSettings.start_date.toISOString().split('T')[0],
          operational_expenses: generalSettings.operational_expenses,
          min_buffer: generalSettings.min_buffer
        }
      };
      
      // API call based on method
      try {
        const results = await optimizeStructure(params, method);
        console.log("Optimization successful:", results);
        setOptimizationResults(results);
        setActiveStep(2); // Move to results step
      } catch (optimizeError) {
        console.error("Optimization error details:", optimizeError);
        throw new Error(`Optimization failed: ${optimizeError.message}`);
      }
    } catch (error) {
      setError('Optimization failed. Please check your parameters and try again. Error: ' + error.message);
      console.error('Optimization error:', error);
      setIsOptimizing(false); // Make sure to stop progress tracking on error
      setActiveStep(0); // Return to settings step
    } finally {
      setIsLoading(false);
      // Keep isOptimizing true until the progress component handles the completion
    }
  };
  
  // Handle optimization completion
  const handleOptimizationComplete = () => {
    setIsOptimizing(false);
  };

  // New function to handle reset
  const handleReset = () => {
    setOptimizationResults(null);
    setIsOptimizing(false);
    setActiveStep(0);
    setError(null);
    
    // Optional: Reset to default settings
    // setOptimizationSettings({...default settings});
    
    window.scrollTo(0, 0); // Scroll to top for better UX
  };

  // Effect to update active step based on results
  useEffect(() => {
    if (optimizationResults && !isOptimizing) {
      setActiveStep(2);
    }
  }, [optimizationResults, isOptimizing]);

  if (!cashFlowData) {
    return (
      <Container maxWidth="lg" sx={{ mt: 6, mb: 8 }}>
        <Paper
          elevation={0}
          sx={{
            p: 4,
            textAlign: 'center',
            borderRadius: 2,
            border: `1px solid ${alpha(theme.palette.warning.main, 0.3)}`,
            backgroundColor: alpha(theme.palette.warning.main, 0.05),
          }}
        >
          <Box sx={{ 
            width: '70px',
            height: '70px',
            borderRadius: '50%',
            backgroundColor: alpha(theme.palette.warning.main, 0.1),
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            margin: '0 auto 16px'
          }}>
            <SpeedIcon sx={{ fontSize: 32, color: theme.palette.warning.main }} />
          </Box>
          <Typography variant="h5" color="warning.main" gutterBottom>
            Cash Flow Data Required
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Please upload your cash flow data on the Home page before starting the optimization process.
          </Typography>
          <Button 
            variant="outlined" 
            color="warning" 
            href="/"
            sx={{ mt: 3 }}
          >
            Go to Home Page
          </Button>
        </Paper>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ my: 4 }}>
      <Paper
        elevation={0}
        sx={{
          p: 4,
          mb: 4,
          borderRadius: 2,
          background: `linear-gradient(135deg, ${alpha(theme.palette.secondary.main, 0.05)} 0%, ${alpha(theme.palette.primary.main, 0.07)} 100%)`,
          border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <TrendingUpIcon sx={{ fontSize: 28, color: theme.palette.secondary.main, mr: 1.5 }} />
            <Typography variant="h4" component="h1" fontWeight="500">
              ABS Structure Optimization
            </Typography>
          </Box>
          
          {/* "Start Over" button */}
          {(activeStep > 0 || optimizationResults) && (
            <Button 
              variant="outlined" 
              color="primary" 
              startIcon={<RestartAltIcon />}
              onClick={handleReset}
              disabled={isLoading || isOptimizing}
            >
              Start Over
            </Button>
          )}
        </Box>
        <Typography variant="body1" color="text.secondary">
          Optimize your asset-backed securities structure to maximize principal while maintaining buffer requirements.
          Choose an optimization method and parameters to find the optimal configuration for your tranches.
        </Typography>
      </Paper>

      {error && (
        <Alert 
          severity="error" 
          sx={{ 
            mb: 3, 
            borderRadius: 2,
            '& .MuiAlert-icon': {
              alignItems: 'center'
            }
          }}
        >
          {error}
        </Alert>
      )}
      
      <Box sx={{ mb: 4 }}>
        <Stepper activeStep={activeStep} alternativeLabel>
          <Step>
            <StepLabel StepIconProps={{
              sx: { '& .MuiStepIcon-text': { fontWeight: 'bold' } }
            }}>
              Configure Settings
            </StepLabel>
          </Step>
          <Step>
            <StepLabel StepIconProps={{
              sx: { '& .MuiStepIcon-text': { fontWeight: 'bold' } }
            }}>
              Run Optimization
            </StepLabel>
          </Step>
          <Step>
            <StepLabel StepIconProps={{
              sx: { '& .MuiStepIcon-text': { fontWeight: 'bold' } }
            }}>
              Review Results
            </StepLabel>
          </Step>
        </Stepper>
      </Box>
      
      {/* Progress Component - will only show when optimization is running */}
      {isOptimizing && (
        <OptimizationProgress 
          isOptimizing={isOptimizing} 
          onComplete={handleOptimizationComplete} 
        />
      )}
      
      {(activeStep === 0 || (!isOptimizing && !optimizationResults)) && (
        <Paper 
          elevation={0}
          sx={{ 
            p: 0, 
            mb: 4, 
            overflow: 'hidden',
            borderRadius: 2,
            border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
            backgroundColor: 'background.paper'
          }}
        >
          <Box sx={{ 
            px: 3, 
            py: 2, 
            display: 'flex', 
            alignItems: 'center',
            borderBottom: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
            backgroundColor: alpha(theme.palette.primary.main, 0.02)
          }}>
            <SettingsIcon sx={{ color: theme.palette.text.secondary, mr: 1.5 }} />
            <Typography variant="h6" fontWeight="medium">
              Optimization Settings
            </Typography>
            
            <Chip 
              label={getOptimizationMethodName(optimizationSettings.optimization_method)} 
              color="primary"
              variant="outlined"
              size="small"
              sx={{ ml: 'auto' }}
            />
          </Box>
          
          <Box sx={{ p: 3 }}>
            <OptimizationSettingsForm 
              values={optimizationSettings} 
              onChange={handleFormChange} 
            />
          </Box>
          
          <Divider />
          
          <Box sx={{ p: 3, textAlign: 'center' }}>
            <Button
              variant="contained"
              color="primary"
              size="large"
              onClick={handleOptimize}
              disabled={isLoading || isOptimizing}
              startIcon={isLoading || isOptimizing ? <CircularProgress size={20} /> : <PlayArrowIcon />}
              sx={{
                py: 1.2,
                px: 4,
                borderRadius: 2,
                fontWeight: 500
              }}
            >
              {isLoading || isOptimizing ? 'Optimizing...' : 'Run Optimization'}
            </Button>
            
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              This process may take several minutes depending on the complexity of your data and optimization settings.
            </Typography>
          </Box>
        </Paper>
      )}
      
      {optimizationResults && !isOptimizing && (
        <OptimizationResults results={optimizationResults} />
      )}
    </Container>
  );
};

export default OptimizationPage;

======================================================================

DOSYA: src\services\apiService.js
==================================================
// frontend/src/services/apiService.js
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 60000, // 60 second timeout for optimization requests
});

// File upload needs different content type
const uploadFile = async (file) => {
  const formData = new FormData();
  formData.append('file', file);
  
  try {
    console.log('Uploading file:', file.name);
    const response = await axios.post(`${API_URL}/upload-excel/`, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    console.log('File upload successful');
    return response.data;
  } catch (error) {
    console.error('Error uploading file:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

const calculateResults = async (params) => {
  try {
    console.log('Calculating results with params:', params);
    const response = await apiClient.post('/calculate/', params);
    console.log('Calculation successful');
    return response.data;
  } catch (error) {
    console.error('Error calculating results:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

const optimizeStructure = async (params, method = 'classic') => {
  try {
    console.log(`Starting optimization with method: ${method}`);
    console.log('Optimization params:', JSON.stringify(params, null, 2));
    
    // Create a cancelable request for optimization
    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();
    
    // Set up timeout to cancel if it takes too long
    const timeout = setTimeout(() => {
      source.cancel('Operation timeout: The optimization process took too long');
    }, 300000); // 5 minute timeout
    
    const response = await apiClient.post(`/optimize/${method}/`, params, {
      cancelToken: source.token
    });
    
    // Clear timeout
    clearTimeout(timeout);
    
    console.log(`${method} optimization completed successfully`);
    return response.data;
  } catch (error) {
    console.error(`Error in ${method} optimization:`, error);
    
    // Check if error was caused by cancellation
    if (axios.isCancel(error)) {
      console.log('Request canceled:', error.message);
      throw new Error('Optimization process was canceled: ' + error.message);
    }
    
    // Log detailed response info if available
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
      
      const status = error.response.status;
      let message = 'Optimization failed';
      
      switch (status) {
        case 400:
          message = 'Invalid optimization parameters: ' + (error.response.data.detail || 'Please check your parameters');
          break;
        case 500:
          message = 'Server error during optimization. The calculation may be too complex.';
          break;
        case 504:
          message = 'Optimization timed out. Try again with simpler parameters.';
          break;
        default:
          message = `Optimization error (${status}): ` + (error.response.data.detail || error.message);
      }
      
      throw new Error(message);
    }
    
    throw error;
  }
};

// Add a progress polling function
const pollOptimizationProgress = async () => {
  try {
    const response = await apiClient.get('/optimize/progress/');
    return response.data;
  } catch (error) {
    console.error('Error polling optimization progress:', error);
    return {
      progress: 0,
      phase: 'Error',
      message: 'Failed to get progress information',
      error: true
    };
  }
};

export { uploadFile, calculateResults, optimizeStructure, pollOptimizationProgress };

======================================================================



BACKEND DOSYALARI VE Ä°Ã‡ERÄ°KLERÄ°:
==============================

DOSYA: backend\Dockerfile
==================================================
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

======================================================================

DOSYA: backend\requirements.txt
==================================================
# backend/requirements.txt
fastapi==0.104.1
uvicorn==0.23.2
pydantic==2.4.2
pandas==2.1.1
numpy==1.26.0
python-multipart==0.0.6
openpyxl==3.1.2
python-dateutil==2.8.2
scikit-optimize==0.9.0

======================================================================

DOSYA: backend\app\main.py
==================================================
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.routers import calculation, optimization

app = FastAPI(
    title="ABS Analysis Tool",
    description="Cash flow analysis for securitization",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify the actual frontend domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(calculation.router, prefix="/api", tags=["Calculation"])
app.include_router(optimization.router, prefix="/api", tags=["Optimization"])

@app.get("/")
async def root():
    return {"message": "ABS Analysis Tool API is running"}

======================================================================

DOSYA: backend\app\__init__.py
==================================================


======================================================================

DOSYA: backend\app\models\input_models.py
==================================================
# backend/app/models/input_models.py
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import date

class GeneralSettings(BaseModel):
    start_date: date
    operational_expenses: float
    min_buffer: float

class TrancheA(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: float

class TrancheB(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float

class NPVSettings(BaseModel):
    method: str  # "weighted_avg_rate" or "custom_rate"
    custom_rate: Optional[float] = None

class OptimizationSettings(BaseModel):
    optimization_method: str = Field(default="classic")
    a_tranches_range: List[int] = Field(default=[2, 6])
    maturity_range: List[int] = Field(default=[32, 365])
    maturity_step: int = Field(default=10)
    min_class_b_percent: float = Field(default=10.0)
    target_class_b_coupon_rate: float = Field(default=30.0)
    additional_days_for_class_b: int = Field(default=10)
    
    # Gradient descent iÃ§in
    learning_rate: Optional[float] = Field(default=0.01)
    max_iterations: Optional[int] = Field(default=100)
    
    # Genetik algoritma iÃ§in
    population_size: Optional[int] = Field(default=50)
    num_generations: Optional[int] = Field(default=40)
    
    # Bayesian iÃ§in
    n_calls: Optional[int] = Field(default=50)
    n_initial_points: Optional[int] = Field(default=10)

class CalculationRequest(BaseModel):
    general_settings: GeneralSettings
    tranches_a: List[TrancheA]
    tranche_b: TrancheB
    npv_settings: NPVSettings

======================================================================

DOSYA: backend\app\models\output_models.py
==================================================
# backend/app/models/output_models.py
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

class CashFlowSummary(BaseModel):
    total_records: int
    total_principal: float
    total_interest: float
    total_cash_flow: float
    date_range: List[str]
    
class CalculationResult(BaseModel):
    class_a_total: float
    class_b_total: float
    class_a_principal: float
    class_b_principal: float
    class_a_interest: float
    class_b_coupon: float
    min_buffer_actual: float
    total_principal_paid: float
    total_loan_principal: float
    financing_cost: float
    tranche_results: List[Dict[str, Any]]
    interest_rate_conversions: List[Dict[str, Any]]
    
class OptimizationResult(BaseModel):
    best_strategy: str
    class_a_maturities: List[int]
    class_a_nominals: List[float]
    class_a_rates: List[float]
    class_a_reinvest: List[float]
    class_b_maturity: int
    class_b_rate: float
    class_b_reinvest: float
    class_b_nominal: float
    class_b_coupon_rate: float
    min_buffer_actual: float
    last_cash_flow_day: int
    additional_days: int
    results_by_strategy: Dict[str, Dict[str, Any]]

======================================================================

DOSYA: backend\app\routers\calculation.py
==================================================
# backend/app/routers/calculation.py
from fastapi import APIRouter, UploadFile, File, HTTPException
from app.models.input_models import CalculationRequest
from app.models.output_models import CalculationResult, CashFlowSummary
from app.services.calculation_service import perform_calculation, load_excel_data
import pandas as pd
from typing import Dict, Any
import io

router = APIRouter()

# Global variable to store the dataframe after upload
# In a production app, you would use a database or Redis cache instead
df_store = {"df": None}

@router.post("/upload-excel/", response_model=CashFlowSummary)
async def upload_excel(file: UploadFile = File(...)):
    try:
        contents = await file.read()
        df = load_excel_data(contents)
        
        # Store the dataframe in memory for later use
        df_store["df"] = df
        
        # Return summary data
        return CashFlowSummary(
            total_records=len(df),
            total_principal=float(df['principal_amount'].sum()),
            total_interest=float(df['interest_amount'].sum()),
            total_cash_flow=float(df['cash_flow'].sum()),
            date_range=[df['installment_date'].min().strftime('%d/%m/%Y'), 
                      df['installment_date'].max().strftime('%d/%m/%Y')]
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Could not process file: {str(e)}")

@router.post("/calculate/", response_model=CalculationResult)
async def calculate(request: CalculationRequest):
    try:
        # Get the stored dataframe
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Perform the calculation
        result = perform_calculation(df, request)
        return result
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Calculation error: {str(e)}")

======================================================================

DOSYA: backend\app\routers\optimization.py
==================================================
# backend/app/routers/optimization.py
import time
import traceback
import logging
from fastapi.responses import JSONResponse
from fastapi import APIRouter, HTTPException, Path
from app.models.input_models import OptimizationSettings, GeneralSettings
from app.models.output_models import OptimizationResult

# Import the optimization_progress object and all optimization functions
from app.services.optimization_service import (
    optimization_progress,  # Import the progress tracker
    perform_optimization, 
    perform_gradient_optimization,
    perform_bayesian_optimization,
    perform_genetic_optimization
)
from app.routers.calculation import df_store  # Import the shared dataframe store

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

@router.get("/optimize/progress/", response_model=dict)
async def get_optimization_progress():
    """Get the current progress of an ongoing optimization process"""
    try:
        # Add a small delay to reduce server load (10ms)
        time.sleep(0.01)
        
        # Get the current progress information
        progress_info = optimization_progress.get_info()
        
        # Force the progress to be a valid number between 0-100
        progress_info['progress'] = max(0, min(100, progress_info['progress']))
        
        # Ensure the message is not None
        if progress_info['message'] is None:
            progress_info['message'] = "Processing..."
            
        # Ensure the phase is not None
        if progress_info['phase'] is None:
            progress_info['phase'] = "Processing"
        
        # Add a timestamp for debugging
        progress_info['timestamp'] = time.time()
        
        return JSONResponse(content=progress_info)
    except Exception as e:
        # Log the error
        logger.error(f"Error retrieving optimization progress: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Return an error status that the frontend can handle
        error_response = {
            "error": True,
            "message": f"Error retrieving optimization progress: {str(e)}",
            "progress": 0,
            "phase": "Error",
            "timestamp": time.time()
        }
        return JSONResponse(content=error_response, status_code=200) # Still return 200 for easier frontend handling
    
@router.post("/optimize/classic/", response_model=OptimizationResult)
async def optimize_classic(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    try:
        # Reset progress tracker
        optimization_progress.reset()
        
        # Get the stored dataframe
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Log the request
        logger.info(f"Starting classic optimization with parameters: {optimization_settings}")
        
        # Perform the optimization with classic method
        result = perform_optimization(df, general_settings, optimization_settings)
        
        # Log success
        logger.info("Classic optimization completed successfully")
        return result
    except Exception as e:
        # Log the error
        logger.error(f"Classic optimization error: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Reset progress tracker in case of error
        optimization_progress.reset()
        optimization_progress.update(
            phase="Error",
            message=f"Classic optimization error: {str(e)}"
        )
        
        raise HTTPException(status_code=500, detail=f"Classic optimization error: {str(e)}")

@router.post("/optimize/gradient/", response_model=OptimizationResult)
async def optimize_gradient(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    try:
        # Reset progress tracker
        optimization_progress.reset()
        
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Log the request
        logger.info(f"Starting gradient optimization with parameters: {optimization_settings}")
        
        result = perform_gradient_optimization(df, general_settings, optimization_settings)
        
        # Log success
        logger.info("Gradient optimization completed successfully")
        return result
    except Exception as e:
        # Log the error
        logger.error(f"Gradient optimization error: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Reset progress tracker in case of error
        optimization_progress.reset()
        optimization_progress.update(
            phase="Error",
            message=f"Gradient optimization error: {str(e)}"
        )
        
        raise HTTPException(status_code=500, detail=f"Gradient optimization error: {str(e)}")

@router.post("/optimize/bayesian/", response_model=OptimizationResult)
async def optimize_bayesian(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    try:
        # Reset progress tracker
        optimization_progress.reset()
        
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Log the request
        logger.info(f"Starting bayesian optimization with parameters: {optimization_settings}")
        
        result = perform_bayesian_optimization(df, general_settings, optimization_settings)
        
        # Log success
        logger.info("Bayesian optimization completed successfully")
        return result
    except Exception as e:
        # Log the error
        logger.error(f"Bayesian optimization error: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Reset progress tracker in case of error
        optimization_progress.reset()
        optimization_progress.update(
            phase="Error",
            message=f"Bayesian optimization error: {str(e)}"
        )
        
        raise HTTPException(status_code=500, detail=f"Bayesian optimization error: {str(e)}")

@router.post("/optimize/genetic/", response_model=OptimizationResult)
async def optimize_genetic(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    try:
        # Reset progress tracker
        optimization_progress.reset()
        
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Log the request
        logger.info(f"Starting genetic optimization with parameters: {optimization_settings}")
        
        result = perform_genetic_optimization(df, general_settings, optimization_settings)
        
        # Log success
        logger.info("Genetic optimization completed successfully")
        return result
    except Exception as e:
        # Log the error
        logger.error(f"Genetic optimization error: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Reset progress tracker in case of error
        optimization_progress.reset()
        optimization_progress.update(
            phase="Error",
            message=f"Genetic optimization error: {str(e)}"
        )
        
        raise HTTPException(status_code=500, detail=f"Genetic optimization error: {str(e)}")

# Backward compatibility iÃ§in ana endpoint
@router.post("/optimize/", response_model=OptimizationResult)
async def optimize(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    method = getattr(optimization_settings, "optimization_method", "classic")
    logger.info(f"Optimizing with method: {method}")
    
    try:
        if method == "classic":
            return await optimize_classic(optimization_settings, general_settings)
        elif method == "gradient":
            return await optimize_gradient(optimization_settings, general_settings)
        elif method == "bayesian":
            return await optimize_bayesian(optimization_settings, general_settings)
        elif method == "genetic":
            return await optimize_genetic(optimization_settings, general_settings)
        else:
            raise HTTPException(status_code=400, detail=f"Unknown optimization method: {method}")
    except Exception as e:
        logger.error(f"Error in main optimize endpoint: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Optimization error: {str(e)}")

======================================================================

DOSYA: backend\app\services\calculation_service.py
==================================================
# backend/app/services/calculation_service.py
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from app.models.input_models import CalculationRequest
from app.models.output_models import CalculationResult
from app.utils.finance_utils import (
    simple_to_compound_annual, 
    simple_to_maturity_compound, 
    overnight_to_annual_compound,
    get_next_business_day,
    calculate_reinvestment_date
)
from app.utils.cash_flow_utils import (
    assign_cash_flows_to_tranches,
    calculate_totals
)
from typing import Dict, List, Any, Tuple
import io

def load_excel_data(contents: bytes) -> pd.DataFrame:
    """Load and preprocess Excel data"""
    try:
        df = pd.read_excel(io.BytesIO(contents))
        df.rename(columns={'Copyinstallment_date': 'installment_date'}, inplace=True, errors='ignore')
        df['installment_date'] = pd.to_datetime(df['installment_date'], dayfirst=True, errors='coerce')
        
        if 'principal_amount' not in df.columns or 'interest_amount' not in df.columns:
            raise ValueError("The Excel file does not contain 'principal_amount' or 'interest_amount' columns.")
        
        df['cash_flow'] = df['principal_amount'] + df['interest_amount']
        # Save original cash flows
        df['original_cash_flow'] = df['cash_flow'].copy()
        
        return df
    except Exception as e:
        raise ValueError(f"Error processing Excel file: {str(e)}")

def perform_calculation(df: pd.DataFrame, request: CalculationRequest) -> CalculationResult:
    """Perform ABS calculation based on provided parameters"""
    # Extract request parameters
    start_date = pd.Timestamp(request.general_settings.start_date)
    ops_expenses = request.general_settings.operational_expenses
    min_buffer = request.general_settings.min_buffer
    
    # Apply operational expenses
    df_calc = df.copy()
    df_calc['cash_flow'] = df_calc['original_cash_flow'].copy()
    target_date = pd.Timestamp('2025-02-16')
    target_rows = df_calc[df_calc['installment_date'].dt.date == target_date.date()]
    
    if not target_rows.empty:
        t_idx = target_rows.index[0]
        orig_cf = df_calc.at[t_idx, 'cash_flow']
        new_cf = max(0, orig_cf - ops_expenses)
        df_calc.at[t_idx, 'cash_flow'] = new_cf
    
    # Extract tranche parameters
    a_maturity_days = [t.maturity_days for t in request.tranches_a]
    a_base_rates = [t.base_rate for t in request.tranches_a]
    a_spreads = [t.spread for t in request.tranches_a]
    a_reinvest_rates = [t.reinvest_rate for t in request.tranches_a]
    a_nominal_amounts = [t.nominal for t in request.tranches_a]
    
    b_maturity_days = [request.tranche_b.maturity_days]
    b_base_rates = [request.tranche_b.base_rate]
    b_spreads = [request.tranche_b.spread]
    b_reinvest_rates = [request.tranche_b.reinvest_rate]
    
    # Calculate B nominal amount
    total_a_nominal = sum(a_nominal_amounts)
    percent_b = 10.17811704
    b_nominal_amount = (total_a_nominal * percent_b) / (100 - percent_b)
    b_nominal_amount = round(b_nominal_amount / 1000) * 1000
    b_nominal = [b_nominal_amount]
    
    # Combine all parameters
    all_maturity_days = a_maturity_days + b_maturity_days
    all_base_rates = a_base_rates + b_base_rates
    all_spreads = a_spreads + b_spreads
    all_reinvest_rates = a_reinvest_rates + b_reinvest_rates
    all_nominal = a_nominal_amounts + b_nominal
    
    # Calculate maturity dates
    all_maturity_dates = [start_date + pd.Timedelta(days=days) for days in all_maturity_days]
    
    # Distribute cash flows into tranches
    tranch_cash_flows = assign_cash_flows_to_tranches(
        df_calc, start_date, all_maturity_dates, all_reinvest_rates
    )
    
    # Calculate results for each tranche
    results = []
    buffer = 0.0
    interest_rate_conversions = []
    
    for i in range(len(all_maturity_days)):
        is_class_a = (i < len(a_maturity_days))
        
        # Set tranche name
        if is_class_a:
            t_name = f"Class A{i+1}"
        else:
            t_name = f"Class B{i - len(a_maturity_days) + 1}"
        
        # Calculate cash flow totals
        c_flow, r_return, total_principal, total_interest = calculate_totals(
            tranch_cash_flows[i], all_maturity_dates[i], all_reinvest_rates[i]
        )
        
        # Buffer reinvestment calculation
        if i > 0 and buffer > 0:
            dd = all_maturity_days[i] - all_maturity_days[i-1]
            if dd > 0:
                factor = (1 + simple_to_compound_annual(all_reinvest_rates[i])/100)**(dd/365) - 1
                buffer_reinv = buffer * factor
            else:
                buffer_reinv = 0
        else:
            buffer_reinv = 0
        
        # Total available funds
        total_available = c_flow + r_return + buffer + buffer_reinv
        
        # Interest rate calculations
        base_rate_val = all_base_rates[i]
        spread_bps = all_spreads[i]
        total_rate = base_rate_val + (spread_bps/100.0)
        
        if is_class_a:
            # Class A payment logic
            nominal_pmt = all_nominal[i]
            
            discount_factor = 1 / (1 + (total_rate/100 * all_maturity_days[i]/365)) if all_maturity_days[i] > 0 else 1
            principal = nominal_pmt * discount_factor
            interest = nominal_pmt - principal
            coupon_payment = 0
            coupon_rate = 0.0
            
            total_payment = nominal_pmt
        else:
            # Class B payment logic
            nominal_pmt = all_nominal[i]
            principal = nominal_pmt
            coupon_payment = max(0, total_available - principal)
            interest = 0
            coupon_rate = (coupon_payment / principal * 100) if principal > 0 else 0.0
            discount_factor = 1.0
            
            total_payment = principal + coupon_payment
        
        # Calculate buffer
        new_buffer = max(0, total_available - total_payment)
        buffer_cf_ratio = (new_buffer / nominal_pmt * 100) if nominal_pmt != 0 else 0
        
        # Calculate effective interest rates
        if is_class_a:
            final_simple = total_rate
            total_interest_rate_percent = total_rate
            effective_coupon_rate = 0.0
        else:
            final_simple = coupon_rate
            total_interest_rate_percent = 0.0
            effective_coupon_rate = (coupon_payment / principal) * (365 / all_maturity_days[i]) * 100 if principal > 0 and all_maturity_days[i] > 0 else 0.0
        
        # Interest rate conversions
        if is_class_a:
            comp_period = simple_to_maturity_compound(final_simple, all_maturity_days[i])
            simple_annual_display = final_simple
            compound_period_display = comp_period
        else:
            # For Class B, use dash ("-") for these values
            simple_annual_display = "-"
            compound_period_display = "-"
        
        reinvest_on_comp = overnight_to_annual_compound(all_reinvest_rates[i])
        
        interest_rate_conversions.append({
            "Tranche": t_name,
            "Maturity Days": all_maturity_days[i],
            "Simple Annual Interest (%)": simple_annual_display,
            "Compound Interest for Period (%)": compound_period_display,
            "Reinvest Simple Annual (%)": all_reinvest_rates[i],
            "Reinvest O/N Compound (%)": reinvest_on_comp,
            "Coupon Rate (%)": coupon_rate if not is_class_a else 0.0,
            "Effective Coupon Rate (%)": effective_coupon_rate if not is_class_a else 0.0
        })
        
        # Add to results
        results.append({
            "Tranche": t_name,
            "Start Date": start_date.strftime("%d/%m/%Y"),
            "Maturity Days": all_maturity_days[i],
            "Maturity Date": all_maturity_dates[i].strftime("%d/%m/%Y"),
            "Base Rate (%)": base_rate_val,
            "Spread (bps)": spread_bps,
            "Total Interest Rate (%)": total_interest_rate_percent,
            "Coupon Rate (%)": coupon_rate,
            "Effective Coupon (%)": effective_coupon_rate,
            "Original Nominal": all_nominal[i],
            "Adjusted Nominal": nominal_pmt,
            "Buffer In": buffer,
            "Cash Flow Total": c_flow,
            "Reinvestment Return": r_return,
            "Buffer Reinvestment": buffer_reinv,
            "Total Available": total_available,
            "Principal": principal,
            "Interest": interest,
            "Coupon Payment": coupon_payment,
            "Nominal Payment": nominal_pmt,
            "Total Payment": total_payment,
            "Buffer Out": new_buffer,
            "Buffer Cash Flow Ratio (%)": buffer_cf_ratio,
            "Discount Factor": discount_factor,
            "Is Class A": is_class_a
        })
        
        # Update buffer for next tranche
        buffer = new_buffer
    
    # Filter for Class A and Class B
    class_a_results = [r for r in results if r.get("Is Class A")]
    class_b_results = [r for r in results if not r.get("Is Class A")]
    
    # Calculate totals
    class_a_total = sum(r["Total Payment"] for r in class_a_results)
    class_b_total = sum(r["Total Payment"] for r in class_b_results)
    class_a_principal = sum(r["Principal"] for r in class_a_results)
    class_b_principal = sum(r["Principal"] for r in class_b_results)
    class_a_interest = sum(r["Interest"] for r in class_a_results)
    class_b_coupon = sum(r["Coupon Payment"] for r in class_b_results)
    min_buffer_actual = min(r["Buffer Cash Flow Ratio (%)"] for r in class_a_results) if class_a_results else 0.0
    
    # Calculate total principal paid and loan principal for financing cost
    total_principal_paid = class_a_principal + class_b_principal
    total_loan_principal = df_calc['principal_amount'].sum()
    financing_cost = total_principal_paid - total_loan_principal
    
    # Create and return the calculation result
    return CalculationResult(
        class_a_total=class_a_total,
        class_b_total=class_b_total,
        class_a_principal=class_a_principal,
        class_b_principal=class_b_principal,
        class_a_interest=class_a_interest,
        class_b_coupon=class_b_coupon,
        min_buffer_actual=min_buffer_actual,
        total_principal_paid=total_principal_paid,
        total_loan_principal=total_loan_principal,
        financing_cost=financing_cost,
        tranche_results=results,
        interest_rate_conversions=interest_rate_conversions
    )

======================================================================

DOSYA: backend\app\services\optimization_service.py
==================================================
"""
Optimization service for ABS structure analysis.
This module implements multiple optimization strategies to find optimal ABS configurations.
"""
import time
import pandas as pd
import numpy as np
import itertools
from datetime import datetime, timedelta
import random
import traceback
import logging
from typing import Dict, List, Any, Tuple, Optional

from app.models.input_models import OptimizationSettings, GeneralSettings
from app.models.output_models import OptimizationResult
from app.utils.finance_utils import (
    simple_to_compound_annual,
    get_nearest_maturity,
    get_last_cash_flow_day
)
from app.utils.cash_flow_utils import (
    assign_cash_flows_to_tranches,
    calculate_totals
)

# Configure logger
logger = logging.getLogger(__name__)

class OptimizationProgress:
    """Class to track and report optimization progress"""
    def __init__(self):
        self.current_step = 0
        self.total_steps = 100
        self.current_phase = "Initializing"
        self.status_message = "Starting optimization..."
        self.progress = 0
        self.last_update_time = time.time()
        self.lock = False  # Simple lock mechanism
        
    def reset(self):
        """Reset all progress tracking variables"""
        self.current_step = 0
        self.total_steps = 100
        self.current_phase = "Initializing"
        self.status_message = "Starting optimization..."
        self.progress = 0
        self.last_update_time = time.time()
        self.lock = False  # Ensure lock is released
        logger.info("Progress tracker reset")
        
    def update(self, step=None, total=None, phase=None, message=None):
        """Update progress information with minimal state contention"""
        if self.lock:
            return  # Skip update if another update is in progress
            
        self.lock = True  # Acquire lock
        try:
            current_time = time.time()
            
            # Only update if there's been a change or more than 1 second has passed
            force_update = (current_time - self.last_update_time) > 1
            
            if step is not None:
                self.current_step = step
            if total is not None:
                self.total_steps = total
            if phase is not None:
                self.current_phase = phase
            if message is not None:
                self.status_message = message
                
            # Calculate percentage
            if self.total_steps > 0:
                new_progress = min(100, int((self.current_step / self.total_steps) * 100))
                progress_changed = new_progress != self.progress
                self.progress = new_progress
            
            # Log progress for debugging if something changed or if forced
            if message is not None or progress_changed or force_update:
                logger.info(f"Progress: {self.progress}% - {self.current_phase} - {self.status_message}")
                self.last_update_time = current_time
        finally:
            self.lock = False  # Release lock
        
    def get_info(self):
        """Get current progress information"""
        return {
            "progress": self.progress,
            "phase": self.current_phase,
            "message": self.status_message,
            "step": self.current_step,
            "total_steps": self.total_steps,
            "timestamp": time.time()
        }

# Create the global optimization_progress instance
optimization_progress = OptimizationProgress()

def adjust_class_a_nominals_for_target_coupon(
    a_nominals: List[float], 
    class_b_nominal: float, 
    target_coupon_rate: float, 
    class_b_maturity: int,
    a_maturity_days: List[int], 
    a_base_rates: List[float], 
    a_reinvest_rates: List[float], 
    b_base_rate: float, 
    b_reinvest_rate: float,
    start_date: pd.Timestamp, 
    df_temp: pd.DataFrame, 
    min_buffer: float,
    max_allowed_diff: float = 1.0
) -> Tuple[List[float], bool]:
    """
    Iteratively adjust Class A nominal amounts to achieve a target coupon rate for Class B
    using an adaptive binary search approach.
    
    Args:
        a_nominals: List of Class A nominal amounts
        class_b_nominal: Class B nominal amount
        target_coupon_rate: Target coupon rate for Class B
        class_b_maturity: Maturity days for Class B
        a_maturity_days: List of maturity days for Class A tranches
        a_base_rates: List of base rates for Class A tranches
        a_reinvest_rates: List of reinvestment rates for Class A tranches
        b_base_rate: Base rate for Class B
        b_reinvest_rate: Reinvestment rate for Class B
        start_date: Start date for calculations
        df_temp: DataFrame containing cash flow data
        min_buffer: Minimum buffer requirement
        max_allowed_diff: Maximum allowed difference between actual and target coupon rate
        
    Returns:
        Tuple of (adjusted_nominals, success_flag)
    """
    # Initial parameters
    original_a_total = sum(a_nominals)
    original_proportions = [n / original_a_total for n in a_nominals]
    max_iterations = 50
    
    # Adjustment limits 
    min_adjustment = 0.001  # Allow down to 0.1% of original
    max_adjustment = 3.0    # Allow up to 300% of original
    
    logger.info(f"Starting adjustment with target coupon rate: {target_coupon_rate:.2f}%")
    logger.info(f"Original Class A total: {original_a_total:,.2f}, Class B nominal: {class_b_nominal:,.2f}")
    
    # First, evaluate the original nominals to get a baseline
    try:
        baseline_coupon_rate, baseline_min_buffer = evaluate_coupon_rate(
            a_nominals, class_b_nominal, class_b_maturity, 
            a_maturity_days, a_base_rates, a_reinvest_rates, 
            b_base_rate, b_reinvest_rate, start_date, df_temp
        )
        
        logger.info(f"Baseline - Coupon rate: {baseline_coupon_rate:.2f}%, Buffer: {baseline_min_buffer:.2f}%")
    except Exception as e:
        logger.error(f"Error evaluating baseline: {str(e)}")
        return a_nominals, False
    
    # Determine initial direction and starting adjustment
    if baseline_coupon_rate < target_coupon_rate:
        # If baseline coupon is too low, we need to increase Class A nominals
        logger.info("Baseline coupon is lower than target - will increase Class A nominals")
        adjustment_direction = 1  # Increase
        current_adjustment = 1.2  # Start with 20% increase
    else:
        # If baseline coupon is too high, we need to decrease Class A nominals
        logger.info("Baseline coupon is higher than target - will decrease Class A nominals")
        adjustment_direction = -1  # Decrease
        
        # Set a very aggressive initial adjustment based on how far we are
        coupon_ratio = baseline_coupon_rate / target_coupon_rate
        if coupon_ratio > 10:
            # If coupon is more than 10x target, use extreme adjustment
            current_adjustment = 0.01  # 1% of original size
        elif coupon_ratio > 5:
            # If coupon is more than 5x target, use very aggressive adjustment
            current_adjustment = 0.05  # 5% of original size
        elif coupon_ratio > 2:
            # If coupon is more than 2x target, use aggressive adjustment
            current_adjustment = 0.1   # 10% of original size
        else:
            # For closer ratios, use moderate adjustment
            current_adjustment = 0.5   # 50% of original size
    
    best_diff = float('inf')
    best_nominals = a_nominals.copy()
    success = False
    
    # Adaptive binary search with safeguards
    for iteration in range(max_iterations):
        # Apply current adjustment factor to all Class A nominals
        current_nominals = [original_proportions[i] * original_a_total * current_adjustment 
                           for i in range(len(a_nominals))]
        
        # Round to nearest 1000 and ensure no zeros
        current_nominals = [max(1000, round(n / 1000) * 1000) for n in current_nominals]
        
        try:
            # Evaluate with current adjustment
            coupon_rate, min_buffer_actual = evaluate_coupon_rate(
                current_nominals, class_b_nominal, class_b_maturity, 
                a_maturity_days, a_base_rates, a_reinvest_rates,
                b_base_rate, b_reinvest_rate, start_date, df_temp
            )
            
            # Calculate difference from target
            rate_diff = abs(coupon_rate - target_coupon_rate)
            
            logger.info(f"Iteration {iteration+1}, adjustment: {current_adjustment:.4f}, "
                  f"coupon: {coupon_rate:.2f}%, target: {target_coupon_rate:.2f}%, "
                  f"diff: {rate_diff:.2f}%, min buffer: {min_buffer_actual:.2f}%")
            
            # Check if this result is better and meets buffer requirement
            if min_buffer_actual >= min_buffer and rate_diff < best_diff:
                best_diff = rate_diff
                best_nominals = current_nominals.copy()
                
                # If we're close to target, consider it a success
                if rate_diff <= max_allowed_diff:
                    success = True
                    logger.info(f"Found acceptable solution - coupon rate: {coupon_rate:.2f}%, "
                          f"diff: {rate_diff:.2f}%, min buffer: {min_buffer_actual:.2f}%")
                    
                    # If very close to target, we can exit early
                    if rate_diff < 0.2:
                        break
            
            # Adaptive adjustment based on current results
            if coupon_rate < target_coupon_rate:
                if adjustment_direction == 1:
                    # We're going in the right direction (increasing), make smaller adjustments
                    current_adjustment *= 1.1  # Increase by 10%
                else:
                    # We went too far, reverse direction and use smaller step
                    adjustment_direction = 1
                    current_adjustment = 1.0 + (1.0 - current_adjustment) * 0.5
            else:  # coupon_rate > target_coupon_rate
                if adjustment_direction == -1:
                    # We're going in the right direction (decreasing), make smaller adjustments
                    if (coupon_rate / target_coupon_rate) > 2:
                        # Still far from target, be more aggressive
                        current_adjustment *= 0.7  # Reduce by 30%
                    else:
                        # Getting closer, be more careful
                        current_adjustment *= 0.9  # Reduce by 10%
                else:
                    # We went too far, reverse direction and use smaller step
                    adjustment_direction = -1
                    current_adjustment = 1.0 - (current_adjustment - 1.0) * 0.5
            
            # Ensure adjustment is within bounds
            current_adjustment = max(min_adjustment, min(max_adjustment, current_adjustment))
            
            # Check if we're making too small changes and break if needed
            if abs(current_adjustment - 1.0) < 0.0001 and iteration > 10:
                logger.info("Adjustment factor converged, stopping iterations")
                break
                
        except Exception as e:
            logger.error(f"Error during adjustment iteration {iteration}: {str(e)}")
            # Continue to next iteration instead of terminating
            continue
    
    # If we didn't find a solution within max_allowed_diff but have a best solution, log it
    if not success and best_diff < float('inf'):
        logger.info(f"Best solution found: coupon rate diff: {best_diff:.2f}%")
    elif not success:
        logger.info(f"Failed to find valid solution. Try adjusting min buffer requirement or target coupon rate.")
    
    return best_nominals, success

def evaluate_coupon_rate(
    a_nominals: List[float], 
    class_b_nominal: float, 
    class_b_maturity: int, 
    a_maturity_days: List[int], 
    a_base_rates: List[float], 
    a_reinvest_rates: List[float],
    b_base_rate: float, 
    b_reinvest_rate: float, 
    start_date: pd.Timestamp, 
    df_temp: pd.DataFrame
) -> Tuple[float, float]:
    """
    Helper function to evaluate a specific nominal adjustment
    Returns tuple of (coupon_rate, min_buffer)
    
    Args:
        a_nominals: List of Class A nominal amounts
        class_b_nominal: Class B nominal amount
        class_b_maturity: Maturity days for Class B
        a_maturity_days: List of maturity days for Class A tranches
        a_base_rates: List of base rates for Class A tranches
        a_reinvest_rates: List of reinvestment rates for Class A tranches
        b_base_rate: Base rate for Class B
        b_reinvest_rate: Reinvestment rate for Class B
        start_date: Start date for calculations
        df_temp: DataFrame containing cash flow data
        
    Returns:
        Tuple of (coupon_rate, min_buffer)
    """
    # Set up parameters for calculation
    a_spreads = [0.0] * len(a_maturity_days)
    b_maturity_days = [class_b_maturity]
    b_nominal = [class_b_nominal]
    b_spreads = [0.0]
    
    # Combine all parameters
    all_maturity_days = a_maturity_days + b_maturity_days
    all_base_rates = a_base_rates + [b_base_rate]
    all_spreads = a_spreads + b_spreads
    all_reinvest_rates = a_reinvest_rates + [b_reinvest_rate]
    all_nominal = a_nominals + b_nominal
    
    # Calculate maturity dates
    all_maturity_dates = [start_date + pd.Timedelta(days=days) for days in all_maturity_days]
    
    # Distribute cash flows to tranches
    tranch_cash_flows = assign_cash_flows_to_tranches(
        df_temp, start_date, all_maturity_dates, all_reinvest_rates
    )
    
    # Calculate results for each tranche
    results = []
    buffer = 0.0
    
    for i in range(len(all_maturity_days)):
        is_class_a = (i < len(a_maturity_days))
        
        # Calculate cash flow totals
        c_flow, r_return, total_principal, total_interest = calculate_totals(
            tranch_cash_flows[i], all_maturity_dates[i], all_reinvest_rates[i]
        )
        
        # Buffer reinvestment calculation
        if i > 0 and buffer > 0:
            dd = all_maturity_days[i] - all_maturity_days[i-1]
            if dd > 0:
                factor = (1 + simple_to_compound_annual(all_reinvest_rates[i])/100)**(dd/365) - 1
                buffer_reinv = buffer * factor
            else:
                buffer_reinv = 0
        else:
            buffer_reinv = 0
        
        # Total available funds
        total_available = c_flow + r_return + buffer + buffer_reinv
        
        # Interest rate calculations
        base_rate_val = all_base_rates[i]
        spread_bps = all_spreads[i]
        total_rate = base_rate_val + (spread_bps/100.0)
        
        if is_class_a:
            # Class A payment logic
            nominal_pmt = all_nominal[i]
            discount_factor = 1 / (1 + (total_rate/100 * all_maturity_days[i]/365)) if all_maturity_days[i] > 0 else 1
            principal = nominal_pmt * discount_factor
            interest = nominal_pmt - principal
            coupon_payment = 0
            total_payment = nominal_pmt
        else:
            # Class B payment logic
            nominal_pmt = all_nominal[i]
            principal = nominal_pmt
            coupon_payment = max(0, total_available - principal)
            interest = 0
            total_payment = principal + coupon_payment
        
        # Calculate buffer - avoid division by zero
        new_buffer = max(0, total_available - total_payment)
        buffer_cf_ratio = (new_buffer / nominal_pmt * 100) if nominal_pmt > 0 else 0
        
        # Add to results
        results.append({
            "is_class_a": is_class_a,
            "principal": principal,
            "interest": interest,
            "coupon_payment": coupon_payment,
            "total_payment": total_payment,
            "buffer_cf_ratio": buffer_cf_ratio,
            "maturity_days": all_maturity_days[i],
            "base_rate": base_rate_val,
            "nominal": all_nominal[i]
        })
        
        # Update buffer for next tranche
        buffer = new_buffer
    
    # Split results by class
    class_a_results = [r for r in results if r['is_class_a']]
    class_b_results = [r for r in results if not r['is_class_a']]
    
    # Calculate Class B coupon rate
    class_b_principal = sum(r['principal'] for r in class_b_results)
    class_b_coupon = sum(r['coupon_payment'] for r in class_b_results)
    
    # Calculate Class B effective coupon rate (annualized)
    if class_b_results and class_b_principal > 0 and class_b_maturity > 0:
        class_b_maturity_days = class_b_results[0]['maturity_days']
        class_b_coupon_rate = (class_b_coupon / class_b_principal) * (365 / class_b_maturity_days) * 100
    else:
        class_b_coupon_rate = 0.0
    
    # Calculate minimum buffer
    min_buffer_actual = min(r['buffer_cf_ratio'] for r in class_a_results) if class_a_results else 0.0
    
    return class_b_coupon_rate, min_buffer_actual

def evaluate_params(
    maturities: List[int], 
    nominals: List[float], 
    class_b_maturity: int, 
    start_date: pd.Timestamp, 
    df_temp: pd.DataFrame,
    maturity_to_base_rate_A: Dict[int, float], 
    maturity_to_reinvest_rate_A: Dict[int, float],
    class_b_base_rate: float, 
    class_b_reinvest_rate: float,
    min_class_b_percent: float, 
    target_class_b_coupon_rate: float, 
    min_buffer: float
) -> Dict[str, Any]:
    """Helper function to evaluate a set of parameters
    
    Args:
        maturities: List of maturity days for Class A tranches
        nominals: List of nominal amounts for Class A tranches
        class_b_maturity: Maturity days for Class B
        start_date: Start date for calculations
        df_temp: DataFrame containing cash flow data
        maturity_to_base_rate_A: Dictionary mapping maturity days to base rates
        maturity_to_reinvest_rate_A: Dictionary mapping maturity days to reinvestment rates
        class_b_base_rate: Base rate for Class B
        class_b_reinvest_rate: Reinvestment rate for Class B
        min_class_b_percent: Minimum percentage of Class B tranche
        target_class_b_coupon_rate: Target coupon rate for Class B
        min_buffer: Minimum buffer requirement
        
    Returns:
        Dictionary containing evaluation results
    """
    # Convert to lists for key operations and ensure types are correct
    maturities = [int(m) for m in maturities]  # Ensure integers
    nominals = list(nominals)
    
    # Round nominals to nearest 1000 and ensure no zeros
    nominals = [max(1000, round(n / 1000) * 1000) for n in nominals]
    
    # Get rates from lookup tables with fallback values
    available_lookup_keys = list(maturity_to_base_rate_A.keys())
    base_rates = [maturity_to_base_rate_A.get(
        get_nearest_maturity(m, available_lookup_keys), 42.0) for m in maturities]
    
    reinvest_rates = [maturity_to_reinvest_rate_A.get(
        get_nearest_maturity(m, list(maturity_to_reinvest_rate_A.keys())), 30.0) for m in maturities]
    
    # Calculate Class B nominal based on minimum percentage
    total_a_nominal = sum(nominals)
    if total_a_nominal <= 0:
        return {
            'is_valid': False,
            'score': 0,
            'results': None,
            'error': "Total Class A nominal must be positive",
            'b_nominal': 0
        }
        
    class_b_nominal = (total_a_nominal * min_class_b_percent) / (100 - min_class_b_percent)
    
    # Set up parameters for calculation
    a_maturity_days = maturities
    a_spreads = [0.0] * len(a_maturity_days)
    b_maturity_days = [int(class_b_maturity)]  # Ensure integer
    b_nominal = [class_b_nominal]
    b_spreads = [0.0]
    
    # Combine all parameters
    all_maturity_days = a_maturity_days + b_maturity_days
    all_base_rates = base_rates + [class_b_base_rate]
    all_spreads = a_spreads + b_spreads
    all_reinvest_rates = reinvest_rates + [class_b_reinvest_rate]
    all_nominal = nominals + b_nominal
    
    # Calculate maturity dates
    all_maturity_dates = [start_date + pd.Timedelta(days=days) for days in all_maturity_days]
    
    try:
        # Distribute cash flows to tranches
        tranch_cash_flows = assign_cash_flows_to_tranches(
            df_temp, start_date, all_maturity_dates, all_reinvest_rates
        )
        
        # Calculate results for each tranche
        results = []
        buffer = 0.0
        
        for i in range(len(all_maturity_days)):
            is_class_a = (i < len(a_maturity_days))
            
            # Calculate cash flow totals
            c_flow, r_return, total_principal, total_interest = calculate_totals(
                tranch_cash_flows[i], all_maturity_dates[i], all_reinvest_rates[i]
            )
            
            # Buffer reinvestment calculation
            if i > 0 and buffer > 0:
                dd = all_maturity_days[i] - all_maturity_days[i-1]
                if dd > 0:
                    factor = (1 + simple_to_compound_annual(all_reinvest_rates[i])/100)**(dd/365) - 1
                    buffer_reinv = buffer * factor
                else:
                    buffer_reinv = 0
            else:
                buffer_reinv = 0
            
            # Total available funds
            total_available = c_flow + r_return + buffer + buffer_reinv
            
            # Interest rate calculations
            base_rate_val = all_base_rates[i]
            spread_bps = all_spreads[i]
            total_rate = base_rate_val + (spread_bps/100.0)
            
            if is_class_a:
                # Class A payment logic
                nominal_pmt = all_nominal[i]
                discount_factor = 1 / (1 + (total_rate/100 * all_maturity_days[i]/365)) if all_maturity_days[i] > 0 else 1
                principal = nominal_pmt * discount_factor
                interest = nominal_pmt - principal
                coupon_payment = 0
                total_payment = nominal_pmt
            else:
                # Class B payment logic
                nominal_pmt = all_nominal[i]
                principal = nominal_pmt
                coupon_payment = max(0, total_available - principal)
                interest = 0
                total_payment = principal + coupon_payment
            
            # Calculate buffer - avoid division by zero
            new_buffer = max(0, total_available - total_payment)
            buffer_cf_ratio = (new_buffer / nominal_pmt * 100) if nominal_pmt > 0 else 0
            
            # Add to results
            results.append({
                "is_class_a": is_class_a,
                "principal": principal,
                "interest": interest,
                "coupon_payment": coupon_payment,
                "total_payment": total_payment,
                "buffer_cf_ratio": buffer_cf_ratio,
                "maturity_days": all_maturity_days[i],
                "base_rate": base_rate_val,
                "nominal": all_nominal[i]
            })
            
            # Update buffer for next tranche
            buffer = new_buffer
        
        # Split results by class
        class_a_results = [r for r in results if r['is_class_a']]
        class_b_results = [r for r in results if not r['is_class_a']]
        
        # Calculate key metrics
        class_a_principal = sum(r['principal'] for r in class_a_results)
        class_b_principal = sum(r['principal'] for r in class_b_results)
        class_a_interest = sum(r['interest'] for r in class_a_results)
        class_b_coupon = sum(r['coupon_payment'] for r in class_b_results)
        class_a_total = sum(r['total_payment'] for r in class_a_results)
        class_b_total = sum(r['total_payment'] for r in class_b_results)
        
        # Calculate Class B effective coupon rate (annualized)
        if class_b_results and class_b_principal > 0:
            class_b_maturity_days = class_b_results[0]['maturity_days']
            class_b_coupon_rate = (class_b_coupon / class_b_principal) * (365 / class_b_maturity_days) * 100
        else:
            class_b_coupon_rate = 0.0
        
        min_buffer_actual = min(r['buffer_cf_ratio'] for r in class_a_results) if class_a_results else 0.0
        
        # Check if valid
        is_valid = min_buffer_actual >= min_buffer
        
        # Collect results
        result_dict = {
            'class_a_principal': class_a_principal,
            'class_b_principal': class_b_principal,
            'class_a_interest': class_a_interest, 
            'class_b_coupon': class_b_coupon,
            'class_a_total': class_a_total,
            'class_b_total': class_b_total,
            'min_buffer_actual': min_buffer_actual,
            'total_principal': class_a_principal + class_b_principal,
            'class_b_coupon_rate': class_b_coupon_rate,
        }
        
        # Calculate weighted score based on principal and coupon rate match
        coupon_rate_diff = abs(class_b_coupon_rate - target_class_b_coupon_rate)
        coupon_rate_weight = 1.0 / (1.0 + coupon_rate_diff / 10.0)  # Penalty for difference
        weighted_principal = result_dict['total_principal'] * coupon_rate_weight
        
        return {
            'is_valid': is_valid,
            'score': weighted_principal if is_valid else 0,
            'results': result_dict if is_valid else None,
            'b_nominal': class_b_nominal
        }
    
    except Exception as e:
        # Return invalid result on any error
        logger.error(f"Error in evaluate_params: {str(e)}")
        logger.debug(traceback.format_exc())
        return {
            'is_valid': False,
            'score': 0,
            'results': None,
            'error': str(e),
            'b_nominal': class_b_nominal
        }

def perform_optimization(df: pd.DataFrame, general_settings: GeneralSettings, optimization_settings: OptimizationSettings) -> OptimizationResult:
    """Perform ABS structure optimization with improved coupon rate targeting
    
    Args:
        df: DataFrame containing cash flow data
        general_settings: General settings for the optimization
        optimization_settings: Optimization-specific settings
        
    Returns:
        OptimizationResult object with the optimized structure
    """
    
    # Initialize progress tracking
    optimization_progress.update(step=0, total=100, 
                                phase="Classic Optimization", 
                                message="Starting classic optimization...")
    
    # Extract settings
    min_a_tranches, max_a_tranches = optimization_settings.a_tranches_range
    maturity_range = optimization_settings.maturity_range
    maturity_step = optimization_settings.maturity_step
    min_class_b_percent = optimization_settings.min_class_b_percent
    target_class_b_coupon_rate = optimization_settings.target_class_b_coupon_rate
    additional_days = optimization_settings.additional_days_for_class_b
    
    # Set maximum allowed difference for coupon rate
    max_allowed_diff = 1.0  # Maximum 1% difference
    
    optimization_progress.update(step=5, 
                               message=f"Target coupon rate: {target_class_b_coupon_rate}%, preparing data...")
    
    start_date = pd.Timestamp(general_settings.start_date)
    ops_expenses = general_settings.operational_expenses
    min_buffer = general_settings.min_buffer
    
    # Get original parameters for Class A from the example data
    original_maturities_A = [61, 120, 182, 274]
    original_base_rates_A = [45.6, 44.5, 43.3, 42.5]
    original_reinvest_rates_A = [40.0, 37.25, 32.5, 30.0]
    
    # Class B values (fallback values)
    class_b_maturity_orig = 300
    class_b_base_rate_orig = 0.0
    class_b_reinvest_rate_orig = 25.5
    
    optimization_progress.update(step=10, 
                               message="Creating rate lookup tables and preparing data...")
    
    # Create rate lookup tables for Class A
    maturity_to_base_rate_A = dict(zip(original_maturities_A, original_base_rates_A))
    maturity_to_reinvest_rate_A = dict(zip(original_maturities_A, original_reinvest_rates_A))
    
    # Calculate total nominal amount (from example)
    total_a_nominal = 1765000000  # Example from original code
    
    # Define search space
    num_a_tranches_options = range(min_a_tranches, max_a_tranches + 1)
    possible_maturities = list(range(maturity_range[0], maturity_range[1] + 1, maturity_step))
    
    optimization_progress.update(step=15, 
                               message=f"Using tranches from {min_a_tranches} to {max_a_tranches}")
    
    # Dictionaries to track best results for each strategy
    strategy_names = ["equal", "increasing", "decreasing", "middle_weighted"]
    
    best_params_by_strategy = {strategy: None for strategy in strategy_names}
    best_results_by_strategy = {strategy: None for strategy in strategy_names}
    best_weighted_principal_by_strategy = {strategy: 0 for strategy in strategy_names}
    best_coupon_rate_diff_by_strategy = {strategy: float('inf') for strategy in strategy_names}
    
    # Find last cash flow day
    last_cash_flow_day = get_last_cash_flow_day(df, start_date)
    
    optimization_progress.update(step=20, 
                               message=f"Last cash flow day: {last_cash_flow_day}")
    
    # Create a temporary copy of dataframe for calculations
    df_temp = df.copy()
    df_temp['cash_flow'] = df_temp['original_cash_flow'].copy()
    target_date = pd.Timestamp('2025-02-16')
    target_rows = df_temp[df_temp['installment_date'].dt.date == target_date.date()]
    
    if not target_rows.empty:
        t_idx = target_rows.index[0]
        orig_cf = df_temp.at[t_idx, 'cash_flow']
        new_cf = max(0, orig_cf - ops_expenses)
        df_temp.at[t_idx, 'cash_flow'] = new_cf
    
    # Initialize progress counter
    current_iteration = 0
    
    # Calculate total iterations (approximate)
    total_maturity_combinations = 0
    for num_a_tranches in num_a_tranches_options:
        # Rough estimate of combinations, will be reduced later
        total_maturity_combinations += min(1000, len(list(itertools.combinations(possible_maturities, num_a_tranches))))
    
    # 4 strategies per maturity combo
    total_iterations = total_maturity_combinations * 4
    optimization_progress.update(message=f"Estimated iterations: {total_iterations}")
    
    # Progress tracking variables
    current_phase = "Testing Configurations"
    optimization_progress.update(phase=current_phase)
    
    # Loop through Class A tranche counts
    for num_a_tranches_idx, num_a_tranches in enumerate(num_a_tranches_options):
        tranche_progress_base = 20 + (num_a_tranches_idx * 15)  # 15% progress per tranche count
        
        optimization_progress.update(
            step=tranche_progress_base,
            message=f"Testing with {num_a_tranches} Class A tranches"
        )
        
        # Minimum gap between consecutive maturities
        min_gap = 15  # In days
        
        # Create sequential maturity combinations
        maturity_combinations = []
        for maturities in itertools.combinations(possible_maturities, num_a_tranches):
            # Check if sorted and with minimum gap
            sorted_maturities = sorted(maturities)
            if all(sorted_maturities[i+1] - sorted_maturities[i] >= min_gap for i in range(len(sorted_maturities)-1)):
                maturity_combinations.append(sorted_maturities)
        
        # If too many combinations, sample a reasonable number
        max_samples = 100
        if len(maturity_combinations) > max_samples:
            sampled_indices = np.random.choice(len(maturity_combinations), max_samples, replace=False)
            maturity_combinations = [maturity_combinations[i] for i in sampled_indices]
        
        # Calculate progress step for this set of combinations
        combo_count = len(maturity_combinations)
        combo_progress_step = 10 / max(1, combo_count)
        
        # Process maturity combinations
        for combo_idx, maturities in enumerate(maturity_combinations):
            combo_progress = tranche_progress_base + (combo_idx * combo_progress_step)
            
            if combo_idx % 5 == 0:  # Update every 5 combinations to avoid too many updates
                optimization_progress.update(
                    step=int(combo_progress),
                    message=f"Testing maturity combination {combo_idx+1}/{combo_count}: {maturities}"
                )
            
            # Calculate Class B maturity as Last Cash Flow Day + Additional Days
            class_b_maturity = min(365, last_cash_flow_day + additional_days)
            
            # Assign rates based on nearest original Class A maturity
            a_base_rates = []
            a_reinvest_rates = []
            for m in maturities:
                nearest = get_nearest_maturity(m, original_maturities_A)
                a_base_rates.append(maturity_to_base_rate_A[nearest])
                a_reinvest_rates.append(maturity_to_reinvest_rate_A[nearest])
            
            # Use the base rate of the longest Class A tranche for Class B
            # but always use the original reinvest rate from UI
            if len(a_base_rates) > 0:
                b_base_rate = a_base_rates[-1]  # Use the base rate of the longest-maturity Class A tranche
                b_reinvest_rate = class_b_reinvest_rate_orig  # Always use original reinvest rate
            else:
                b_base_rate = class_b_base_rate_orig
                b_reinvest_rate = class_b_reinvest_rate_orig
            
            # Different nominal distribution strategies
            distribution_strategies = [
                "equal",               # Equal distribution
                "increasing",          # Increasing by maturity
                "decreasing",          # Decreasing by maturity
                "middle_weighted"      # More weight to middle tranches
            ]
            
            for strategy_idx, strategy in enumerate(distribution_strategies):
                strategy_progress = combo_progress + (strategy_idx * (combo_progress_step / 4))
                
                if combo_idx % 5 == 0 and strategy_idx == 0:  # Limit updates
                    optimization_progress.update(
                        step=int(strategy_progress),
                        message=f"Testing strategy: {strategy} for combination {combo_idx+1}"
                    )
                
                # Calculate Class B nominal based on minimum percentage
                total_nominal_amount = total_a_nominal / (1 - min_class_b_percent/100)
                class_b_nominal = total_nominal_amount * (min_class_b_percent / 100)
                remaining_nominal = total_nominal_amount - class_b_nominal
                
                # Distribute nominal amounts based on strategy
                if strategy == "equal":
                    a_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                    
                elif strategy == "increasing":
                    # Weight by maturity days
                    weights = np.array(maturities)
                    a_nominals = (weights / weights.sum()) * remaining_nominal
                    
                elif strategy == "decreasing":
                    # Inverse weight by maturity days
                    weights = 1 / np.array(maturities)
                    a_nominals = (weights / weights.sum()) * remaining_nominal
                    
                elif strategy == "middle_weighted":
                    # Give more weight to middle tranches
                    if num_a_tranches >= 3:
                        weights = np.ones(num_a_tranches)
                        mid_idx = num_a_tranches // 2
                        weights[mid_idx] = 1.5
                        if num_a_tranches > 3:
                            weights[mid_idx-1] = 1.3
                            weights[mid_idx+1] = 1.3
                        a_nominals = (weights / weights.sum()) * remaining_nominal
                    else:
                        a_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                
                # Round to nearest 1000
                a_nominals = [round(n / 1000) * 1000 for n in a_nominals]
                
                # Ensure sum equals the remaining nominal
                adjustment = (remaining_nominal - sum(a_nominals)) / num_a_tranches
                a_nominals = [n + adjustment for n in a_nominals]
                a_nominals = [round(n / 1000) * 1000 for n in a_nominals]
                
                # Make final adjustment to last tranche to ensure exact total
                a_nominals[-1] += remaining_nominal - sum(a_nominals)
                
                # Now adjust the nominals to achieve target coupon rate
                adjusted_a_nominals, success = adjust_class_a_nominals_for_target_coupon(
                    a_nominals, 
                    class_b_nominal, 
                    target_class_b_coupon_rate,
                    class_b_maturity,
                    maturities, 
                    a_base_rates, 
                    a_reinvest_rates, 
                    b_base_rate, 
                    b_reinvest_rate,
                    start_date, 
                    df_temp, 
                    min_buffer,
                    max_allowed_diff
                )
                
                if success:
                    a_nominals = adjusted_a_nominals
                
                # Set up parameters for calculation
                a_maturity_days = list(maturities)
                a_spreads = [0.0] * len(a_maturity_days)
                b_maturity_days = [class_b_maturity]
                b_nominal = [class_b_nominal]
                b_spreads = [0.0]
                
                # Combine all parameters
                all_maturity_days = a_maturity_days + b_maturity_days
                all_base_rates = a_base_rates + [b_base_rate]
                all_spreads = a_spreads + b_spreads
                all_reinvest_rates = a_reinvest_rates + [b_reinvest_rate]
                all_nominal = a_nominals + b_nominal
                
                # Calculate maturity dates
                all_maturity_dates = [start_date + pd.Timedelta(days=days) for days in all_maturity_days]
                
                # Distribute cash flows to tranches
                try:
                    tranch_cash_flows = assign_cash_flows_to_tranches(
                        df_temp, start_date, all_maturity_dates, all_reinvest_rates
                    )
                    
                    # Calculate results for each tranche
                    results = []
                    buffer = 0.0
                    
                    for i in range(len(all_maturity_days)):
                        is_class_a = (i < len(a_maturity_days))
                        
                        # Calculate cash flow totals
                        c_flow, r_return, total_principal, total_interest = calculate_totals(
                            tranch_cash_flows[i], all_maturity_dates[i], all_reinvest_rates[i]
                        )
                        
                        # Buffer reinvestment calculation
                        if i > 0 and buffer > 0:
                            dd = all_maturity_days[i] - all_maturity_days[i-1]
                            if dd > 0:
                                factor = (1 + simple_to_compound_annual(all_reinvest_rates[i])/100)**(dd/365) - 1
                                buffer_reinv = buffer * factor
                            else:
                                buffer_reinv = 0
                        else:
                            buffer_reinv = 0
                        
                        # Total available funds
                        total_available = c_flow + r_return + buffer + buffer_reinv
                        
                        # Interest rate calculations
                        base_rate_val = all_base_rates[i]
                        spread_bps = all_spreads[i]
                        total_rate = base_rate_val + (spread_bps/100.0)
                        
                        if is_class_a:
                            # Class A payment logic
                            nominal_pmt = all_nominal[i]
                            discount_factor = 1 / (1 + (total_rate/100 * all_maturity_days[i]/365)) if all_maturity_days[i] > 0 else 1
                            principal = nominal_pmt * discount_factor
                            interest = nominal_pmt - principal
                            coupon_payment = 0
                            total_payment = nominal_pmt
                        else:
                            # Class B payment logic
                            nominal_pmt = all_nominal[i]
                            principal = nominal_pmt
                            coupon_payment = max(0, total_available - principal)
                            interest = 0
                            total_payment = principal + coupon_payment
                        
                        # Calculate buffer with division by zero protection
                        new_buffer = max(0, total_available - total_payment)
                        buffer_cf_ratio = (new_buffer / nominal_pmt * 100) if nominal_pmt > 0 else 0
                        
                        # Add to results
                        results.append({
                            "is_class_a": is_class_a,
                            "principal": principal,
                            "interest": interest,
                            "coupon_payment": coupon_payment,
                            "total_payment": total_payment,
                            "buffer_cf_ratio": buffer_cf_ratio,
                            "maturity_days": all_maturity_days[i],
                            "base_rate": base_rate_val,
                            "nominal": all_nominal[i],
                            "discount_factor": discount_factor
                        })
                        
                        # Update buffer for next tranche
                        buffer = new_buffer
                    
                    # Split results by class
                    class_a_results = [r for r in results if r['is_class_a']]
                    class_b_results = [r for r in results if not r['is_class_a']]
                    
                    # Calculate key metrics
                    class_a_principal = sum(r['principal'] for r in class_a_results)
                    class_b_principal = sum(r['principal'] for r in class_b_results)
                    class_a_interest = sum(r['interest'] for r in class_a_results)
                    class_b_coupon = sum(r['coupon_payment'] for r in class_b_results)
                    class_a_total = sum(r['total_payment'] for r in class_a_results)
                    class_b_total = sum(r['total_payment'] for r in class_b_results)
                    
                    # Class B base rate should match the last Class A's
                    class_b_base_rate = class_b_results[0]['base_rate'] if class_b_results else 0.0
                    
                    # Calculate Class B effective coupon rate (annualized)
                    if class_b_results and class_b_principal > 0:
                        class_b_maturity_days = class_b_results[0]['maturity_days']
                        class_b_coupon_rate = (class_b_coupon / class_b_principal) * (365 / class_b_maturity_days) * 100
                    else:
                        class_b_coupon_rate = 0.0
                    
                    min_buffer_actual = min(r['buffer_cf_ratio'] for r in class_a_results) if class_a_results else 0.0
                    
                    # Calculate difference from target coupon rate
                    coupon_rate_diff = abs(class_b_coupon_rate - target_class_b_coupon_rate)
                    
                    # Check if valid and meets buffer requirement
                    if min_buffer_actual >= min_buffer:
                        total_principal = class_a_principal + class_b_principal
                        
                        # Calculate weighted score based on principal and coupon rate match
                        # Use exponential penalty for larger differences
                        coupon_rate_weight = np.exp(-coupon_rate_diff / 5.0)  # Stronger penalty for rate difference
                        weighted_principal = total_principal * coupon_rate_weight
                        
                        # Check if this is the best solution for this strategy
                        # Prioritize solutions with smaller coupon rate differences
                        is_better = False
                        
                        if coupon_rate_diff <= best_coupon_rate_diff_by_strategy[strategy]:
                            # If coupon rate difference is better or equal, check weighted principal
                            if coupon_rate_diff < best_coupon_rate_diff_by_strategy[strategy] or \
                               weighted_principal > best_weighted_principal_by_strategy[strategy]:
                                is_better = True
                        elif coupon_rate_diff <= max_allowed_diff and \
                             weighted_principal > best_weighted_principal_by_strategy[strategy]:
                            # If within allowed difference and better weighted principal
                            is_better = True
                        
                        if is_better:
                            best_coupon_rate_diff_by_strategy[strategy] = coupon_rate_diff
                            best_weighted_principal_by_strategy[strategy] = weighted_principal
                            
                            best_params_by_strategy[strategy] = {
                                'num_a_tranches': num_a_tranches,
                                'a_maturity_days': a_maturity_days,
                                'a_base_rates': a_base_rates,
                                'a_reinvest_rates': a_reinvest_rates,
                                'a_nominal_amounts': a_nominals,
                                'b_maturity_days': b_maturity_days,
                                'b_base_rates': [b_base_rate],
                                'b_reinvest_rates': [b_reinvest_rate],
                                'b_nominal': b_nominal,
                                'strategy': strategy,
                                'last_cash_flow_day': last_cash_flow_day,
                                'added_days': additional_days
                            }
                            
                            best_results_by_strategy[strategy] = {
                                'class_a_principal': class_a_principal,
                                'class_b_principal': class_b_principal,
                                'class_a_interest': class_a_interest,
                                'class_b_coupon': class_b_coupon,
                                'class_a_total': class_a_total,
                                'class_b_total': class_b_total,
                                'min_buffer_actual': min_buffer_actual,
                                'total_principal': total_principal,
                                'class_b_coupon_rate': class_b_coupon_rate,
                                'target_class_b_coupon_rate': target_class_b_coupon_rate,
                                'coupon_rate_diff': coupon_rate_diff,
                                'coupon_rate_weight': coupon_rate_weight,
                                'class_b_base_rate': class_b_base_rate,
                                'num_a_tranches': num_a_tranches
                            }
                            
                            optimization_progress.update(
                                message=f"Found better solution for {strategy}: coupon_rate={class_b_coupon_rate:.2f}%, " +
                                       f"diff={coupon_rate_diff:.2f}%, total_principal={total_principal:,.2f}"
                            )
                
                except Exception as e:
                    logger.error(f"Error in calculation for {strategy} strategy: {str(e)}")
                    logger.debug(traceback.format_exc())
                    # Continue to next strategy
                    continue
                
                # Update iteration counter
                current_iteration += 1
                
                # Update progress periodically
                if current_iteration % 50 == 0:
                    progress_percent = min(80, 20 + int(current_iteration / total_iterations * 60))
                    optimization_progress.update(
                        step=progress_percent,
                        message=f"Completed {current_iteration} iterations out of approximately {total_iterations}"
                    )
    
    # Update progress to preparing results phase
    optimization_progress.update(
        step=85,
        phase="Finalizing Results",
        message="Comparing strategies and preparing results..."
    )
    
    # Compare valid strategies
    valid_strategies = {k: v for k, v in best_results_by_strategy.items() if v is not None}
    
    if not valid_strategies:
        # No valid solution found
        optimization_progress.update(
            step=90,
            message="No valid configuration found. Try adjusting optimization parameters."
        )
        raise ValueError("No valid configuration found. Try adjusting optimization parameters.")
    
    # Find best overall strategy prioritizing coupon rate match
    best_overall_strategy = min(
        valid_strategies.items(),
        key=lambda x: (x[1]['coupon_rate_diff'], -x[1]['total_principal'])
    )[0]
    
    # Get best parameters and results
    best_strategy = best_overall_strategy
    best_params = best_params_by_strategy[best_strategy]
    best_results = best_results_by_strategy[best_strategy]
    
    optimization_progress.update(
        step=95,
        message=f"Selected best strategy: {best_strategy}, coupon_rate: {best_results['class_b_coupon_rate']:.2f}%, " +
               f"diff: {best_results['coupon_rate_diff']:.2f}%, total_principal: {best_results['total_principal']:,.2f}"
    )
    
    # Extract values for the result
    class_a_maturities = best_params['a_maturity_days']
    class_a_nominals = best_params['a_nominal_amounts']
    class_a_rates = best_params['a_base_rates']
    class_a_reinvest = best_params['a_reinvest_rates']
    
    class_b_maturity = best_params['b_maturity_days'][0]
    class_b_rate = best_params['b_base_rates'][0]
    class_b_reinvest = best_params['b_reinvest_rates'][0]
    class_b_nominal = best_params['b_nominal'][0]
    
    # Final progress update
    optimization_progress.update(
        step=100,
        message="Optimization completed successfully."
    )
    
    # Return the optimization result
    return OptimizationResult(
        best_strategy=best_strategy,
        class_a_maturities=class_a_maturities,
        class_a_nominals=class_a_nominals,
        class_a_rates=class_a_rates,
        class_a_reinvest=class_a_reinvest,
        class_b_maturity=class_b_maturity,
        class_b_rate=class_b_rate,
        class_b_reinvest=class_b_reinvest,
        class_b_nominal=class_b_nominal,
        class_b_coupon_rate=best_results['class_b_coupon_rate'],
        min_buffer_actual=best_results['min_buffer_actual'],
        last_cash_flow_day=last_cash_flow_day,
        additional_days=additional_days,
        results_by_strategy={k: v for k, v in best_results_by_strategy.items() if v is not None}
    )

def perform_gradient_optimization(df: pd.DataFrame, general_settings: GeneralSettings, optimization_settings: OptimizationSettings) -> OptimizationResult:
    """Gradient descent optimization with aggressive coupon rate targeting
    
    Args:
        df: DataFrame containing cash flow data
        general_settings: General settings for the optimization
        optimization_settings: Optimization-specific settings
        
    Returns:
        OptimizationResult object with the optimized structure
    """
    try:
        # Initialize progress tracking
        global optimization_progress
        optimization_progress.update(step=0, total=100, 
                                    phase="Gradient Optimization", 
                                    message="Starting gradient optimization...")
        
        # Basic parameters
        max_iterations = getattr(optimization_settings, "max_iterations", 100)
        learning_rate = getattr(optimization_settings, "learning_rate", 0.01)
        start_date = pd.Timestamp(general_settings.start_date)
        ops_expenses = general_settings.operational_expenses
        min_buffer = general_settings.min_buffer
        min_class_b_percent = optimization_settings.min_class_b_percent
        target_class_b_coupon_rate = optimization_settings.target_class_b_coupon_rate
        additional_days = optimization_settings.additional_days_for_class_b
        
        # Strict maximum allowed difference for coupon rate
        max_allowed_diff = 1.0  # Maximum 1% difference for coupon rate
        
        optimization_progress.update(step=5, 
                                    message=f"Target coupon rate: {target_class_b_coupon_rate}%, preparing data...")
        
        # Get last cash flow day
        last_cash_flow_day = get_last_cash_flow_day(df, start_date)
        
        # Class B maturity as Last Cash Flow Day + Additional Days, capped at 365
        class_b_maturity = min(365, last_cash_flow_day + additional_days)
        
        # Get original parameters for Class A from the example data
        original_maturities_A = [61, 120, 182, 274]
        original_base_rates_A = [45.6, 44.5, 43.3, 42.5]
        original_reinvest_rates_A = [40.0, 37.25, 32.5, 30.0]
        
        # Class B values (fallback values)
        class_b_base_rate_orig = 0.0
        class_b_reinvest_rate_orig = 25.5
        
        optimization_progress.update(step=10, 
                                    message="Creating rate lookup tables and preparing data...")
        
        # Create rate lookup tables for Class A
        maturity_to_base_rate_A = dict(zip(original_maturities_A, original_base_rates_A))
        maturity_to_reinvest_rate_A = dict(zip(original_maturities_A, original_reinvest_rates_A))
        
        # Create temporary dataframe for calculation - only do this once
        df_temp = df.copy()
        df_temp['cash_flow'] = df_temp['original_cash_flow'].copy()
        target_date = pd.Timestamp('2025-02-16')
        target_rows = df_temp[df_temp['installment_date'].dt.date == target_date.date()]
        
        if not target_rows.empty:
            t_idx = target_rows.index[0]
            orig_cf = df_temp.at[t_idx, 'cash_flow']
            new_cf = max(0, orig_cf - ops_expenses)
            df_temp.at[t_idx, 'cash_flow'] = new_cf
        
        # Total A nominal (example from original code)
        total_a_nominal = 1765000000
        
        # Fixed number of tranches
        num_a_tranches = 4
        
        optimization_progress.update(step=15, 
                                    message=f"Using {num_a_tranches} tranches for Class A...")
        
        # Calculate Class B nominal based on minimum percentage
        total_nominal_amount = total_a_nominal / (1 - min_class_b_percent/100)
        class_b_nominal = total_nominal_amount * (min_class_b_percent / 100)
        remaining_nominal = total_nominal_amount - class_b_nominal
        
        # Try multiple initial maturity configurations
        maturity_configurations = [
            [60, 120, 180, 270],  # Evenly spaced configuration
            [45, 90, 180, 270],   # Alternative configuration 1
            [30, 90, 150, 210],   # Alternative configuration 2
            [60, 120, 210, 300],  # Alternative configuration 3
            [30, 60, 90, 180]     # Shorter maturities configuration
        ]
        
        # For tracking the best solution found
        best_results = None
        best_params = None
        best_coupon_rate_diff = float('inf')
        
        optimization_progress.update(step=20, 
                                    phase="Testing Configurations",
                                    message="Starting multi-configuration optimization...")
        
        # Calculate progress steps per configuration
        total_configs = len(maturity_configurations)
        config_progress_step = 60 / total_configs
        
        # Loop through different initial maturity configurations
        for config_idx, maturities in enumerate(maturity_configurations):
            config_progress_base = 20 + (config_idx * config_progress_step)
            
            optimization_progress.update(
                step=int(config_progress_base), 
                message=f"Testing configuration {config_idx+1}/{total_configs}: {maturities}"
            )
            
            # Get rates based on nearest original maturity
            base_rates = [maturity_to_base_rate_A.get(get_nearest_maturity(m, original_maturities_A), 42.0) for m in maturities]
            reinvest_rates = [maturity_to_reinvest_rate_A.get(get_nearest_maturity(m, original_maturities_A), 30.0) for m in maturities]
            
            # Start with equal nominal amounts
            equal_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
            
            # Use the aggressive adjustment function to target coupon rate
            adjusted_nominals, adjustment_success = adjust_class_a_nominals_for_target_coupon(
                equal_nominals,
                class_b_nominal,
                target_class_b_coupon_rate,
                class_b_maturity,
                maturities,
                base_rates,
                reinvest_rates,
                class_b_base_rate_orig,
                class_b_reinvest_rate_orig,
                start_date,
                df_temp,
                min_buffer,
                max_allowed_diff
            )
            
            # Update progress
            optimization_progress.update(
                step=int(config_progress_base + config_progress_step * 0.5),
                message=f"Evaluated configuration {config_idx+1}, adjustment success: {adjustment_success}"
            )
            
            if adjustment_success:
                # Evaluate with the successful adjustment
                result = evaluate_params(
                    maturities,
                    adjusted_nominals, 
                    class_b_maturity, 
                    start_date, 
                    df_temp,
                    maturity_to_base_rate_A, 
                    maturity_to_reinvest_rate_A,
                    class_b_base_rate_orig, 
                    class_b_reinvest_rate_orig,
                    min_class_b_percent, 
                    target_class_b_coupon_rate, 
                    min_buffer
                )
                
                if result['is_valid']:
                    coupon_rate = result['results']['class_b_coupon_rate']
                    coupon_rate_diff = abs(coupon_rate - target_class_b_coupon_rate)
                    
                    if coupon_rate_diff < best_coupon_rate_diff:
                        best_coupon_rate_diff = coupon_rate_diff
                        best_results = result['results']
                        best_params = {
                            'a_maturities': maturities,
                            'a_nominals': adjusted_nominals,
                            'a_base_rates': base_rates,
                            'a_reinvest_rates': reinvest_rates,
                            'b_maturity': class_b_maturity,
                            'b_base_rate': class_b_base_rate_orig,
                            'b_reinvest_rate': class_b_reinvest_rate_orig,
                            'b_nominal': class_b_nominal
                        }
                        
                        optimization_progress.update(
                            message=f"Found better solution with coupon rate {coupon_rate:.2f}% (diff: {coupon_rate_diff:.2f}%)"
                        )
                        
                        # If difference is very small, break early
                        if coupon_rate_diff < 0.2:
                            optimization_progress.update(
                                message=f"Found excellent match (diff < 0.2%), breaking early"
                            )
                            break
            
            # Update progress at end of configuration
            optimization_progress.update(
                step=int(config_progress_base + config_progress_step),
                message=f"Completed testing configuration {config_idx+1}/{total_configs}"
            )
        
        # If no solution found with the predefined configurations, try shorter maturities
        if best_results is None:
            optimization_progress.update(
                step=80,
                phase="Alternative Configurations",
                message="Trying alternative configurations with very short maturities..."
            )
            
            # Try configurations with very short maturities
            short_maturity_configs = [
                [15, 30, 45, 60],   # Very short maturities
                [30, 45, 60, 90],   # Short maturities
                [10, 20, 40, 90],   # Mixed short maturities
            ]
            
            for idx, maturities in enumerate(short_maturity_configs):
                optimization_progress.update(
                    step=80 + (idx * 5),
                    message=f"Testing short maturity configuration: {maturities}"
                )
                
                # Get rates
                base_rates = [maturity_to_base_rate_A.get(get_nearest_maturity(m, original_maturities_A), 42.0) for m in maturities]
                reinvest_rates = [maturity_to_reinvest_rate_A.get(get_nearest_maturity(m, original_maturities_A), 30.0) for m in maturities]
                
                # Use extremely small initial nominals (10% of normal)
                small_nominals = [(remaining_nominal / num_a_tranches) * 0.1] * num_a_tranches
                
                # Try adjustment with these small nominals
                adjusted_nominals, adjustment_success = adjust_class_a_nominals_for_target_coupon(
                    small_nominals,
                    class_b_nominal,
                    target_class_b_coupon_rate,
                    class_b_maturity,
                    maturities,
                    base_rates,
                    reinvest_rates,
                    class_b_base_rate_orig,
                    class_b_reinvest_rate_orig,
                    start_date,
                    df_temp,
                    min_buffer,
                    max_allowed_diff
                )
                
                if adjustment_success:
                    result = evaluate_params(
                        maturities,
                        adjusted_nominals, 
                        class_b_maturity, 
                        start_date, 
                        df_temp,
                        maturity_to_base_rate_A, 
                        maturity_to_reinvest_rate_A,
                        class_b_base_rate_orig, 
                        class_b_reinvest_rate_orig,
                        min_class_b_percent, 
                        target_class_b_coupon_rate, 
                        min_buffer
                    )
                    
                    if result['is_valid']:
                        coupon_rate = result['results']['class_b_coupon_rate']
                        coupon_rate_diff = abs(coupon_rate - target_class_b_coupon_rate)
                        
                        if coupon_rate_diff < best_coupon_rate_diff:
                            best_coupon_rate_diff = coupon_rate_diff
                            best_results = result['results']
                            best_params = {
                                'a_maturities': maturities,
                                'a_nominals': adjusted_nominals,
                                'a_base_rates': base_rates,
                                'a_reinvest_rates': reinvest_rates,
                                'b_maturity': class_b_maturity,
                                'b_base_rate': class_b_base_rate_orig,
                                'b_reinvest_rate': class_b_reinvest_rate_orig,
                                'b_nominal': class_b_nominal
                            }
                            
                            optimization_progress.update(
                                message=f"Found better solution with short maturities: coupon rate {coupon_rate:.2f}% (diff: {coupon_rate_diff:.2f}%)"
                            )
                            
                            if coupon_rate_diff < 0.2:
                                break
        
        # Final phase - preparing results
        optimization_progress.update(step=95, phase="Finalizing Results", 
                                    message="Preparing optimization results...")
        
        # If no solution was found that meets our criteria
        if best_results is None:
            # Fall back to classic optimization method rather than failing
            optimization_progress.update(
                message="Gradient optimization couldn't find a solution matching the target coupon rate. Falling back to classic optimization method..."
            )
            
            return perform_optimization(df, general_settings, optimization_settings)
        
        optimization_progress.update(
            message=f"Gradient optimization completed. Best coupon rate: {best_results['class_b_coupon_rate']:.2f}% (target: {target_class_b_coupon_rate:.2f}%, diff: {best_coupon_rate_diff:.2f}%)"
        )
        
        # Prepare and return the result
        result = OptimizationResult(
            best_strategy="gradient",
            class_a_maturities=best_params['a_maturities'],
            class_a_nominals=best_params['a_nominals'],
            class_a_rates=best_params['a_base_rates'],
            class_a_reinvest=best_params['a_reinvest_rates'],
            class_b_maturity=best_params['b_maturity'],
            class_b_rate=best_params['b_base_rate'],
            class_b_reinvest=best_params['b_reinvest_rate'],
            class_b_nominal=best_params['b_nominal'],
            class_b_coupon_rate=best_results.get('class_b_coupon_rate', 0),
            min_buffer_actual=best_results.get('min_buffer_actual', 0),
            last_cash_flow_day=last_cash_flow_day,
            additional_days=additional_days,
            results_by_strategy={"gradient": best_results}
        )
        
        # Final progress update
        optimization_progress.update(step=100, 
                                    message="Optimization completed successfully.")
        
        return result
    except Exception as e:
        # Log error, update progress, fall back to classic method
        optimization_progress.update(
            phase="Error Recovery",
            message=f"Error during gradient optimization: {str(e)}. Falling back to classic method..."
        )
        logger.error(f"Gradient optimization error: {str(e)}")
        logger.debug(traceback.format_exc())
        
        return perform_optimization(df, general_settings, optimization_settings)

def perform_bayesian_optimization(df: pd.DataFrame, general_settings: GeneralSettings, optimization_settings: OptimizationSettings) -> OptimizationResult:
    """Bayesian optimization with binary search for coupon rate targeting
    
    Args:
        df: DataFrame containing cash flow data
        general_settings: General settings for the optimization
        optimization_settings: Optimization-specific settings
        
    Returns:
        OptimizationResult object with the optimized structure
    """
    try:
        # Initialize progress tracking
        global optimization_progress
        optimization_progress.update(step=0, total=100, 
                                    phase="Bayesian Optimization", 
                                    message="Starting Bayesian optimization...")
        
        # Basic parameters
        start_date = pd.Timestamp(general_settings.start_date)
        ops_expenses = general_settings.operational_expenses
        min_buffer = general_settings.min_buffer
        min_class_b_percent = optimization_settings.min_class_b_percent
        target_class_b_coupon_rate = optimization_settings.target_class_b_coupon_rate
        additional_days = optimization_settings.additional_days_for_class_b
        n_calls = getattr(optimization_settings, "n_calls", 50)
        n_initial_points = getattr(optimization_settings, "n_initial_points", 10)
        
        # Strict maximum allowed difference for coupon rate
        max_allowed_diff = 1.0  # Maximum 1% difference for coupon rate
        
        optimization_progress.update(step=5, 
                                    message=f"Target coupon rate: {target_class_b_coupon_rate}%, preparing data...")
        
        # Get last cash flow day
        last_cash_flow_day = get_last_cash_flow_day(df, start_date)
        
        # Class B maturity as Last Cash Flow Day + Additional Days, capped at 365
        class_b_maturity = min(365, last_cash_flow_day + additional_days)
        
        # Get original parameters for Class A 
        original_maturities_A = [61, 120, 182, 274]
        original_base_rates_A = [45.6, 44.5, 43.3, 42.5]
        original_reinvest_rates_A = [40.0, 37.25, 32.5, 30.0]
        
        # Class B values
        class_b_base_rate_orig = 0.0
        class_b_reinvest_rate_orig = 25.5
        
        optimization_progress.update(step=10, 
                                    message="Creating rate lookup tables and preparing data...")
        
        # Create rate lookup tables for Class A
        maturity_to_base_rate_A = dict(zip(original_maturities_A, original_base_rates_A))
        maturity_to_reinvest_rate_A = dict(zip(original_maturities_A, original_reinvest_rates_A))
        
        # Create temporary dataframe for calculation
        df_temp = df.copy()
        df_temp['cash_flow'] = df_temp['original_cash_flow'].copy()
        target_date = pd.Timestamp('2025-02-16')
        target_rows = df_temp[df_temp['installment_date'].dt.date == target_date.date()]
        
        if not target_rows.empty:
            t_idx = target_rows.index[0]
            orig_cf = df_temp.at[t_idx, 'cash_flow']
            new_cf = max(0, orig_cf - ops_expenses)
            df_temp.at[t_idx, 'cash_flow'] = new_cf
        
        # Total A nominal
        total_a_nominal = 1765000000
        
        # Fixed number of tranches
        num_a_tranches = 4
        
        optimization_progress.update(step=15, 
                                    message=f"Using {num_a_tranches} tranches for Class A")
        
        # Calculate Class B nominal based on minimum percentage
        total_nominal_amount = total_a_nominal / (1 - min_class_b_percent/100)
        class_b_nominal = total_nominal_amount * (min_class_b_percent / 100)
        remaining_nominal = total_nominal_amount - class_b_nominal
        
        # Define different maturity configurations to try
        maturity_configurations = [
            [60, 120, 180, 270],  # Evenly spaced configuration
            [45, 90, 180, 270],   # Alternative configuration 1
            [30, 90, 150, 210],   # Alternative configuration 2
            [60, 120, 210, 300],  # Alternative configuration 3
            [30, 60, 90, 180]     # Shorter maturities configuration
        ]
        
        # Define different nominal distribution patterns to try
        nominal_distributions = [
            [0.25, 0.25, 0.25, 0.25],  # Equal distribution
            [0.4, 0.3, 0.2, 0.1],      # Decreasing distribution
            [0.1, 0.2, 0.3, 0.4],      # Increasing distribution
            [0.15, 0.35, 0.35, 0.15],  # Middle-weighted distribution
            [0.3, 0.1, 0.1, 0.5]       # Weighted at ends
        ]
        
        # Track best results overall
        best_result = None
        best_coupon_rate_diff = float('inf')
        best_maturities = None
        best_nominals = None
        best_base_rates = None
        best_reinvest_rates = None
        
        optimization_progress.update(step=20, 
                                    phase="Testing Configurations",
                                    message="Starting structured Bayesian optimization...")
        
        # Calculate total steps for progress tracking
        total_configs = len(maturity_configurations) * len(nominal_distributions)
        current_config = 0
        config_progress_step = 60 / total_configs
        
        # For each maturity configuration, try different nominal distributions
        for config_idx, maturity_config in enumerate(maturity_configurations):
            for dist_idx, dist_pattern in enumerate(nominal_distributions):
                current_config += 1
                config_progress = 20 + (current_config * config_progress_step)
                
                optimization_progress.update(
                    step=int(config_progress),
                    message=f"Testing configuration {current_config}/{total_configs}"
                )
                
                maturities = maturity_config.copy()
                
                # Get rates based on nearest original maturity
                base_rates = [maturity_to_base_rate_A.get(get_nearest_maturity(m, original_maturities_A), 42.0) for m in maturities]
                reinvest_rates = [maturity_to_reinvest_rate_A.get(get_nearest_maturity(m, original_maturities_A), 30.0) for m in maturities]
                
                # Initial nominals based on distribution pattern
                nominals = [p * remaining_nominal for p in dist_pattern]
                
                # Use the direct Class A nominal adjustment function to target the coupon rate
                adjusted_nominals, adjustment_success = adjust_class_a_nominals_for_target_coupon(
                    nominals,
                    class_b_nominal,
                    target_class_b_coupon_rate,
                    class_b_maturity,
                    maturities,
                    base_rates,
                    reinvest_rates,
                    class_b_base_rate_orig,
                    class_b_reinvest_rate_orig,
                    start_date,
                    df_temp,
                    min_buffer,
                    max_allowed_diff
                )
                
                if adjustment_success:
                    # If adjustment was successful, evaluate the results
                    result = evaluate_params(
                        maturities, 
                        adjusted_nominals, 
                        class_b_maturity, 
                        start_date, 
                        df_temp,
                        maturity_to_base_rate_A, 
                        maturity_to_reinvest_rate_A,
                        class_b_base_rate_orig, 
                        class_b_reinvest_rate_orig,
                        min_class_b_percent, 
                        target_class_b_coupon_rate, 
                        min_buffer
                    )
                    
                    if result['is_valid']:
                        coupon_rate = result['results']['class_b_coupon_rate']
                        coupon_rate_diff = abs(coupon_rate - target_class_b_coupon_rate)
                        
                        if coupon_rate_diff <= max_allowed_diff:
                            total_principal = result['results']['total_principal']
                            
                            if coupon_rate_diff < best_coupon_rate_diff:
                                best_coupon_rate_diff = coupon_rate_diff
                                best_result = result
                                best_maturities = maturities
                                best_nominals = adjusted_nominals
                                best_base_rates = base_rates
                                best_reinvest_rates = reinvest_rates
                                
                                optimization_progress.update(
                                    message=f"Found better solution with coupon rate {coupon_rate:.2f}% (diff: {coupon_rate_diff:.2f}%)"
                                )
                                
                                # If we found a very good match, break early
                                if coupon_rate_diff < 0.2:
                                    optimization_progress.update(
                                        message=f"Found excellent match (diff < 0.2%), breaking early"
                                    )
                                    break
            
            # If we found a very good match in this configuration, break early
            if best_coupon_rate_diff < 0.2:
                break
# Phase 2: If no solution found with predefined configurations, do random search
        if best_result is None:
            optimization_progress.update(
                step=80,
                phase="Random Search",
                message="Initial strategies failed. Proceeding with random search..."
            )
            
            # Try more random maturity combinations, focusing on coupon rate adjustment
            n_random_trials = min(30, n_calls)  # Cap at 30 to avoid taking too long
            random_progress_step = 15 / n_random_trials
            
            for i in range(n_random_trials):
                random_progress = 80 + (i * random_progress_step)
                
                optimization_progress.update(
                    step=int(random_progress),
                    message=f"Random search {i+1}/{n_random_trials}"
                )
                
                # Generate random maturities with minimum gap
                maturities = []
                min_gap = 15  # days
                min_maturity = 30
                max_maturity = 365
                
                # First maturity
                maturities.append(random.randint(min_maturity, 120))
                
                # Add remaining maturities with minimum gap
                for j in range(1, num_a_tranches):
                    min_val = maturities[-1] + min_gap
                    max_val = min(max_maturity, maturities[-1] + 90)
                    
                    if min_val >= max_val:
                        min_val = max_val
                    
                    maturities.append(random.randint(min_val, max_val))
                
                # Get rates based on nearest original maturity
                base_rates = [maturity_to_base_rate_A.get(get_nearest_maturity(m, original_maturities_A), 42.0) for m in maturities]
                reinvest_rates = [maturity_to_reinvest_rate_A.get(get_nearest_maturity(m, original_maturities_A), 30.0) for m in maturities]
                
                # Generate equal nominals
                nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                
                # Use the adjustment function to target coupon rate
                adjusted_nominals, adjustment_success = adjust_class_a_nominals_for_target_coupon(
                    nominals,
                    class_b_nominal,
                    target_class_b_coupon_rate,
                    class_b_maturity,
                    maturities,
                    base_rates,
                    reinvest_rates,
                    class_b_base_rate_orig,
                    class_b_reinvest_rate_orig,
                    start_date,
                    df_temp,
                    min_buffer,
                    max_allowed_diff
                )
                
                if adjustment_success:
                    # Evaluate the results
                    result = evaluate_params(
                        maturities, 
                        adjusted_nominals, 
                        class_b_maturity, 
                        start_date, 
                        df_temp,
                        maturity_to_base_rate_A, 
                        maturity_to_reinvest_rate_A,
                        class_b_base_rate_orig, 
                        class_b_reinvest_rate_orig,
                        min_class_b_percent, 
                        target_class_b_coupon_rate, 
                        min_buffer
                    )
                    
                    if result['is_valid']:
                        coupon_rate = result['results']['class_b_coupon_rate']
                        coupon_rate_diff = abs(coupon_rate - target_class_b_coupon_rate)
                        
                        if coupon_rate_diff <= max_allowed_diff:
                            total_principal = result['results']['total_principal']
                            
                            if coupon_rate_diff < best_coupon_rate_diff:
                                best_coupon_rate_diff = coupon_rate_diff
                                best_result = result
                                best_maturities = maturities
                                best_nominals = adjusted_nominals
                                best_base_rates = base_rates
                                best_reinvest_rates = reinvest_rates
                                
                                optimization_progress.update(
                                    message=f"Found better solution with coupon rate {coupon_rate:.2f}% (diff: {coupon_rate_diff:.2f}%)"
                                )
                                
                                # If we found a very good match, break early
                                if coupon_rate_diff < 0.2:
                                    optimization_progress.update(
                                        message=f"Found excellent match (diff < 0.2%), breaking early"
                                    )
                                    break
        
        # Final phase - preparing results
        optimization_progress.update(step=95, phase="Finalizing Results", 
                                    message="Preparing optimization results...")
        
        # If no solution was found that meets our criteria
        if best_result is None:
            # Fall back to classic optimization method rather than failing
            optimization_progress.update(
                message="Bayesian optimization couldn't find a solution matching the target coupon rate. Falling back to classic optimization method..."
            )
            
            return perform_optimization(df, general_settings, optimization_settings)
        
        optimization_progress.update(
            message=f"Bayesian optimization completed. Best coupon rate: {best_result['results']['class_b_coupon_rate']:.2f}% (target: {target_class_b_coupon_rate:.2f}%, diff: {best_coupon_rate_diff:.2f}%)"
        )
        
        # Prepare the result - ensure maturities are integers
        result = OptimizationResult(
            best_strategy="bayesian",
            class_a_maturities=[int(m) for m in best_maturities],
            class_a_nominals=best_nominals,
            class_a_rates=best_base_rates,
            class_a_reinvest=best_reinvest_rates,
            class_b_maturity=int(class_b_maturity),
            class_b_rate=class_b_base_rate_orig,
            class_b_reinvest=class_b_reinvest_rate_orig,
            class_b_nominal=best_result.get('b_nominal', 0),
            class_b_coupon_rate=best_result['results'].get('class_b_coupon_rate', 0),
            min_buffer_actual=best_result['results'].get('min_buffer_actual', 0),
            last_cash_flow_day=int(last_cash_flow_day),
            additional_days=int(additional_days),
            results_by_strategy={"bayesian": best_result['results']}
        )
        
        # Final progress update
        optimization_progress.update(step=100, 
                                    message="Optimization completed successfully.")
        
        return result
    except Exception as e:
        # Log error, update progress, fall back to classic method
        optimization_progress.update(
            phase="Error Recovery",
            message=f"Error during Bayesian optimization: {str(e)}. Falling back to classic method..."
        )
        logger.error(f"Bayesian optimization error: {str(e)}")
        logger.debug(traceback.format_exc())
        
        return perform_optimization(df, general_settings, optimization_settings)

def perform_genetic_optimization(df: pd.DataFrame, general_settings: GeneralSettings, optimization_settings: OptimizationSettings) -> OptimizationResult:
    """Genetic algorithm optimization
    
    Args:
        df: DataFrame containing cash flow data
        general_settings: General settings for the optimization
        optimization_settings: Optimization-specific settings
        
    Returns:
        OptimizationResult object with the optimized structure
    """
    try:
        # Initialize progress tracking
        optimization_progress.update(step=0, total=100, 
                                    phase="Genetic Optimization", 
                                    message="Starting genetic algorithm optimization...")
        
        logger.info("Starting genetic algorithm optimization...")
        
        # Basic parameters
        start_date = pd.Timestamp(general_settings.start_date)
        ops_expenses = general_settings.operational_expenses
        min_buffer = general_settings.min_buffer
        min_class_b_percent = optimization_settings.min_class_b_percent
        target_class_b_coupon_rate = optimization_settings.target_class_b_coupon_rate
        additional_days = optimization_settings.additional_days_for_class_b
        population_size = getattr(optimization_settings, "population_size", 50)
        num_generations = getattr(optimization_settings, "num_generations", 40)
        
        optimization_progress.update(step=5, 
                                    message=f"Population size: {population_size}, generations: {num_generations}")
        
        logger.info(f"Parameters: population_size={population_size}, num_generations={num_generations}")
        
        # Get last cash flow day
        last_cash_flow_day = get_last_cash_flow_day(df, start_date)
        
        # Update progress to 10%
        optimization_progress.update(step=10, 
                                    message=f"Last cash flow day: {last_cash_flow_day}")
        
        # Class B maturity as Last Cash Flow Day + Additional Days, capped at 365
        class_b_maturity = min(365, last_cash_flow_day + additional_days)
        
        # Get original parameters for Class A 
        original_maturities_A = [61, 120, 182, 274]
        original_base_rates_A = [45.6, 44.5, 43.3, 42.5]
        original_reinvest_rates_A = [40.0, 37.25, 32.5, 30.0]
        
        # Class B values
        class_b_base_rate_orig = 0.0
        class_b_reinvest_rate_orig = 25.5
        
        # Create rate lookup tables for Class A
        maturity_to_base_rate_A = dict(zip(original_maturities_A, original_base_rates_A))
        maturity_to_reinvest_rate_A = dict(zip(original_maturities_A, original_reinvest_rates_A))
        
        # Update progress to 15%
        optimization_progress.update(step=15, 
                                    message="Preparing optimization data...")
        
        # Create temporary dataframe for calculation
        df_temp = df.copy()
        df_temp['cash_flow'] = df_temp['original_cash_flow'].copy()
        target_date = pd.Timestamp('2025-02-16')
        target_rows = df_temp[df_temp['installment_date'].dt.date == target_date.date()]
        
        if not target_rows.empty:
            t_idx = target_rows.index[0]
            orig_cf = df_temp.at[t_idx, 'cash_flow']
            new_cf = max(0, orig_cf - ops_expenses)
            df_temp.at[t_idx, 'cash_flow'] = new_cf
        
        # Total A nominal
        total_a_nominal = 1765000000
        
        # Fixed number of tranches
        num_a_tranches = 4
        
        # Parameter boundaries
        min_maturity = optimization_settings.maturity_range[0]
        max_maturity = optimization_settings.maturity_range[1]
        
        # Initialize population with valid individuals
        population = []
        min_gap = 15  # Minimum days between maturities
        
        optimization_progress.update(step=20, 
                                   phase="Initializing Population",
                                   message="Creating initial population...")
        
        logger.info("Initializing population...")
        
        # Function to create a valid individual
        def create_valid_individual():
            # Generate valid maturities - ensure they are integers
            maturities = []
            maturities.append(random.randint(min_maturity, min_maturity + 60))
            
            for j in range(1, num_a_tranches):
                prev_maturity = maturities[j-1]
                min_new = prev_maturity + min_gap
                max_new = min(max_maturity, prev_maturity + 120)  # Cap max gap
                
                if min_new > max_new:
                    min_new = max_new
                
                maturities.append(random.randint(min_new, max_new))
            
            # Random weights
            weights = [random.random() for _ in range(num_a_tranches)]
            total_weight = sum(weights)
            weights = [w / total_weight for w in weights]
            
            # Convert to nominals
            nominals = [w * total_a_nominal for w in weights]
            
            return {
                'maturities': maturities,
                'nominals': nominals,
                'fitness': 0  # Will be evaluated
            }
        
        # Create initial population
        failure_count = 0
        for i in range(population_size):
            try:
                individual = create_valid_individual()
                population.append(individual)
                
                # Update progress periodically
                if i % 10 == 0:
                    optimization_progress.update(
                        step=20 + int((i / population_size) * 5),
                        message=f"Initializing population: {i+1}/{population_size}"
                    )
            except Exception as e:
                logger.error(f"Error creating individual {i}: {str(e)}")
                failure_count += 1
                # Try again
                if failure_count < 50:  # Limit retries
                    i -= 1  # Retry this index
                else:
                    logger.error("Too many failures creating population, proceeding with limited population")
                    break
        
        # Ensure we have at least some individuals
        if len(population) < 5:
            optimization_progress.update(
                phase="Error",
                message="Failed to create sufficient initial population"
            )
            raise ValueError("Failed to create sufficient initial population")
        
        # Update progress to 25%
        optimization_progress.update(step=25, 
                                   phase="Evolution",
                                   message="Starting genetic algorithm evolution...")
        
        # Evolution loop
        best_individual = None
        best_fitness = -float('inf')
        
        logger.info("Starting genetic algorithm evolution...")
        
        generation_progress_step = 50 / num_generations  # 50% of progress for generations
        
        # Tournament selection function
        def tournament_select(pop, tournament_size=3):
            if not pop:
                raise ValueError("Empty population for tournament selection")
                
            contestants = random.sample(pop, min(tournament_size, len(pop)))
            return max(contestants, key=lambda x: x.get('fitness', -float('inf')))
        
        for generation in range(num_generations):
            # Update progress for each generation
            generation_progress = 25 + int(generation * generation_progress_step)
            optimization_progress.update(
                step=generation_progress,
                message=f"Generation {generation+1} of {num_generations}"
            )
            
            logger.info(f"Generation {generation+1} of {num_generations}")
            
            # Evaluate fitness
            fitness_sum = 0
            valid_count = 0
            
            for idx, individual in enumerate(population):
                try:
                    maturities = individual['maturities']
                    nominals = individual['nominals']
                    
                    # Ensure maturities are integers for evaluation
                    maturities_int = [int(m) for m in maturities]
                    
                    result = evaluate_params(
                        maturities_int, nominals, 
                        class_b_maturity, start_date, df_temp,
                        maturity_to_base_rate_A, maturity_to_reinvest_rate_A,
                        class_b_base_rate_orig, class_b_reinvest_rate_orig,
                        min_class_b_percent, target_class_b_coupon_rate, min_buffer
                    )
                    
                    # Set fitness - ensure it's a number
                    if result['is_valid']:
                        individual['fitness'] = float(result['score'])
                        individual['result'] = result
                        fitness_sum += individual['fitness']
                        valid_count += 1
                    else:
                        individual['fitness'] = -1.0 # Invalid but better than -inf for selection
                        individual['result'] = None
                    
                    # Track the best
                    if individual['fitness'] > best_fitness:
                        best_fitness = individual['fitness']
                        best_individual = individual.copy()
                        logger.info(f"Found better solution: score={best_fitness}")
                        
                        # Update progress message when finding better solution
                        if 'result' in individual and individual['result'] and 'results' in individual['result']:
                            if 'class_b_coupon_rate' in individual['result']['results']:
                                coupon_rate = individual['result']['results']['class_b_coupon_rate']
                                coupon_diff = abs(coupon_rate - target_class_b_coupon_rate)
                                optimization_progress.update(
                                    message=f"Generation {generation+1}: Found better solution with score {best_fitness:.2f}, coupon rate: {coupon_rate:.2f}% (diff: {coupon_diff:.2f}%)"
                                )
                        else:
                            optimization_progress.update(
                                message=f"Generation {generation+1}: Found better solution with score {best_fitness:.2f}"
                            )
                except Exception as e:
                    logger.error(f"Error evaluating individual {idx} in generation {generation}: {str(e)}")
                    # Set very low fitness to avoid selection
                    individual['fitness'] = -float('inf')
                    individual['result'] = None
            
            # Log average fitness for valid individuals
            if valid_count > 0:
                avg_fitness = fitness_sum / valid_count
                logger.info(f"Generation {generation+1} average fitness: {avg_fitness:.2f} ({valid_count} valid individuals)")
            
            # Create next generation
            new_population = []
            
            # Elitism - keep best individuals
            sorted_pop = sorted(population, key=lambda x: x.get('fitness', -float('inf')), reverse=True)
            elite_count = max(2, population_size // 10)
            new_population.extend(sorted_pop[:elite_count])
            
            # Fill rest with crossover and mutation
            crossover_attempts = 0
            while len(new_population) < population_size and crossover_attempts < population_size * 2:
                crossover_attempts += 1
                try:
                    # Tournament selection
                    parent1 = tournament_select(population)
                    parent2 = tournament_select(population)
                    
                    # Crossover - mix maturities
                    child_maturities = []
                    for i in range(num_a_tranches):
                        # 50% chance from each parent
                        if random.random() < 0.5:
                            child_maturities.append(parent1['maturities'][i])
                        else:
                            child_maturities.append(parent2['maturities'][i])
                    
                    # Ensure maturities are valid integers
                    child_maturities = sorted([int(m) for m in child_maturities])
                    
                    # Fix any invalid gaps
                    for i in range(1, num_a_tranches):
                        if child_maturities[i] - child_maturities[i-1] < min_gap:
                            child_maturities[i] = child_maturities[i-1] + min_gap
                    
                    # Weight crossover with averaging
                    child_weights = []
                    for i in range(num_a_tranches):
                        weight1 = parent1['nominals'][i] / total_a_nominal
                        weight2 = parent2['nominals'][i] / total_a_nominal
                        child_weights.append((weight1 + weight2) / 2)
                    
                    # Normalize weights
                    total_weight = sum(child_weights)
                    child_weights = [w / total_weight for w in child_weights]
                    child_nominals = [w * total_a_nominal for w in child_weights]
                    
                    # Mutation - mutate maturities
                    if random.random() < 0.3:  # 30% mutation rate
                        mutation_idx = random.randint(0, num_a_tranches-1)
                        
                        # Different mutation for different positions
                        if mutation_idx == 0:
                            # First maturity
                            child_maturities[0] = random.randint(min_maturity, min(child_maturities[1] - min_gap, min_maturity + 60))
                        elif mutation_idx == num_a_tranches - 1:
                            # Last maturity
                            child_maturities[-1] = random.randint(child_maturities[-2] + min_gap, max_maturity)
                        else:
                            # Middle maturity
                            min_val = child_maturities[mutation_idx-1] + min_gap
                            max_val = child_maturities[mutation_idx+1] - min_gap
                            
                            if min_val < max_val:
                                child_maturities[mutation_idx] = random.randint(min_val, max_val)
                    
                    # Mutation - mutate weights
                    if random.random() < 0.3:
                        mutation_idx = random.randint(0, num_a_tranches-1)
                        mutation_amount = random.uniform(-0.1, 0.1)
                        child_weights[mutation_idx] = max(0.1, min(0.4, child_weights[mutation_idx] + mutation_amount))
                        
                        # Renormalize
                        total_weight = sum(child_weights)
                        child_weights = [w / total_weight for w in child_weights]
                        child_nominals = [w * total_a_nominal for w in child_weights]
                    
                    # Add child to new population
                    new_population.append({
                        'maturities': child_maturities,  # These are already integers
                        'nominals': child_nominals,
                        'fitness': 0  # Will be evaluated in next generation
                    })
                except Exception as e:
                    logger.error(f"Error in crossover/mutation: {str(e)}")
                    continue
            
            # If we couldn't create enough children, fill with new random individuals
            while len(new_population) < population_size:
                try:
                    new_population.append(create_valid_individual())
                except Exception as e:
                    logger.error(f"Error creating new individual to fill population: {str(e)}")
                    # If we failed a few times, just break and proceed with smaller population
                    if len(new_population) > population_size * 0.7:
                        break
            
            # Replace population
            population = new_population
            
            # Early termination if we have an excellent solution
            if best_individual and best_individual.get('result') and best_individual['result'].get('results'):
                best_results = best_individual['result']['results']
                if 'class_b_coupon_rate' in best_results:
                    coupon_diff = abs(best_results['class_b_coupon_rate'] - target_class_b_coupon_rate)
                    if coupon_diff < 0.2:
                        optimization_progress.update(
                            message=f"Found excellent solution (coupon diff < 0.2%), ending evolution early"
                        )
                        break
        
        # Update to 75% progress
        optimization_progress.update(step=75, 
                                   phase="Finalizing",
                                   message="Evolution complete, preparing final results...")
        
        # If no valid solution found
        if best_individual is None or best_fitness <= 0:
            optimization_progress.update(
                step=80,
                phase="Error",
                message="Genetic optimization failed: No valid solution found"
            )
            logger.error("Genetic optimization failed: No valid solution found")
            # Fall back to classic optimization
            optimization_progress.update(
                message="Falling back to classic optimization method..."
            )
            return perform_optimization(df, general_settings, optimization_settings)
        
        # Get the best result
        best_maturities = best_individual['maturities']
        best_nominals = best_individual['nominals']
        best_result = best_individual['result']
        
        # Get rates based on original data
        best_base_rates = [maturity_to_base_rate_A.get(get_nearest_maturity(m, original_maturities_A), 42.0) for m in best_maturities]
        best_reinvest_rates = [maturity_to_reinvest_rate_A.get(get_nearest_maturity(m, original_maturities_A), 30.0) for m in best_maturities]
        
        optimization_progress.update(step=90, 
                                   message="Creating optimization result...")
        
        logger.info("Genetic optimization completed successfully")
        
        # Prepare the result - ensure all values are of correct types
        result = OptimizationResult(
            best_strategy="genetic",
            class_a_maturities=[int(m) for m in best_maturities],  # Ensure integers
            class_a_nominals=best_nominals,
            class_a_rates=best_base_rates,
            class_a_reinvest=best_reinvest_rates,
            class_b_maturity=int(class_b_maturity),
            class_b_rate=class_b_base_rate_orig,
            class_b_reinvest=class_b_reinvest_rate_orig,
            class_b_nominal=best_result.get('b_nominal', 0),
            class_b_coupon_rate=best_result['results'].get('class_b_coupon_rate', 0),
            min_buffer_actual=best_result['results'].get('min_buffer_actual', 0),
            last_cash_flow_day=int(last_cash_flow_day),
            additional_days=int(additional_days),
            results_by_strategy={"genetic": best_result['results']}
        )
        
        # Final progress update to 100%
        optimization_progress.update(step=100, 
                                   phase="Complete",
                                   message="Genetic optimization completed successfully")
        
        return result
    except Exception as e:
        # Log error and update progress
        optimization_progress.update(
            step=100,
            phase="Error",
            message=f"Error during genetic optimization: {str(e)}"
        )
        
        # Detailed error logging
        logger.error(f"Genetic optimization error: {str(e)}")
        logger.debug(traceback.format_exc())
        
        # Fall back to classic optimization
        optimization_progress.update(
            message="Falling back to classic optimization method..."
        )
        return perform_optimization(df, general_settings, optimization_settings)

======================================================================

DOSYA: backend\app\utils\cash_flow_utils.py
==================================================
"""
Utility functions for cash flow processing and tranche calculations.
"""
import pandas as pd
import numpy as np
from datetime import timedelta
from typing import List, Dict, Any, Tuple
from app.utils.finance_utils import (
    get_next_business_day,
    simple_to_compound_annual,
    calculate_reinvestment_date
)

def assign_cash_flows_to_tranches(
    df: pd.DataFrame, 
    start_date: pd.Timestamp, 
    all_maturity_dates: List[pd.Timestamp], 
    all_reinvest_rates: List[float]
) -> List[List[Dict[str, Any]]]:
    """
    Distribute cash flows into tranches, adjust for weekends,
    and calculate reinvestment returns.
    
    Args:
        df: DataFrame containing cash flow data
        start_date: Start date for calculations
        all_maturity_dates: List of maturity dates for each tranche
        all_reinvest_rates: List of reinvestment rates for each tranche
        
    Returns:
        List of cash flow lists for each tranche
    """
    num_tranches = len(all_maturity_dates)
    tranch_cash_flows = [[] for _ in range(num_tranches)]
    
    for idx, row in df.iterrows():
        inst_date = row['installment_date']
        cf = row['cash_flow']
        principal_amt = row.get('principal_amount', 0)
        interest_amt = row.get('interest_amount', 0)
        
        if pd.isnull(inst_date) or inst_date < start_date:
            continue
        
        reinvest_date = calculate_reinvestment_date(inst_date)
        assigned = False
        
        # First pass - assign to the first matching tranche
        for i in range(num_tranches):
            if inst_date < all_maturity_dates[i]:
                if reinvest_date < all_maturity_dates[i]:
                    days_diff = (all_maturity_dates[i] - reinvest_date).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        r_return = cf * factor
                    else:
                        r_return = 0.0
                    tranch_cash_flows[i].append({
                        'date': inst_date,
                        'cash_flow': cf,
                        'principal_amount': principal_amt,
                        'interest_amount': interest_amt,
                        'reinvest_date': reinvest_date,
                        'reinvestment_return': r_return,
                        'moved_from': None
                    })
                    assigned = True
                    break
        
        # If not assigned in first pass
        if not assigned and num_tranches > 0:
            # Second pass - assign based on reinvest date
            re_assign = False
            for i in range(num_tranches):
                if reinvest_date < all_maturity_dates[i]:
                    days_diff = (all_maturity_dates[i] - reinvest_date).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        r_return = cf * factor
                    else:
                        r_return = 0.0
                    tranch_cash_flows[i].append({
                        'date': inst_date,
                        'cash_flow': cf,
                        'principal_amount': principal_amt,
                        'interest_amount': interest_amt,
                        'reinvest_date': reinvest_date,
                        'reinvestment_return': r_return,
                        'moved_from': None
                    })
                    re_assign = True
                    break
            
            # If still not assigned, put in the last tranche
            if not re_assign:
                last_idx = num_tranches - 1
                days_diff = (all_maturity_dates[last_idx] - reinvest_date).days
                if days_diff > 0:
                    r_compound = simple_to_compound_annual(all_reinvest_rates[last_idx]) / 100.0
                    factor = (1 + r_compound)**(days_diff/365) - 1
                    r_return = cf * factor
                else:
                    r_return = 0.0
                tranch_cash_flows[last_idx].append({
                    'date': inst_date,
                    'cash_flow': cf,
                    'principal_amount': principal_amt,
                    'interest_amount': interest_amt,
                    'reinvest_date': reinvest_date,
                    'reinvestment_return': r_return,
                    'moved_from': None,
                    'note': 'Reinvestment date >= all'
                })
    
    # Third pass: if reinvest_date >= current tranche maturity, move the cash flow to a later tranche
    for i in range(num_tranches-1):
        final_cf = []
        for cf_info in tranch_cash_flows[i]:
            if cf_info['reinvest_date'] >= all_maturity_dates[i]:
                moved = False
                for j in range(i+1, num_tranches):
                    if cf_info['reinvest_date'] < all_maturity_dates[j]:
                        days_diff = (all_maturity_dates[j] - cf_info['reinvest_date']).days
                        if days_diff > 0:
                            r_compound = simple_to_compound_annual(all_reinvest_rates[j]) / 100.0
                            factor = (1 + r_compound)**(days_diff/365) - 1
                            new_ret = cf_info['cash_flow'] * factor
                        else:
                            new_ret = 0.0
                        new_cf = dict(cf_info)
                        new_cf['reinvestment_return'] = new_ret
                        new_cf['moved_from'] = i
                        tranch_cash_flows[j].append(new_cf)
                        moved = True
                        break
                
                if not moved and (i+1) < num_tranches:
                    last_i = num_tranches - 1
                    days_diff = (all_maturity_dates[last_i] - cf_info['reinvest_date']).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[last_i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        new_ret = cf_info['cash_flow'] * factor
                    else:
                        new_ret = 0.0
                    new_cf = dict(cf_info)
                    new_cf['reinvestment_return'] = new_ret
                    new_cf['moved_from'] = i
                    tranch_cash_flows[last_i].append(new_cf)
            else:
                final_cf.append(cf_info)
        
        tranch_cash_flows[i] = final_cf
    
    return tranch_cash_flows

def calculate_totals(
    cash_flows: List[Dict[str, Any]], 
    maturity_date: pd.Timestamp, 
    reinvest_rate: float
) -> Tuple[float, float, float, float]:
    """
    Calculate totals for a tranche.
    
    Args:
        cash_flows: List of cash flow information dictionaries
        maturity_date: Maturity date for the tranche
        reinvest_rate: Reinvestment rate for the tranche
        
    Returns:
        Tuple of (total_cash_flow, total_reinvest, total_principal, total_interest)
    """
    r_comp = simple_to_compound_annual(reinvest_rate)
    total_cash_flow = 0.0
    total_principal = 0.0
    total_interest = 0.0
    total_reinvest = 0.0
    
    for c in cash_flows:
        cf = c['cash_flow']
        principal = c.get('principal_amount', 0)
        interest = c.get('interest_amount', 0)
        
        total_cash_flow += cf
        total_principal += principal
        total_interest += interest
        
        rd = c['reinvest_date']
        days_diff = (maturity_date - rd).days
        
        if days_diff > 0:
            factor = (1 + r_comp/100)**(days_diff/365) - 1
            ret = cf * factor
            total_reinvest += ret
    
    return total_cash_flow, total_reinvest, total_principal, total_interest

======================================================================

DOSYA: backend\app\utils\finance_utils.py
==================================================
# backend/app/utils/finance_utils.py
import pandas as pd
from datetime import datetime, timedelta

def simple_to_compound_annual(simple_rate_percent):
    """Convert an annual simple rate (in %) to an annual compounded rate (in %)."""
    r_simple = simple_rate_percent / 100.0
    # daily rate under simple assumption:
    r_daily = r_simple / 365
    annual_compound = (1 + r_daily)**365 - 1
    return annual_compound * 100.0

def simple_to_maturity_compound(simple_rate_percent, days):
    """Convert a simple rate over 'days' to an equivalent annual compounded rate."""
    if days <= 0:
        return 0.0
    r_simple = simple_rate_percent / 100.0
    period_simple = r_simple * (days / 365)  # portion of the year
    period_compound = (1 + period_simple)**(365 / days) - 1
    return period_compound * 100.0

def overnight_to_annual_compound(simple_rate_percent):
    """Convert an annual simple rate to annual compound."""
    daily_rate = simple_rate_percent / 365 / 100
    annual_compound = (1 + daily_rate)**365 - 1
    return annual_compound * 100.0

def get_next_business_day(date):
    """If the date falls on a weekend, move it to the next business day."""
    while date.weekday() >= 5:  # 5=Saturday, 6=Sunday
        date += timedelta(days=1)
    return date

def calculate_reinvestment_date(installment_date):
    """Adjust the installment date for weekends and add 1 day."""
    if installment_date.weekday() >= 5:
        installment_date = get_next_business_day(installment_date)
    reinvest_date = installment_date + timedelta(days=1)
    reinvest_date = get_next_business_day(reinvest_date)
    return reinvest_date

def get_nearest_maturity(target_maturity, available_maturities):
    """Find the closest maturity day in the available maturities."""
    return min(available_maturities, key=lambda x: abs(x - target_maturity))

def get_last_cash_flow_day(df, start_date):
    """Find the last cash flow day and calculate as days from start date."""
    start_date = pd.Timestamp(start_date)
    last_cash_flow_date = df['installment_date'].max()
    
    if pd.notna(last_cash_flow_date):
        days = (last_cash_flow_date - start_date).days
        return max(0, days)  # Should not be negative
    else:
        return 365  # Default value

======================================================================

